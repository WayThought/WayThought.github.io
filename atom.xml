<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>钱多多的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://waythought.duoshuo.com/"/>
  <updated>2018-01-03T09:31:12.000Z</updated>
  <id>http://waythought.duoshuo.com/</id>
  
  <author>
    <name>Qian.G.j</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>08-.gitignore相关</title>
    <link href="http://waythought.duoshuo.com/2017/10/27/08.gitignore/"/>
    <id>http://waythought.duoshuo.com/2017/10/27/08.gitignore/</id>
    <published>2017-10-27T00:59:59.000Z</published>
    <updated>2018-01-03T09:31:12.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-作用"><a href="#1-作用" class="headerlink" title="1.作用:"></a>1.作用:</h4><p>利用.gitignore过滤文件，如编译过程中的中间文件，等等，这些文件不需要被追踪管理。<br><a href="https://github.com/github/gitignore" target="_blank" rel="external"><font size="3">内容参考gitHub</font></a></p><h4 id="2-gitignore无效，不能过滤某些文件"><a href="#2-gitignore无效，不能过滤某些文件" class="headerlink" title="2.gitignore无效，不能过滤某些文件"></a>2.gitignore无效，不能过滤某些文件</h4><ul><li>现象：<br>在.gitignore添加file1文件，以过滤该文件，但是通过git status查看仍显示file1文件的状态。</li><li>原因：<br>在git库中已存在了这个文件，之前push提交过该文件。<br>.gitignore文件只对还没有加入版本管理的文件起作用，如果之前已经用git把这些文件纳入了版本库，就不起作用了</li><li>解决：<br>需要在git库中删除该文件，并更新。<br>然后再次git status查看状态，file1文件不再显示状态。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-作用&quot;&gt;&lt;a href=&quot;#1-作用&quot; class=&quot;headerlink&quot; title=&quot;1.作用:&quot;&gt;&lt;/a&gt;1.作用:&lt;/h4&gt;&lt;p&gt;利用.gitignore过滤文件，如编译过程中的中间文件，等等，这些文件不需要被追踪管理。&lt;br&gt;&lt;a href=&quot;ht
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>07-JavaScript &amp;&amp; iOS原生交互</title>
    <link href="http://waythought.duoshuo.com/2017/10/21/07-JavaScript%20&amp;&amp;%20iOS%E5%8E%9F%E7%94%9F%E4%BA%A4%E4%BA%92/"/>
    <id>http://waythought.duoshuo.com/2017/10/21/07-JavaScript &amp;&amp; iOS原生交互/</id>
    <published>2017-10-21T08:33:40.000Z</published>
    <updated>2018-01-04T12:40:43.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JavaScript-amp-amp-iOS原生交互"><a href="#JavaScript-amp-amp-iOS原生交互" class="headerlink" title="JavaScript &amp;&amp; iOS原生交互"></a>JavaScript &amp;&amp; iOS原生交互</h3><p><img src="https://cl.ly/2d2u0Y1C1a0r" alt="图片"><br>JavaScript &amp;&amp; iOS原生交互第三方框架:<br><a href="https://github.com/marcuswestin/WebViewJavascriptBridge" target="_blank" rel="external">WebViewJavascriptBridge</a></p><h4 id="1-简单用法-OC执行JS"><a href="#1-简单用法-OC执行JS" class="headerlink" title="1. 简单用法(OC执行JS)"></a>1. 简单用法(OC执行JS)</h4><pre><code>UIWebView在webViewDidFinishLoad里使用 - (nullable NSString *)stringByEvaluatingJavaScriptFromString:(NSString *)script;// 获取当前页面的titleNSString *title = [webview stringByEvaluatingJavaScriptFromString:@&quot;document.title&quot;];// 获取当前页面的urlNSString *url = [webview stringByEvaluatingJavaScriptFromString:@&quot;document.location.href&quot;];</code></pre><h4 id="2-OC执行JS-amp-amp-JS执行OC"><a href="#2-OC执行JS-amp-amp-JS执行OC" class="headerlink" title="2. OC执行JS &amp;&amp; JS执行OC"></a>2. OC执行JS &amp;&amp; JS执行OC</h4><pre><code>2.1 JavaScriptCore:iOS7后引用,里面包含常见的对象及协议如下:JSContext：给JavaScript提供运行的上下文环境,通过-evaluateScript:方法就可以执行一JS代码JSValue：JavaScript和Objective-C数据和方法的桥梁,封装了JS与ObjC中的对应的类型，以及调用JS的API等JSManagedValue：管理数据和方法的类JSVirtualMachine：处理线程相关，使用较少JSExport：这是一个协议，如果采用协议的方法交互，自己定义的协议必须遵守此协议</code></pre><p>注:</p><blockquote><p>JSContext 和 JSValue : JSVirtualMachine 为JavaScript的运行提供了底层资源,JSContext为JavaScript其提供着运行环境,通过evaluateScript方法就可以执行一段JavaScript脚本,并且如果其中有方法,变量等信息都会被存储在其中以便在需要的时候使用。而JSContext的创建都是基于JSVirtualMachine(initwithVirtualMachine:),如果使用init进行初始化,那么在其内部会自动创建一个新的JSVirtualMachine对象然后调用前边的初始化方法。<br>JSValue是JSContext执行后的返回结果,封装了JS与ObjC中的对应的类型,可以方便的在两种类型之间转换,可以说是JavaScript和Object-C之间互换的桥梁</p></blockquote><pre><code>Objective-C type  |   JavaScript type</code></pre><p>   ——————–+———————<br>           nil         |     undefined<br>          NSNull       |        null<br>         NSString      |       string<br>         NSNumber      |   number, boolean<br>       NSDictionary    |   Object object<br>         NSArray       |    Array object<br>          NSDate       |     Date object<br>         NSBlock (1)   |   Function object (1)<br>            id (2)     |   Wrapper object (2)<br>          Class (3)    | Constructor object (3)</p><blockquote><p>JSVirtualMachine : “A JSVirtualMachine instance represents a self-contained environment for JavaScript execution.”，这段话是官方文档中对JSVirtualMachine的定义，我们使用JSVirtualMachine的目的主要有两个：支持JavaScript并发执行，管理用于衔接JavaScript 与 OC(Swift) 代码的对象的内存。</p></blockquote><p>#####2.1 简单直接调用JS代码<br>        // 一个JSContext对象<br>        self.jsContext = [[JSContext alloc] init];</p><pre><code>//  jscontext可以直接执行JS代码。[self.jsContext evaluateScript:@&quot;var num = 10&quot;];[self.jsContext evaluateScript:@&quot;var squareFunc = function(value) { return value * 2 }&quot;];// 计算正方形的面积JSValue *square = [self.jsContext evaluateScript:@&quot;squareFunc(num)&quot;];// 也可以通过下标的方式获取到方法JSValue *squareFunc = self.jsContext[@&quot;squareFunc&quot;];// 将参数传进去来调用方法JSValue *value = [squareFunc callWithArguments:@[@&quot;20&quot;]];NSLog(@&quot;%@&quot;, square.toNumber);NSLog(@&quot;%@&quot;, value.toNumber);</code></pre><p>#####2.2 快读调用Block,可以传入参数</p><pre><code>JSContext *context = [[JSContext alloc] init];context[@&quot;log&quot;] = ^() {NSLog(@&quot;+++++++Begin Log+++++++&quot;);// 获取当前参数列表NSArray *args = [JSContext currentArguments];for (JSValue *jsVal in args) {NSLog(@&quot;%@&quot;, jsVal);}// 获取当前调用该方法的对象JSValue *this = [JSContext currentThis];NSLog(@&quot;this: %@&quot;,this);NSLog(@&quot;-------End Log-------&quot;);};[context evaluateScript:@&quot;log(&apos;ider&apos;, [7, 21], { hello:&apos;world&apos;, js:100 });&quot;];//// Output:// +++++++Begin Log+++++++// ider// 7,21// [object Object]// this: [object GlobalObject]// -------End Log-------</code></pre><h3 id="3-协议、模型实现"><a href="#3-协议、模型实现" class="headerlink" title="3.协议、模型实现"></a>3.协议、模型实现</h3><p>事先和前端wap协商格式、定义方法的名字和参数的顺序<br>    3.1 定义一个模型 KNOCJSModel<br>    3.2 在该模型实现以下协议(协议中定义需要暴露给js的属性和方法)</p><pre><code>@protocol KNOCJSObjectProtocol &lt;JSExport&gt;// 在JS中调用时，函数名应该为showAlertMsg(arg1, arg2)// 这里是只两个参数的。- (void)showAlert:(NSString *)title msg:(NSString *)msg;// JS调用Oc，然后在OC中通过调用JS方法来传值给JS。- (void)jsCallObjcAndObjcCallJsWithDict:(NSDictionary *)params;@endtypedef void (^KNOCJSModelDetailAlertBlock)(NSString * title, NSString *message);typedef void (^KNOCJSModelDetailCallJsBlock)(NSDictionary *dic);@interface ObjCModel : NSObject &lt;JavaScriptObjectiveCDelegate&gt;@property (nonatomic, copy) KNOCJSModelDetailAlertBlock alertBlock;@property (nonatomic, copy) KNOCJSModelDetailCallJsBlock callJsBlock;@end</code></pre><p>3.3实现模型</p><pre><code>@implementation ObjCModel- (void)showAlert:(NSString *)title msg:(NSString *)msg {    if (self. alertBlock) {        self.alertBlock(title, msg)    }}- (void)jsCallObjcAndObjcCallJsWithDict:(NSDictionary *)params {    if (self. callJsBlock) {        self. callJsBlock(params);    }    }@end</code></pre><p>3.4 在控制器中webView加载完成的代理中,给JSContext注入模型</p><pre><code>#pragma mark - UIWebViewDelegate- (void)webViewDidFinishLoad:(UIWebView *)webView {  JSContext *context = [webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;]; // 通过模型调用方法，这种方式更好些。 KNOCJSModel *objectModel  = [[KNOCJSModel alloc] init]; context[@&quot;native&quot;] = objectModel;__weak typeof(self) weakSelf = selfobjectModel.alertBlock = ^(NSString *title, NSString *msg) {    dispatch_async(dispatch_get_main_queue(), ^{    UIAlertView *alert = [[UIAlertView alloc] initWithTitle:title message:msg delegate:nil cancelButtonTitle:@&quot;Ok&quot; otherButtonTitles:nil, nil];        [alert show];    });};objectModel.callJsBlock = ^(NSDictionary *dic) {    dispatch_async(dispatch_get_main_queue(), ^{        // 第一种方式        JSValue *jsParamFunc = context[@&quot;jsParamFunc&quot;];        [jsParamFunc callWithArguments:@[@{@&quot;age&quot;: @10, @&quot;name&quot;: @&quot;lili&quot;, @&quot;height&quot;: @158}]];        // 第二种方式         NSString *alertUserInfo = [NSString stringWithFormat:@&quot;jsParamFunc(&apos;%@&apos;,&apos;%@&apos;,&apos;%@&apos;)&quot;, @10, @&quot;lili&quot;, @158];        [context evaluateScript:alertUserInfo];    });}; context.exceptionHandler = ^(JSContext *context, JSValue *exceptionValue) {   context.exception = exceptionValue;   NSLog(@&quot;异常信息：%@&quot;, exceptionValue); };}</code></pre><p>3.5 在html中的body中添加以下代码:(这里要和wap端统一好)<font color="#0099ff" size="3" face="黑体">‘native’</font></p><pre><code>    &lt;div style=&quot;margin-top: 100px&quot;&gt;&lt;h1&gt;Test how to use objective-c call js&lt;/h1&gt;&lt;input type=&quot;button&quot; value=&quot;Call ObjC system alert&quot; onclick=&quot;native.showAlertMsg(&apos;js title&apos;, &apos;js message&apos;)&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;input type=&quot;button&quot; value=&quot;Call ObjC func with JSON and ObjC call js func to pass args.&quot; onclick=&quot;native.jsCallObjcAndObjcCallJsWithDict({&apos;name&apos;: &apos;testname&apos;, &apos;age&apos;: 10, &apos;height&apos;: 170})&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;span id=&quot;jsParamFuncSpan&quot; style=&quot;color: red; font-size: 50px;&quot;&gt;&lt;/span&gt;&lt;/div&gt;也可自己在控制器中执行js代码调用- (void)useJSExprot {      JSContext *context = [self.webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;];      KNOCJSModel *objectModel  = [[KNOCJSModel alloc] init];      context[@&quot;native&quot;] = objectModel;      [context evaluateScript:@&quot;objectModel.showAlertMsg()&quot;]}</code></pre><p>保留:<br>    1.在Block内都不要直接使用其外部定义的JSContext对象或者JSValue，应该将其当做参数传入到Block中，或者通过JSContext的类方法+ (JSContext *)currentContext;来获得。否则会造成循环引用使得内存无法被正确释放。<br>    2.如果js端的方法是这样的<br>func viewDetailLoginNamePassWord(String name, String passWord) {</p><p>}</p><p>我们可以用<br>第一种:</p><ul><li>(void)viewDetailLoginName:(NSString *)loginName<pre><code>PassWord:(NSString *)passWord;</code></pre></li></ul><p>第二种:<br>JSExportAs(viewDetailLoginNamePassWord,<br>           -(void)viewDetailLoginNamePassWord:(NSString <em>)loginName psd:(NSString </em>)psd;)<br><a href="http://www.jianshu.com/p/fad8c7844d3e" target="_blank" rel="external">http://www.jianshu.com/p/fad8c7844d3e</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;JavaScript-amp-amp-iOS原生交互&quot;&gt;&lt;a href=&quot;#JavaScript-amp-amp-iOS原生交互&quot; class=&quot;headerlink&quot; title=&quot;JavaScript &amp;amp;&amp;amp; iOS原生交互&quot;&gt;&lt;/a&gt;JavaS
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>06-Objectview-C 中变量采用@property的各个关键字的含义</title>
    <link href="http://waythought.duoshuo.com/2017/10/17/06-Objectview-C%20%E4%B8%AD%E5%8F%98%E9%87%8F%E9%87%87%E7%94%A8@property%E7%9A%84%E5%90%84%E4%B8%AA%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%90%AB%E4%B9%89/"/>
    <id>http://waythought.duoshuo.com/2017/10/17/06-Objectview-C 中变量采用@property的各个关键字的含义/</id>
    <published>2017-10-17T07:44:24.000Z</published>
    <updated>2017-10-31T12:45:48.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Objectview-C-中变量采用-property的各个关键字的含义"><a href="#Objectview-C-中变量采用-property的各个关键字的含义" class="headerlink" title="Objectview-C 中变量采用@property的各个关键字的含义"></a>Objectview-C 中变量采用@property的各个关键字的含义</h3><h4 id="1-property的本质是什么"><a href="#1-property的本质是什么" class="headerlink" title="1.@property的本质是什么?"></a>1.@property的本质是什么?</h4><p>@property = ivar + getter + setter<br>“属性”(property) = 实例变量 + 存取方法<br>OC2.0开始,系统提供了自动生成设置变量值得方法或获取变量值得方法,让我们有更多的精力放在程序的业务逻辑上</p><h4 id="2-ARC下-不显示指定任何属性性关键字时-默认的关键字有哪些"><a href="#2-ARC下-不显示指定任何属性性关键字时-默认的关键字有哪些" class="headerlink" title="2.ARC下,不显示指定任何属性性关键字时,默认的关键字有哪些?"></a>2.ARC下,不显示指定任何属性性关键字时,默认的关键字有哪些?</h4><pre><code>对于基本数据类型默认关键字是:atomic,readwrite,assign对于普通的OC对象:atomic,readwrite,strong</code></pre><h4 id="3-copy关键字"><a href="#3-copy关键字" class="headerlink" title="3.copy关键字"></a>3.copy关键字</h4><pre><code>3.1 NSString,NSArray,NSDictionary等等经常使用copy关键字,是因为他们有对应的可变类型:NSMutableString、NSMutableArray、NSMutableDictionary；是对应的子类,他们之间可能进行赋值操作,为确保对象中的字符串值不会无意间变动,应该在设置新属性值时拷贝一份3.2 block 也经常使用copy关键字,这是从MRC遗留下的&quot;传统&quot;,在MRC中,方法内部的block是在栈区的,使用copy可以把它放在堆区;ARC中写不写都行: 对于block使用copy还是strong效果是一样的,但写上copy能够提醒我们:编译器自动对block进行了copy操作。3.3 小试牛刀:    这个写法会出什么问题 @property (copy) NSMutableArray *array;    3.3.1 添加,删除,修改数组内的元素的时候,程序会因为找不到对应的方法而崩溃,因为copy是复制的一个不可变的NSArray的对象    3.3.2 默认关键字是atomic属性会严重影响性能</code></pre><h4 id="4-weak-关键字"><a href="#4-weak-关键字" class="headerlink" title="4. weak 关键字"></a>4. weak 关键字</h4><pre><code>4.1 在ARC中,有可能出现循环引用的时候,往往要通过让其中一端使用weak来解决,比如delegate代理4.2 自身已经对它进行一次强引用,没有必要再强引用一次,此时也会使用weak,自定义IBOutlet控件的属性一般也使用weak。</code></pre><h4 id="5-assign"><a href="#5-assign" class="headerlink" title="5. assign"></a>5. assign</h4><pre><code>只会执行基本类型的简单赋值操作,既不保留新值,也不释放旧值。</code></pre><h4 id="6-retain"><a href="#6-retain" class="headerlink" title="6. retain"></a>6. retain</h4><pre><code>释放旧的对象，将旧对象的值赋予输入对象，再提高输入对象的索引计数为1</code></pre><h4 id="7-nonnull"><a href="#7-nonnull" class="headerlink" title="7.nonnull:"></a>7.nonnull:</h4><pre><code>不能为空,用来修饰属性,或者方法的参数,方法的返回值,不适用于assign属性,因为他是专门用来修饰指针的 @property (nonatomic, copy, nonnull) NSString *name;  @property (nonatomic, copy) NSString * _Nonnull name;   @property (nonatomic, copy) NSString * __nonnull name;</code></pre><h4 id="8-nullable"><a href="#8-nullable" class="headerlink" title="8.nullable:"></a>8.nullable:</h4><pre><code>表示可以为空,代码提示会告诉你这个谁能够是可以为空的@property (nonatomic, copy, nullable) NSString *name;@property (nonatomic, copy) NSString *_Nullable name;@property (nonatomic, copy) NSString *__nullable name;</code></pre><h4 id="9-null-resettable"><a href="#9-null-resettable" class="headerlink" title="9.null_resettable:"></a>9.null_resettable:</h4><pre><code>表示get方法不能返回为空,set方法可以为空 ⚠️⚠️⚠️ 必须重写该属性的get方法,保证返回值不为空tan @property(nonatomic,strong,null_resettable) NSNumber * number;(只有这一种方式)</code></pre><h4 id="10-null-unspecified"><a href="#10-null-unspecified" class="headerlink" title="10.null_unspecified"></a>10.null_unspecified</h4><pre><code>表示不确定是否为空,使用方式有三种: @property(nonatomic,strong) NSNumber *_Null_unspecified height; @property(nonatomic,strong) NSNumber *__null_unspecified height;  @property(nonatomic,strong,null_unspecified) NSNumber * height;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Objectview-C-中变量采用-property的各个关键字的含义&quot;&gt;&lt;a href=&quot;#Objectview-C-中变量采用-property的各个关键字的含义&quot; class=&quot;headerlink&quot; title=&quot;Objectview-C 中变量采用@p
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>05-git教程</title>
    <link href="http://waythought.duoshuo.com/2017/07/07/05-git%E6%95%99%E7%A8%8B/"/>
    <id>http://waythought.duoshuo.com/2017/07/07/05-git教程/</id>
    <published>2017-07-07T04:34:25.000Z</published>
    <updated>2018-01-03T09:30:30.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>SVN: 集中式的版本控制系统. 本地只有文件,没有版本库,所有的代码只在服务器上有版本记录,如果要进行版本的回退,和一些tag操作,必须经过服务器</p></li><li><p>Git: 分布式版本控制系统,每个人电脑就有版本库.写完代码,先提交到本地的版本,让后提交到服务器上,最后每个电脑都有一个最新的代码</p><pre><code>git也要配置服务器, 但是服务器的作用, 只是作为一个中间桥梁供开发人员去同步代码用的.git有机器强大的分支管理,把SVN等远远抛在了后面</code></pre></li></ul><h4 id="1-远程仓库"><a href="#1-远程仓库" class="headerlink" title="1.远程仓库"></a>1.远程仓库</h4><ul><li><p>1.1 创建SSH Key. 在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。使用以下命令创建SSH Key：(替换成你的邮箱地址).</p><pre><code>$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</code></pre></li><li><p>1.2 在用户主目录中找到.ssh目录,里面有id_rsa(私钥)和id_rea.pub(公钥),打开id_rea.pub并记录下来.</p></li><li><p>1.3 登录GitHub,打开”Account settings”,”SSH Key”页面,添加Key,把id_rea.pub内容添加进去.</p><pre><code>git需要在GitHup,OsChina,GitLabel中添加自己的公钥由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的,GitHub只要知道了你的公钥,就可以在每台电脑上往GitHub推送了.</code></pre><a id="more"></a></li><li><p>1.4 添加远程库</p><pre><code>在GitHub上创建仓库,使用下面命令,把这个远程的仓库与本地已有的仓库进行关联,之后就可以把本地仓库的内容推送到GitHub仓库了,注意是SSH的,传输相比http稳定cd 到本地文件        $ git remote add origin git@github.com:WayThought/blog.git</code></pre></li></ul><p>git remote  查看远程库的信息</p><pre><code>$ git remote origin或者，用git remote -v显示更详细的信息：</code></pre><ul><li><p>1.5 从远程库克隆(当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。)</p><pre><code> cd 到本地文件        $ git clone git@github.com:WayThought/blog.git</code></pre><p>这样就把远程的仓库克隆到了本地</p></li></ul><h4 id="2-本地分支管理"><a href="#2-本地分支管理" class="headerlink" title="2.本地分支管理"></a>2.本地分支管理</h4><p>git status: 查看文件的状态</p><p>git add : 提交有修改的文件,由工作区到暂存区</p><pre><code>git add 文件名  添加指定修改的文件到暂存区git add .  添加当前目录所有有修改的文件到暂存区</code></pre><p>git commit : 提交暂存区的文件到本地版本库</p><pre><code>git commit -m &quot;注释&quot; 文件名  提交指定的文件到本地仓库git commit -m &quot;注释&quot;        提交所有的文件到本地仓库</code></pre><p>(需要提交的改动文件,必须先add加到缓存区,再commit到版本区)</p><p>git pull和push命令是本地仓库和远程仓库(服务器)打交道的,一般在push之前都会先pull下代码,如果有冲突,解决完冲突再push</p><pre><code>git pull 从服务器上更新代码到本地仓库,切换到本地需要提交的分支(dev)git pull origin dev  把服务器远程仓库更新的代码拉到本地仓库git push origin dev  把本地仓库的代码更新推送到服务器上</code></pre><p>创建与合并分支(当前分支为master)</p><pre><code>git branch  查看当前分支git branch dev origin/dev 切换到分支devgit checkout dev    切换到分支devgit checkout -b dev   创建dev分支,然后切换到dev分支git merge dev  把dev的工作内容合并到master上(分支A合并分支B,与分支B合并分支A是一样的)</code></pre><h4 id="3-版本回退"><a href="#3-版本回退" class="headerlink" title="3.版本回退"></a>3.版本回退</h4><pre><code>git log  显示历史记录(写周报或者查看版本号)git reflog 来记录你的每一次命令(版本回退后,可以找到上一个版本的commit id )git reset --hard HEAD^ 回退到上一个版本git reset --hard HEAD^^ 回退到上上个版本git reset --hard HEAD 版本号 回退到指定的版本注: 如何找回删除的分支    3.1 通过git reflog 命令找到我们需要恢复的信息对应的commit_id (根据log 提交的日期时间)    3.2 通过git branch 新分支名字 对应的commit_id 来建立一个新的分支,吧丢失的东西恢复到新分支上</code></pre><h4 id="4-补充"><a href="#4-补充" class="headerlink" title="4.补充:"></a>4.补充:</h4><p>4.1 常用命令:<br>    git config user.name 查看用户名<br>    git config user.email 查看邮箱地址<br>    git config –global user.name “Your Name”  提交名字<br>    git config –global user.email you@example.com  提交邮箱</p><pre><code>git co  -- &lt;file&gt;   # 抛弃工作区修改git co  .           # 抛弃工作区修改git rm &lt;file&gt;       # 从版本库中删除文件git rm &lt;file&gt; --cached  # 从版本库中删除文件，但不删除文件git reset &lt;file&gt;    # 从暂存区恢复到工作文件git reset -- .      # 从暂存区恢复到工作文件git reset --hard    # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改git stash listgit stash pop  恢复的同时把stash内容也删了git checkout -- readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销git checkout -- . 把工作区的修改全部撤销(版本相同的两个分支)未add和commit的内容如果checkout另一个分支会带过去 可以来回切换</code></pre><p>4.2 常见问题:</p><p>4.2.1 git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接：</p><pre><code>$ git branch --set-upstream dev origin/dev</code></pre><p>4.2.2 将本地项目添加到远程的仓库</p><pre><code>1.远程建立仓库,并克隆到本地(例如:storeHouse)2.将本地的项目拷贝到storeHouse文件中3.使用 git init 命令4.使用 $ git remote add origin git@github.com:WayThought/blog.git 5. git add . 6. git commit 7. git push </code></pre><p>4.2.3 将本地分支推送到远程分支:(如果远程分支不存在则会自动创建分支)<br>git push origin 本地分支名:远程分支名<br>4.2.4 远程分支版本的回退</p><pre><code>切换到本地分支对应着的远程分支git push origin HEAD --force #远程提交回退</code></pre><p>4.2.5 删除远程分支<br>git push origin - -delete 远程分支名</p><p>4.3 补充：<br>查看本地分支与远端分支的差异：<br>git diff master..远程仓库名字/master<br>4.4 将本地分支推送到远端服务器：<br>git push 远程仓库名字 分支名字<br>4.4 寻找回退的commit-id(后悔药)<br>git reflog</p><p>ea34578 HEAD@{0}: reset: moving to HEAD^<br>3628164 HEAD@{1}: commit: append GPL<br>ea34578 HEAD@{2}: commit: add distributed<br>做完后面的操作的形成前面的commit-id</p><h3 id="5-0冲突"><a href="#5-0冲突" class="headerlink" title="5.0冲突"></a>5.0冲突</h3><h4 id="5-1常见冲突"><a href="#5-1常见冲突" class="headerlink" title="5.1常见冲突:"></a>5.1常见冲突:</h4><pre><code>第一种: 项目可以打开,报错-&gt;直接去找,对别人的改动要进行沟通决定是否要保留第二种: 项目打开失败git status 查看哪个文件冲突(一般是配置文件)open 路径 搜索&quot;===“,删除后没有恢复的话 说明删除错误了 -&gt;重新删除&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADCreating a new branch is quick &amp; simple.=======Creating a new branch is quick AND simple.&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1</code></pre><p>上面那个是HEAD分支的,下面这个是feature1分支,沟通后决定保留或删除</p><h4 id="5-2-pbxproj文件冲突"><a href="#5-2-pbxproj文件冲突" class="headerlink" title="5.2 pbxproj文件冲突"></a>5.2 pbxproj文件冲突</h4><p>比较麻烦的一种冲突,企业开发经常会遇到project.pbxproj文件冲突的问题,project.pbxproj文件主要包含了以下几项主要信息:</p><pre><code>1.工程文件关联信息, 如PBXBuildFile PBXFileReference2.组织结构分类信息, 如PBXGroup3.项目工程配置信息, 如XCBuildConfiguration XCConfigurationList</code></pre><p>解决办法:</p><pre><code>1. 1.1 笨方法1: 由于删除自己的修改的部分还是没有办法打开工程,所以要将上一个版本的project.pbxproj文件导出来，替换掉现有的project.pbxproj文件,但是添加到工程中的文件不见了,后来其实在工程里面看不到了而已,在对应文件目录还是能找到的,只要将这些文件拖一遍到工程里就ok了,(注意看下工程的Compile Sources,有时候会不显示添加的类)    1.2 笨方法2: 将project.pbxproj文件文件中一个版本的的冲突都删除掉,根据编译报的错误去添加对应的类(注意不要重复添加),在对应文件目录还是能找到的,只要将这些文件拖一遍到工程里就ok了2.预防:需要增加文件时先增加完空文件后立刻check一次，让别人每次改动 pbxproj的时候改动之前check一次，保证有交叉时间是可能性最小3.将不同分支导致的对象进行重新排序,先排序冲突里面相同的对象,然后是重命名或移动了的对象,最后是两边各自新增的对象,(根据sourceCode进行排序)</code></pre><h3 id="6-0-建议"><a href="#6-0-建议" class="headerlink" title="6.0 建议"></a>6.0 建议</h3><pre><code>项目开发的时候 可以单独建立一个分支dev_x  并行发开人员的每天或者几天合并下代码,合并到dev_x  比较方便,避免最后批量合并代码</code></pre><p>参考资料:<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/" target="_blank" rel="external">廖雪峰的博客</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;SVN: 集中式的版本控制系统. 本地只有文件,没有版本库,所有的代码只在服务器上有版本记录,如果要进行版本的回退,和一些tag操作,必须经过服务器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Git: 分布式版本控制系统,每个人电脑就有版本库.写完代码,先提交到本地的版本,让后提交到服务器上,最后每个电脑都有一个最新的代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git也要配置服务器, 但是服务器的作用, 只是作为一个中间桥梁供开发人员去同步代码用的.
git有机器强大的分支管理,把SVN等远远抛在了后面
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;1-远程仓库&quot;&gt;&lt;a href=&quot;#1-远程仓库&quot; class=&quot;headerlink&quot; title=&quot;1.远程仓库&quot;&gt;&lt;/a&gt;1.远程仓库&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;1.1 创建SSH Key. 在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。使用以下命令创建SSH Key：(替换成你的邮箱地址).&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ssh-keygen -t rsa -C &amp;quot;youremail@example.com&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;1.2 在用户主目录中找到.ssh目录,里面有id_rsa(私钥)和id_rea.pub(公钥),打开id_rea.pub并记录下来.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;1.3 登录GitHub,打开”Account settings”,”SSH Key”页面,添加Key,把id_rea.pub内容添加进去.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git需要在GitHup,OsChina,GitLabel中添加自己的公钥
由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的,GitHub只要知道了你的公钥,就可以在每台电脑上往GitHub推送了.
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>03-iOS单元测试</title>
    <link href="http://waythought.duoshuo.com/2017/06/21/03-iOS%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    <id>http://waythought.duoshuo.com/2017/06/21/03-iOS单元测试/</id>
    <published>2017-06-21T07:03:43.000Z</published>
    <updated>2018-01-03T09:29:59.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>我是从去年开始写单元测试的,平常也只是使用测试一下接口的测试,最近有时间网上查找下了资料总结一下,也是有个归纳吧</p><h2 id="单元测试简介"><a href="#单元测试简介" class="headerlink" title="单元测试简介"></a>单元测试简介</h2><blockquote><p>单元测试是指开发者编写代码,检测代码。合理的利用单元测试可以提高软件的质量</p><p>代码检测通常需要预先设置边界条件,因为UI测试的时候,很多边界条件不容易满足。主要针对<font color="#0099ff" size="3" face="黑体">业务逻辑</font>进行测试,不适合做UI的测试。</p><p>MVVM的设计模式,把几乎所有重要的业务逻辑全部封装在视图模型中,通过单元测试就很方便检测条件以及代码质量。</p></blockquote><h2 id="什么方法或者函数需要测试"><a href="#什么方法或者函数需要测试" class="headerlink" title="什么方法或者函数需要测试"></a>什么方法或者函数需要测试</h2><pre><code>1.私有方法不需要测试,面向对象有一个原则:开闭原则! 暴露在.h中的方法需要测试,2. 所有跟UI有关的都不需要测试,有UI的交互。MVVM 把小的业务逻辑封装出来,变成可以测试的代码,让程序更加健壮。3.一般而言,代码的覆盖度大概在50% ~ 70%</code></pre><h2 id="苹果自带的XCTest"><a href="#苹果自带的XCTest" class="headerlink" title="苹果自带的XCTest"></a>苹果自带的XCTest</h2><pre><code>/** 单元测试开始前调用 */- (void)setUp {[supersetUp];// Put setup code here. This method is called before the invocation of each test method in the class.}</code></pre><a id="more"></a><pre><code>/** 单元测试结束前调用 */- (void)tearDown {// Put teardown code here. This method is called after the invocation of each test method in the class.[supertearDown];}/** 测试代码可以写到以test开头的方法中 并且test开头的方法左边会生成一个菱形图标，点击即可运行检测当前test方法内的代码 */- (void)testExample {// This is an example of a functional test case.// Use XCTAssert and related functions to verify your tests produce the correct results.}/** 测试性能 */- (void)testPerformanceExample {// This is an example of a performance test case.[selfmeasureBlock:^{// 测量执行时间的代码放到这里// Put the code you want to measure the time of here.}];}</code></pre><h2 id="断言命令"><a href="#断言命令" class="headerlink" title="断言命令"></a>断言命令</h2><p>XCTFail(format…) 生成一个失败的测试；</p><p>XCTAssertNil(a1, format…)为空判断，a1为空时通过，反之不通过；</p><p>XCTAssertNotNil(a1, format…)不为空判断，a1不为空时通过，反之不通过；</p><p>XCTAssert(expression, format…)当expression求值为TRUE时通过；</p><p>XCTAssertTrue(expression, format…)当expression求值为TRUE时通过；</p><p>XCTAssertFalse(expression, format…)当expression求值为False时通过；</p><p>XCTAssertEqualObjects(a1, a2, format…)判断相等，[a1 isEqual:a2]值为TRUE时通过，其中一个不为空时，不通过；</p><p>XCTAssertNotEqualObjects(a1, a2, format…)判断不等，[a1 isEqual:a2]值为False时通过，</p><p>XCTAssertEqual(a1, a2, format…)判断相等（当a1和a2是 C语言标量、结构体或联合体时使用,实际测试发现NSString也可以）；</p><p>XCTAssertNotEqual(a1, a2, format…)判断不等（当a1和a2是 C语言标量、结构体或联合体时使用）；</p><p>XCTAssertEqualWithAccuracy(a1, a2, accuracy, format…)判断相等，（double或float类型）提供一个误差范围，当在误差范围（+/-accuracy）以内相等时通过测试；</p><p>XCTAssertNotEqualWithAccuracy(a1, a2, accuracy, format…) 判断不等，（double或float类型）提供一个误差范围，当在误差范围以内不等时通过测试；</p><p>XCTAssertThrows(expression, format…)异常测试，当expression发生异常时通过；反之不通过；（很变态）</p><p>XCTAssertThrowsSpecific(expression, specificException, format…) 异常测试，当expression发生specificException异常时通过；反之发生其他异常或不发生异常均不通过；</p><p>XCTAssertThrowsSpecificNamed(expression, specificException, exception_name, format…)异常测试，当expression发生具体异常、具体异常名称的异常时通过测试，反之不通过；</p><p>XCTAssertNoThrow(expression, format…)异常测试，当expression没有发生异常时通过测试；</p><h2 id="单元测试的适用情况以及覆盖率"><a href="#单元测试的适用情况以及覆盖率" class="headerlink" title="单元测试的适用情况以及覆盖率"></a>单元测试的适用情况以及覆盖率</h2><p>对于测试用例覆盖度多少合适这个话题,也是仁者见仁智者见智,其实一个软件覆盖度在50%以上就可以成为一个健壮的软件了,要达到70%,80%这些已经非常难了,不过我们常见的一些第三方开源框架的测试用例覆盖率还是非常高的,例如AFNNetWorking的覆盖率高达87%,SDWebImage的覆盖率高达77%</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;单元测试&quot;&gt;&lt;a href=&quot;#单元测试&quot; class=&quot;headerlink&quot; title=&quot;单元测试&quot;&gt;&lt;/a&gt;单元测试&lt;/h2&gt;&lt;p&gt;我是从去年开始写单元测试的,平常也只是使用测试一下接口的测试,最近有时间网上查找下了资料总结一下,也是有个归纳吧&lt;/p&gt;
&lt;h2 id=&quot;单元测试简介&quot;&gt;&lt;a href=&quot;#单元测试简介&quot; class=&quot;headerlink&quot; title=&quot;单元测试简介&quot;&gt;&lt;/a&gt;单元测试简介&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;单元测试是指开发者编写代码,检测代码。合理的利用单元测试可以提高软件的质量&lt;/p&gt;
&lt;p&gt;代码检测通常需要预先设置边界条件,因为UI测试的时候,很多边界条件不容易满足。主要针对&lt;font color=#0099ff size=3 face=&quot;黑体&quot;&gt;业务逻辑&lt;/font&gt;进行测试,不适合做UI的测试。&lt;/p&gt;
&lt;p&gt;MVVM的设计模式,把几乎所有重要的业务逻辑全部封装在视图模型中,通过单元测试就很方便检测条件以及代码质量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;什么方法或者函数需要测试&quot;&gt;&lt;a href=&quot;#什么方法或者函数需要测试&quot; class=&quot;headerlink&quot; title=&quot;什么方法或者函数需要测试&quot;&gt;&lt;/a&gt;什么方法或者函数需要测试&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;1.私有方法不需要测试,面向对象有一个原则:开闭原则! 暴露在.h中的方法需要测试,
2. 所有跟UI有关的都不需要测试,有UI的交互。MVVM 把小的业务逻辑封装出来,变成可以测试的代码,让程序更加健壮。
3.一般而言,代码的覆盖度大概在50% ~ 70%
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;苹果自带的XCTest&quot;&gt;&lt;a href=&quot;#苹果自带的XCTest&quot; class=&quot;headerlink&quot; title=&quot;苹果自带的XCTest&quot;&gt;&lt;/a&gt;苹果自带的XCTest&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;/** 单元测试开始前调用 */
- (void)setUp {
[supersetUp];
// Put setup code here. This method is called before the invocation of each test method in the class.
}
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>04-Code Review</title>
    <link href="http://waythought.duoshuo.com/2017/06/21/04-%E4%BB%A3%E7%A0%81%E5%AE%A1%E6%9F%A5%E6%B8%85%E5%8D%95/"/>
    <id>http://waythought.duoshuo.com/2017/06/21/04-代码审查清单/</id>
    <published>2017-06-21T07:03:43.000Z</published>
    <updated>2017-10-31T12:45:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Code-Review"><a href="#Code-Review" class="headerlink" title="Code Review"></a>Code Review</h2><h3 id="代码审查清单"><a href="#代码审查清单" class="headerlink" title="代码审查清单"></a>代码审查清单</h3><h4 id="常规项"><a href="#常规项" class="headerlink" title="常规项"></a>常规项</h4><pre><code>1.代码能够工作吗？它有没有实现预期的功能，逻辑是否正确等。2.代码符合你遵循的编程规范吗？通常包括大括号的位置，变量名和函数名，行的长度，缩进，格式和注释。3.是否存在多余的或是重复的代码？4.代码是否尽可能的模块化了？5.是否有可以被替换的全局变量？6.是否有被注释掉的代码？7.健壮性：是否考虑线程安全；边界处理是否完整；数据的越界处理；有没有内存泄漏；逻辑是否健壮；循环引用（block中的self和weakSelf）</code></pre><a id="more"></a><h4 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h4><pre><code>1.所有的数据输入是否都进行了检查（检测正确的类型，长度，格式和范围）并且进行了编码？2.在哪里使用了第三方工具，返回的错误是否被捕获？3.输入的值是够进行了检查和编码？4.无效的参数值是否能够处理？</code></pre><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><pre><code>把使用清单作为你的起点，针对特定的使用案例，你需要对其进行优化。一个比较棒的方式就是让你的团队记录下那些在代码审查过程中临时发现的问题，有了这些数据，你就能够确定你的团队常犯的错误，然后你就可以量身定制一个审查清单。确保你删除了那些没有出现过的错误。</code></pre><h4 id="获取认可并且保持更新"><a href="#获取认可并且保持更新" class="headerlink" title="获取认可并且保持更新"></a>获取认可并且保持更新</h4><pre><code>基本规则是，清单上的人和条目都必须明确，而且，如果可能的话，对于一些条目你可以对其进行二元判断。这样可以防止判断的不一致。和你的团队分享这份清单并且让他们认同你的清单的内容是个好主意。同样的，要定期检查你的清单，以确保各条目仍然是有意义的。</code></pre><p>最后： 代码审查的流程<br><a href="http://www.cnblogs.com/IT-Bear/archive/2012/07/04/2576367.html" target="_blank" rel="external">http://www.cnblogs.com/IT-Bear/archive/2012/07/04/2576367.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Code-Review&quot;&gt;&lt;a href=&quot;#Code-Review&quot; class=&quot;headerlink&quot; title=&quot;Code Review&quot;&gt;&lt;/a&gt;Code Review&lt;/h2&gt;&lt;h3 id=&quot;代码审查清单&quot;&gt;&lt;a href=&quot;#代码审查清单&quot; class=&quot;headerlink&quot; title=&quot;代码审查清单&quot;&gt;&lt;/a&gt;代码审查清单&lt;/h3&gt;&lt;h4 id=&quot;常规项&quot;&gt;&lt;a href=&quot;#常规项&quot; class=&quot;headerlink&quot; title=&quot;常规项&quot;&gt;&lt;/a&gt;常规项&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;1.代码能够工作吗？它有没有实现预期的功能，逻辑是否正确等。
2.代码符合你遵循的编程规范吗？通常包括大括号的位置，变量名和函数名，行的长度，缩进，格式和注释。
3.是否存在多余的或是重复的代码？
4.代码是否尽可能的模块化了？
5.是否有可以被替换的全局变量？
6.是否有被注释掉的代码？
7.健壮性：是否考虑线程安全；边界处理是否完整；数据的越界处理；有没有内存泄漏；逻辑是否健壮；循环引用（block中的self和weakSelf）
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>02-Mac上安装oh-my-zsh以及iterm2的使用</title>
    <link href="http://waythought.duoshuo.com/2017/06/21/02-mac%E4%B8%8A%E5%AE%89%E8%A3%85oh-my-zsh%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
    <id>http://waythought.duoshuo.com/2017/06/21/02-mac上安装oh-my-zsh以及应用/</id>
    <published>2017-06-21T07:02:42.000Z</published>
    <updated>2017-10-31T12:45:18.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Mac上安装oh-my-zsh"><a href="#Mac上安装oh-my-zsh" class="headerlink" title="Mac上安装oh-my-zsh"></a>Mac上安装oh-my-zsh</h3><ul><li><p>1 克隆项目本地(Mac默认已经安装git) </p><pre><code>git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh</code></pre></li><li><p>2 创建一个zsh的配置文件 </p><pre><code>cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc</code></pre><p>  备注:~ 代表:你的/home/用户名的目录,假设你的用户名是user,那么~/就是/home/user/. .是代表此目录本身,但是一般可以不写,所以cd ~/. 和 cd ~ 和cd ~/效果是一样的.但是.后面有东西又是另外一个问题,点在文件名头部,代表一个隐藏文件. ~/.local是你的主目录下下一个.local的文件夹的路径,并且从.可以看出,这是一个隐藏文件,使用ls -a显示.</p></li><li><p>3 设置zsh为默认的shell</p><pre><code>chsh -s /bin/zsh</code></pre></li><li><p>4 重启终端生效</p><a id="more"></a></li><li><p>5 设置ZSH主题:<br>   5.1 到你的用户名目录</p><pre><code>$ cd ~/</code></pre><p>   5.2 显示文件(包括隐藏文件),并打开.zshrc</p><pre><code>$ ls -a $ open .zshrc</code></pre><p>   5.3 找到 ZSH_THEME=“robbyrussell”,并注释掉(行头加 #),另起一行,换上你喜欢的主题,我使用的ys.zsh-theme(补充:直接在原来的行上替换,有时候会出现替换是失败的情况,所以注释掉原来的,重新写是最好的选择)</p><pre><code>ZSH_THEME=&quot;ys&quot;</code></pre></li><li><p>6 补充:卸载oh my zsh：<br>在命令行输入如下命令，回车即可</p><pre><code>uninstall_oh_my_zsh</code></pre></li></ul><h3 id="iterm2的使用"><a href="#iterm2的使用" class="headerlink" title="iterm2的使用"></a>iterm2的使用</h3><pre><code>下载地址:  http://www.iterm2.com/</code></pre><p>使用:</p><pre><code>1.cmd+f 弹出iterm2的查找模式,确认找到的是自己的内容之后,使用tab键,查找窗口将自动变化内容,并将其复制.如果是shift+tab,则自动将查找内容的左边选中并复制.2.自动使用前-Tab路径,设置perferces-&gt;Profiles-&gt;选中Login shell 和Reuse previous tab&apos;s directory3.command+d: 垂直分割  command+shift+d: 水平分割4.系统热键:设置好系统热键之后,将在正常的浏览器或者编辑器等窗口的上面,以半透明窗口的上面,以半透明窗口形式直接调出iterm2 shell-&gt;perferces-&gt;Key-&gt;Hotkey5.自动完成:输入打头几个字母,然后输入cmd + ; iterm2将自动列出之前输入过的类似命令6.剪切历史:输入cmd + shift + h iterm2将自动列出剪切板的历史记录.如果需要将剪切板的历史记录保存到磁盘,在Perferences-&gt;General-&gt;Save copy/paste history to disk. 7.全屏切换: cmd + enter 进入和返回全屏模式</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Mac上安装oh-my-zsh&quot;&gt;&lt;a href=&quot;#Mac上安装oh-my-zsh&quot; class=&quot;headerlink&quot; title=&quot;Mac上安装oh-my-zsh&quot;&gt;&lt;/a&gt;Mac上安装oh-my-zsh&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;1 克隆项目本地(Mac默认已经安装git) &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;2 创建一个zsh的配置文件 &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  备注:~ 代表:你的/home/用户名的目录,假设你的用户名是user,那么~/就是/home/user/. .是代表此目录本身,但是一般可以不写,所以cd ~/. 和 cd ~ 和cd ~/效果是一样的.但是.后面有东西又是另外一个问题,点在文件名头部,代表一个隐藏文件. ~/.local是你的主目录下下一个.local的文件夹的路径,并且从.可以看出,这是一个隐藏文件,使用ls -a显示.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;3 设置zsh为默认的shell&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;chsh -s /bin/zsh
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;4 重启终端生效&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>01-状态栏</title>
    <link href="http://waythought.duoshuo.com/2017/05/22/01-%E7%8A%B6%E6%80%81%E6%A0%8F/"/>
    <id>http://waythought.duoshuo.com/2017/05/22/01-状态栏/</id>
    <published>2017-05-22T05:38:39.000Z</published>
    <updated>2018-01-03T09:29:35.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="状态栏"><a href="#状态栏" class="headerlink" title="状态栏"></a>状态栏</h2><pre><code>typedef NS_ENUM(NSInteger, UIStatusBarStyle) {UIStatusBarStyleDefault                                     = 0, // 白底黑子UIStatusBarStyleLightContent     NS_ENUM_AVAILABLE_IOS(7_0) = 1, 黑底白字UIStatusBarStyleBlackTranslucent NS_ENUM_DEPRECATED_IOS(2_0, 7_0, &quot;Use UIStatusBarStyleLightContent&quot;) = 1,UIStatusBarStyleBlackOpaque      NS_ENUM_DEPRECATED_IOS(2_0, 7_0, &quot;Use UIStatusBarStyleLightContent&quot;) = 2,</code></pre><p>} __TVOS_PROHIBITED;</p><p>//默认的值是黑色的<br>-(UIStatusBarStyle)preferredStatusBarStyle<br>{<br>    return UIStatusBarStyleDefault;</p><p>}<br>如果项目中root是UINavigationController,那我们自己的UIViewController的preferredStatusBarStyle的方法根本不会调用</p><p>// 是否隐藏状态栏</p><ul><li>(BOOL)prefersStatusBarHidden<br>{<br>  return NO;<br>}</li></ul><p><a href="http://www.cnblogs.com/ilovelqq/p/4769655.html" target="_blank" rel="external">http://www.cnblogs.com/ilovelqq/p/4769655.html</a>  参考</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;状态栏&quot;&gt;&lt;a href=&quot;#状态栏&quot; class=&quot;headerlink&quot; title=&quot;状态栏&quot;&gt;&lt;/a&gt;状态栏&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;typedef NS_ENUM(NSInteger, UIStatusBarStyle) {
UIStatusBar
      
    
    </summary>
    
    
  </entry>
  
</feed>
