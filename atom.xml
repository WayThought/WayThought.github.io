<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>钱多多的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://waythought.duoshuo.com/"/>
  <updated>2020-02-26T06:47:12.544Z</updated>
  <id>http://waythought.duoshuo.com/</id>
  
  <author>
    <name>Qian.G.j</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>23.探讨KVO底层原理、存在的缺陷以及解决方法</title>
    <link href="http://waythought.duoshuo.com/2020/01/02/23.KVO%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://waythought.duoshuo.com/2020/01/02/23.KVO底层实现原理/</id>
    <published>2020-01-02T04:12:24.000Z</published>
    <updated>2020-02-26T06:47:12.544Z</updated>
    
    <content type="html"><![CDATA[<h3 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h3><p><strong>KVO的全称是Key-Value Observing，俗称“键值监听”，可以用于监听某个对象属性值的改变</strong></p><p><img src="http://ww1.sinaimg.cn/large/8af26a6dly1g5r4ueu2m0j212g084wew.jpg" alt=""></p><a id="more"></a><h3 id="KVO底层实现原理分析与验证"><a href="#KVO底层实现原理分析与验证" class="headerlink" title="KVO底层实现原理分析与验证"></a>KVO底层实现原理分析与验证</h3><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p><img src="http://ww1.sinaimg.cn/large/8af26a6dly1g5r4vim911j21j613e7e0.jpg" alt=""></p><p>打印结果<br><img src="http://ww1.sinaimg.cn/large/8af26a6dly1g5r5jz1s2zj21x409sgn7.jpg" alt=""></p><p>那么给person1和person2赋值的时候,为什么只是添加了监听者对象的属性变化会调用呢? </p><p>我们看到person1与person2的区别就是person2添加了监听者。所以猜测是person2实例对象发生了变化。</p><p><img src="http://ww1.sinaimg.cn/large/8af26a6dly1g5r5l6q7d8j21x4130tjg.jpg" alt=""></p><p>打印结果显示person1与person2实例对象的isa指向的类对象是不同的,也就是添加了KVO监听的实例对象的isa指向的类对象是NSKVONotifying_BYPerson,未添加监听者的实例对象的isa指向的还是原来的类对象。</p><p>我们都知道实例对象调用方法是给这个对象发送消息,根据实例对象的isa,找到类对象,优先在这个类对象中去寻找对象方法,找不到的话会根据superClass指针找父类的类对象,再去父类的类对象中查询对象方法。</p><p><strong>person1的isa</strong><br><img src="http://ww1.sinaimg.cn/large/8af26a6dly1g5r69kvuqoj20xe0fw0tx.jpg" alt=""></p><p><strong>person2的isa</strong></p><p><img src="http://ww1.sinaimg.cn/large/8af26a6dly1g5r69votxbj21a00ogdix.jpg" alt=""></p><p><strong>备注:  NSKVONotifying_BYPerson这个派生的子类,是runtime动态生成的, NSKVONotifying_BYPerson这个类对象的isa指针指向这个派生类的元类对象</strong></p><p>我们来验证下NSKVONotifying_BYPerson类中有哪些对象方法</p><pre><code>// 打印类中的方法- (void)printMethodNamesOfClass:(Class)cls{    unsigned int count;    // 获得方法数组    Method *methodList = class_copyMethodList(cls, &amp;count);    // 存储方法名    NSMutableString *methodNames = [NSMutableString string];    // 遍历所有的方法    for (int i = 0; i &lt; count; i++) {        // 获得方法        Method method = methodList[i];        // 获得方法名        NSString *methodName = NSStringFromSelector(method_getName(method));        // 拼接方法名        [methodNames appendString:methodName];        [methodNames appendString:@&quot;, &quot;];    }    // 释放    free(methodList);    // 打印方法名    NSLog(@&quot;%@ %@&quot;, cls, methodNames);}</code></pre><hr><p><img src="http://ww1.sinaimg.cn/large/8af26a6dly1g5r6whglpej21w80oaqay.jpg" alt=""></p><p>NSKVONotifying_BYPerson类中有setAge:, class, dealloc, _isKVOA方法</p><h4 id="派生的子类中的-setAge-方法"><a href="#派生的子类中的-setAge-方法" class="headerlink" title="派生的子类中的 setAge: 方法"></a>派生的子类中的 setAge: 方法</h4><p><strong>根据结果来看person2会优先调用NSKVONotifying_BYPerson这个类对象中的setAge:方法</strong></p><p>我们来看下NSKVONotifying_BYPerson对象方法的setAge:方法的实现:</p><p><strong>methodForSelector:</strong>方法是返回实例对象对应的对象方法的实现<br><img src="http://ww1.sinaimg.cn/large/8af26a6dly1g5r70l2asuj21x6176tnl.jpg" alt=""></p><p>我们看到person1的”setAge:”方法实现没有发生变化,person2在添加监听者之前和之后是不同的</p><pre><code>p (IMP) 地址</code></pre><p>会打印出该方法的实现</p><p>person1是正常调用的BYPerson类的setAge:方法,而person2的”setAge:”方法的实现是函数<strong>_NSSetIntValueAndNotify</strong>这个函数</p><h4 id="NSSetIntValueAndNotify内部实现"><a href="#NSSetIntValueAndNotify内部实现" class="headerlink" title="_NSSetIntValueAndNotify内部实现"></a>_NSSetIntValueAndNotify内部实现</h4><p><img src="http://ww1.sinaimg.cn/large/8af26a6dly1g73y0sr4duj20dg04f0tr.jpg" alt=""></p><ol><li>调用willChangeValueForKey,记录旧的值</li><li>调用原来的setter方法</li><li>调用didChangeValueForKey (该方法内部会调用observer的observeValueForKeyPath:ofObject:change:context方法)</li></ol><h4 id="派生的子类中的-class-方法"><a href="#派生的子类中的-class-方法" class="headerlink" title="派生的子类中的 class 方法"></a>派生的子类中的 class 方法</h4><pre><code>- (Class)class {return [BYPerson class];}</code></pre><p>派生的子类中重写了class方法,返回的是父类的class方法。苹果为什么要这么做呢?</p><p>我认为是苹果不想公开NSKVONotifying_BYPerson这个类,屏蔽内部实现,隐藏派生子类的实现,让开发者更注重业务的开发。<br>即使开发者调用class方法,告诉开发者的也是BYPerson,是父类,也是正确的。</p><h3 id="KVOController源码讨论"><a href="#KVOController源码讨论" class="headerlink" title="KVOController源码讨论"></a>KVOController源码讨论</h3><h4 id="KVO现状"><a href="#KVO现状" class="headerlink" title="KVO现状"></a>KVO现状</h4><ul><li>addObserver和removeObserver必须配对出现,仅支持以下用法</li></ul><pre><code>[observe addObserver...];// do something[observe removeObserver...];</code></pre><ul><li>很多时候明明代码已经做到了配对出现且按次序调用,由于<strong>多线程导致软件运行时环境复杂化</strong> 或者 <strong>观察者意外地过早释放掉</strong>还是发现有相关的crash。</li><li>对同一个实例对象的属性添加多次监听,在属性发生变化的时候,observeValueForKeyPath:ofObject:change:context的方法会调用多次</li></ul><h4 id="KVOController的优势"><a href="#KVOController的优势" class="headerlink" title="KVOController的优势"></a>KVOController的优势</h4><ul><li>提供更易用的的接口</li></ul><p>提供对block回调和自定义selector的支持,保持了灵活性和强大</p><ul><li>提供更加安全的接口</li></ul><p>通过解决addObserver 和 removeObserver必须配对且按次序调用的问题,提供了一套更加安全的接口。</p><p>使用单例主动监听,保证在程序声明周期不会释放掉。</p><ul><li>消息过滤<br>通过_FBKVOInfo *existingInfo = [infos member:info], 首先判断是否已经包含对应观察者消息,如果包含则直接返回,不会再重复注册。</li></ul><h4 id="KVOController-流程"><a href="#KVOController-流程" class="headerlink" title="KVOController 流程"></a>KVOController 流程</h4><p><strong>关键类</strong></p><pre><code>_FBKVOInfo:{    @public      // 对FBKVOController的弱引用      __weak FBKVOController *_controller;      // 被监听者的keyPath      NSString *_keyPath;      NSKeyValueObservingOptions _options;      SEL _action;      void *_context;      // 被监听到的实例变量发生变化之后的回调      FBKVONotificationBlock _block;      // 本对象的状态      _FBKVOInfoState _state;}</code></pre><hr><pre><code>FBKVOController:    // 用来记录监听的table    NSMapTable&lt;id, NSMutableSet&lt;_FBKVOInfo *&gt; *&gt; *_objectInfosMap;    // 弱引用一个被监听的对象    @property (nullable, nonatomic, weak, readonly) id observer;</code></pre><hr><pre><code>_FBKVOSharedController:// 记录监听的集合NSHashTable&lt;_FBKVOInfo *&gt; *_infos;</code></pre><p>第一步、(基本使用)</p><pre><code>// Arrange 1: Create a controller to observe changes to a circle.id&lt;FBKVOTestObserving&gt; observer = mockProtocol(@protocol(FBKVOTestObserving));FBKVOController *controller = [FBKVOController controllerWithObserver:observer];// Arrange 2: Observe the key paths &quot;radius&quot; and &quot;borderWidth&quot; on the circle.//            Aggregate the new values in an array.NSMutableArray *newValues = [NSMutableArray array];FBKVOTestCircle *circle = [FBKVOTestCircle circle];// 将被监听者、keyPath、传到FBKVOController内部[controller observe:circle keyPaths:@[radius, borderWidth] options:NSKeyValueObservingOptionNew block:^(id observer, FBKVOTestCircle *circle, NSDictionary *change) {  [newValues addObject:change[NSKeyValueChangeNewKey]];}];</code></pre><p>第二步、(在FBKVOController的操作)</p><ol><li><p>根据FBKVOController、keyPath等创建_FBKVOInfo对象,并把被监听者作为key,创建对应NSMutableSet作为value,将_FBKVOInfo对象添加到这个NSMutableSet中。将key与value的对应关系存储到FBKVOController的的objectInfosMap(NSMapTable类型)成员变量中</p></li><li><p>等下次添加的时候,根据被监听者(key)判断是否创建了这个NSMutableSet(value),未创建则重新创建;如果判断已经创建了,取出对应的NSMutableSet, 再判断这个NSMutableSet是否包含了该keypath创建_FBKVOInfo对象,如果包含则直接return,未创建则重新创建。过滤掉重复监听同一个被监听者的同一个属性。</p></li><li>将被监听者和生成的_FBKVOInfo对象传给_FBKVOSharedController这个单例</li></ol><p>第三步、(在_FBKVOSharedController中的操作)</p><ol><li>让_FBKVOSharedController这个单例对被监听者进行监听,因为监听者是单例,所以监听者在程序的运行声明周期不会释放掉。</li><li><p>在监听回调方法<strong>observeValueForKeyPath</strong>中做了以下判断</p><p> 2.1. 取出对应的info,判断info持有的_controller是否释放掉了,如果释放掉了直接return <br></p><p> 2.2. 判断_controller持有的被监听者是否释放掉了,如果释放掉了直接return</p></li><li>走完上述两步,进行block的回调。保证在回调过程中被监听者、监听者和KVOController都是存在的</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;KVO&quot;&gt;&lt;a href=&quot;#KVO&quot; class=&quot;headerlink&quot; title=&quot;KVO&quot;&gt;&lt;/a&gt;KVO&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;KVO的全称是Key-Value Observing，俗称“键值监听”，可以用于监听某个对象属性值的改变&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/8af26a6dly1g5r4ueu2m0j212g084wew.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>22.app瘦身</title>
    <link href="http://waythought.duoshuo.com/2019/08/02/22.app%E7%98%A6%E8%BA%AB/"/>
    <id>http://waythought.duoshuo.com/2019/08/02/22.app瘦身/</id>
    <published>2019-08-02T03:12:23.000Z</published>
    <updated>2020-02-26T06:47:08.774Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装包（IPA）主要由可执行文件、资源组成"><a href="#安装包（IPA）主要由可执行文件、资源组成" class="headerlink" title="安装包（IPA）主要由可执行文件、资源组成"></a>安装包（IPA）主要由可执行文件、资源组成</h2><h3 id="一、资源优化（图片、音频、视频等）"><a href="#一、资源优化（图片、音频、视频等）" class="headerlink" title="一、资源优化（图片、音频、视频等）"></a>一、资源优化（图片、音频、视频等）</h3><ol><li>图片采取无损压缩(压缩大小但是不压缩质量)</li><li>去除没有用到的资源工具： <a href="https://github.com/tinymind/LSUnusedResources" target="_blank" rel="external">工具</a></li><li>png与jpg图片替换成使用NSBundle加载webp格式图片,已验证瘦身效果明显</li></ol><h4 id="删除无用图片的过程-可以概括为下面这个6大步。"><a href="#删除无用图片的过程-可以概括为下面这个6大步。" class="headerlink" title="删除无用图片的过程,可以概括为下面这个6大步。"></a>删除无用图片的过程,可以概括为下面这个6大步。</h4><ul><li>通过find命令获取App安装包中的所有资源文件</li><li>设置用到的资源的类型,比如jpg、gif、png、webp</li><li>使用正则匹配在源码中找出使用到的资源名,比如pattern = @”@(.+?)”</li><li>使用find命令找到的所有的资源文件,再去掉代码使用到的资源文件,剩下的就是无用资源了。</li><li>对于按照规则设置的资源名,我们需要再匹配使用资源的正则表达式里添加相应的规则,比如@”image_%d”。</li><li>确认无用资源后,就可以对这些无用资源执行删除操作了。这个删除操作,你可以使用nsfilemanager</li></ul><h3 id="二、可执行文件的瘦身"><a href="#二、可执行文件的瘦身" class="headerlink" title="二、可执行文件的瘦身"></a>二、可执行文件的瘦身</h3><p>1.编译选项优化 </p><ul><li>Strip Linked Product、Make Strings Read-Only、Symbols Hidden by Default设置为YES (高版本xcode已默认设置为YES)</li><li>去掉异常支持，Enable C++ Exceptions、Enable Objective-C Exceptions设置为NO， Other C Flags添加-fno-exceptions</li></ul><p>2.未使用代码检测</p><p>利用AppCode <a href="https://www.jetbrains.com/objc/" target="_blank" rel="external">下载地址</a><br>检测未使用的代码流程：菜单栏 -&gt; Code -&gt; Inspect Code</p><p>补充:<br>App Thining是由苹果公司推出的一项可以改善App下载进程的新技术,主要是为了解决用户下载App 耗费过高流量的问题。同时还可以节省用户iOS设备的存储空间。</p><p>现在的iOS设备屏幕尺寸、分辨率越来越多样化,这样也就需要更多的资源来匹配不同的尺寸和分辨率。同时,App也会有32位、64位不同芯片架构的优化版本,如果这些都是在一个包里,那么用户下载包的大小势必就会变大。</p><p>App Thinning会专门针对不同的设备来选择只使用当前设备的内容以供下载。比如,iPhone 6只会下载2x分辨率的图片资源,iPhone 6Plus则只会下载3x分辨率的图片资源。<br>App Thining有三种方式,包括: App Slicing、Bitcode、On-Demand Resource。</p><p>App Slicing,会在你向iTunes Connect上传App后,对App做切割,创建不同的变体,这样就可以使用到不同的设备。<br>On-Demand Resources,主要是为了游戏多关卡场景服务的。它会根据用户的关卡进度下载随后几个关卡的资源,并且已经过关的资源也会被删掉,这样就可以减少初装app的包的大小。</p><p>Bitcode,是针对特定设备进行包大小优化,优化不明显。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装包（IPA）主要由可执行文件、资源组成&quot;&gt;&lt;a href=&quot;#安装包（IPA）主要由可执行文件、资源组成&quot; class=&quot;headerlink&quot; title=&quot;安装包（IPA）主要由可执行文件、资源组成&quot;&gt;&lt;/a&gt;安装包（IPA）主要由可执行文件、资源组成&lt;/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>21.深入AutoreleasePool</title>
    <link href="http://waythought.duoshuo.com/2019/01/17/21.AutoreleasePool/"/>
    <id>http://waythought.duoshuo.com/2019/01/17/21.AutoreleasePool/</id>
    <published>2019-01-17T03:12:23.000Z</published>
    <updated>2020-02-15T16:19:37.817Z</updated>
    
    <content type="html"><![CDATA[<h3 id="autoreleasepool"><a href="#autoreleasepool" class="headerlink" title="@autoreleasepool"></a>@autoreleasepool</h3><p>@autoreleasepool{} 是一个__AtAutorereleasePool的结构体</p><pre><code>struct __AtAutoreleasePool {  __AtAutoreleasePool() {// 构造函数,在创建结构体的时候调用          atautoreleasepoolobj = objc_autoreleasePoolPush();      }  ~__AtAutoreleasePool() {// 析构函数, 在结构体销毁的时候调用      objc_autoreleasePoolPop(atautoreleasepoolobj);  }  void * atautoreleasepoolobj;};</code></pre><p>这个结构体会在初始化时调用<strong>objc_autoreleasePoolPush()</strong>方法,会在析构(对象结束其生命周期)时调用<strong>objc_autoreleasePoolPop</strong>方法。</p><a id="more"></a><p>我们main函数在实际工作时其实是这样的:</p><pre><code>int main(int argc, const char * argv[]) {    {        void * atautoreleasepoolobj = objc_autoreleasePoolPush();        // do whatever you want        objc_autoreleasePoolPop(atautoreleasepoolobj);    }    return 0;}</code></pre><h3 id="AutoreleasePool-是什么"><a href="#AutoreleasePool-是什么" class="headerlink" title="AutoreleasePool 是什么"></a>AutoreleasePool 是什么</h3><p>这一节开始分析方法<strong>objc_autoreleasePoolPush</strong>和 <strong>objc_autoreleasePoolPop</strong>实现:</p><pre><code>void *objc_autoreleasePoolPush(void) {    return AutoreleasePoolPage::push();}void objc_autoreleasePoolPop(void *ctxt) {    AutoreleasePoolPage::pop(ctxt);}</code></pre><p>上面的方法是对AutoreleasePoolPage对应的静态方法push和pop的封装。</p><h4 id="AutoreleasePoolPage-的结构"><a href="#AutoreleasePoolPage-的结构" class="headerlink" title="AutoreleasePoolPage 的结构"></a>AutoreleasePoolPage 的结构</h4><p><strong>AutoreleasePoolPage</strong>是一个c++中的类, 它在NSObject.mm中的定义是这样的:</p><pre><code>class AutoreleasePoolPage {    magic_t const magic;    id *next;    pthread_t const thread;    AutoreleasePoolPage * const parent;    AutoreleasePoolPage *child;    uint32_t const depth;    uint32_t hiwat;};</code></pre><ul><li>magic用于对当前AutoreleasePoolPage完整性的校验</li><li>thread保存了当前页所在的线程</li><li>*next指向最新添加的autorelease对象的下一个位置,初始化时指向begin()</li><li>parent指向了父节点,第一个初始化的 AutoreleasePoolPage 的parent值为nil</li><li>child指向子节点,最后一个节点的child值为nil</li></ul><p>每一个自动释放池都是由一系列的 AutoreleasePoolPage 组成的,并且每一个 AutoreleasePoolPage 的大小都是4096字节(16进制 0x1000)内存,除了用来存放它内部的成员变量, 剩下的空间用来存在autorelease对象(放到该pool中的对象)的地址。</p><h5 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表:"></a>双向链表:</h5><p>自动释放池中的 AutoreleasePoolPage 是以<strong>双向链表</strong>的形式连接起来的:</p><p><img src="http://ww1.sinaimg.cn/large/8af26a6dly1gbrbdmx35kj20rs05idgz.jpg" alt=""></p><p><strong>parent 和 child 就是用来构造双向链表的指针。</strong></p><h5 id="自动释放池中的栈"><a href="#自动释放池中的栈" class="headerlink" title="自动释放池中的栈"></a>自动释放池中的栈</h5><p>如果我们的一个 AutoreleasePoolPage被初始化在内存中的结构如下:</p><p><img src="http://ww1.sinaimg.cn/large/8af26a6dly1gbrbdmx35kj20rs05idgz.jpg" alt=""></p><p>其中前 56bit用于存储 AutoreleasePoolPage的成员变量,剩下的 4040bit 都是用来存储加入到自动释放池中的对象。</p><p>在每个自动释放池初始化调用 <strong>objc_autoreleasePoolPush</strong> 的时候,都会把一个 <strong>POOL_BOUNDARY</strong>,它存储着存储着begin()的初始值,push到自动释放池的栈顶,并且返回这个 <strong>POOL_BOUNDARY</strong>。</p><pre><code>int main(int argc, const char * argv[]) {    {        void * atautoreleasepoolobj = objc_autoreleasePoolPush();        // do whatever you want        objc_autoreleasePoolPop(atautoreleasepoolobj);    }    return 0;}</code></pre><p>上面的 <strong>atautoreleasepoolobj</strong> 就是一个 <strong>POOL_BOUNDARY</strong>。</p><p>每当一个对象调用autorelease的时候, 就会将这个对象地址值依次放到这个<strong>POOL_BOUNDARY</strong>的后面。</p><p>每当一个autoreleasepool创建的时候,就会再次压栈一个<strong>POOL_BOUNDARY</strong>。</p><p>而当方法 <strong>objc_autoreleasePoolPop</strong> 调用时,入参为<strong>atautoreleasepoolobj</strong>,就会向自动释放池中的对象依次发送 <strong>release</strong> 消息,从最后一个对象开始直到该pool对应的第一个 <strong>POOL_BOUNDARY</strong>:</p><h5 id="objc-autoreleasePoolPush方法"><a href="#objc-autoreleasePoolPush方法" class="headerlink" title="objc_autoreleasePoolPush方法"></a>objc_autoreleasePoolPush方法</h5><pre><code>void *objc_autoreleasePoolPush(void) {    return AutoreleasePoolPage::push();}</code></pre><p>它调用 <strong>AutoreleasePoolPage</strong> 的类方法 <strong>push</strong>: </p><pre><code>static inline void *push() {       return autoreleaseFast(POOL_BOUNDARY);}</code></pre><p>在这里会进入一个比较关键的方法 <strong>autoreleaseFast</strong>,并传入 <strong>POOL_BOUNDARY</strong>:</p><pre><code>static inline id *autoreleaseFast(id obj){   AutoreleasePoolPage *page = hotPage();   if (page &amp;&amp; !page-&gt;full()) {       return page-&gt;add(obj);   } else if (page) {       return autoreleaseFullPage(obj, page);   } else {       return autoreleaseNoPage(obj);   }}</code></pre><p>上述方法分三种情况选择不同的代码执行:</p><ul><li><strong>有hotPage并且当前的page不满</strong> :调用 page-&gt;add(obj) 方法将对象添加至 AutoreleasePoolPage 的栈中</li><li><strong>有 hotpage 并且当前的page已满</strong> :调用 autoreleaseFullPage 初始化一个新的页; 调用 page-&gt;add(obj) 方法将对象添加至 AutoreleasePoolPage 的栈中</li><li><strong>无 hotPage</strong> : 调用 autoreleaseNoPage 创建一个 hotPage; 调用 page-&gt;add(obj)方法将对象添加至 AutoreleasePoolPage 的栈中</li></ul><p>最后都会调用 <strong>page-&gt;add(obj)</strong> 将对象添加到自动释放池中。<strong>hotPage</strong> 可以理解为当前正在使用的 <strong>AutoreleasePoolPage</strong></p><h5 id="page-gt-add-添加对象"><a href="#page-gt-add-添加对象" class="headerlink" title="page-&gt;add 添加对象"></a>page-&gt;add 添加对象</h5><p><strong>id *add(id objc)</strong> 将对象添加到自动释放池中:</p><pre><code>id *add(id obj) {    id *ret = next;    *next = obj;    next++;    return ret;}</code></pre><p>这个方法其实就是一个压栈的操作,将对象加入到 <strong>AutoreleasePoolPage</strong> 然后移动到栈顶的指针。</p><h5 id="autoreleaseFullPage-当前的hotPage已满"><a href="#autoreleaseFullPage-当前的hotPage已满" class="headerlink" title="autoreleaseFullPage(当前的hotPage已满)"></a>autoreleaseFullPage(当前的hotPage已满)</h5><p>autoreleaseFullPage会在当前的hotPage已满的时候调用:</p><pre><code>static id *autoreleaseFullPage(id obj, AutoreleasePoolPage *page) {    do {        if (page-&gt;child) page = page-&gt;child;        else page = new AutoreleasePoolPage(page);    } while (page-&gt;full());    setHotPage(page);    return page-&gt;add(obj);}</code></pre><p>它会从传入的 page 开始遍历整个双向链表,直到:</p><ol><li>查找到一个未满的 autoreleaseFullPage</li><li>使用构造器传入parent创建一个新的 AutoreleasePoolPage</li></ol><p>在查找到一个可以使用的 AutoreleasePoolPage 之后,会将该页面标记成 hotPage,然后调动上面分析过的 page-&gt;add方法添加对象。</p><h5 id="autoreleaseNoPage-没有hotPage"><a href="#autoreleaseNoPage-没有hotPage" class="headerlink" title="autoreleaseNoPage(没有hotPage)"></a>autoreleaseNoPage(没有hotPage)</h5><p>如果当前内存中不存在 hotPage,就会调用 autoreleaseNoPage 方法初始化一个 AutoreleasePoolPage:</p><pre><code>static id *autoreleaseNoPage(id obj) {    AutoreleasePoolPage *page = new AutoreleasePoolPage(nil);    setHotPage(page);    if (obj != POOL_SENTINEL) {        page-&gt;add(POOL_SENTINEL);    }    return page-&gt;add(obj);}</code></pre><p>既然当前内存中不存在 AutoreleasePoolPage, 就要 <strong>从头开始构建这个自动释放池的双向链表</strong>,也就是说,新的 AutoreleasePoolPage 是没有 parent指针的。</p><p>初始化之后,将当前页标记为 hotPage,然后会先向这个page中添加一个 POOL_BOUNDARY 对象,来确保在 pop 调用的时候,不会出现异常。</p><p>最后,将 obj 添加到自动释放池中。</p><h3 id="objc-autoreleasePoolPop-方法"><a href="#objc-autoreleasePoolPop-方法" class="headerlink" title="objc_autoreleasePoolPop 方法"></a>objc_autoreleasePoolPop 方法</h3><pre><code>void objc_autoreleasePoolPop(void *ctxt) {    AutoreleasePoolPage::pop(ctxt);}</code></pre><p>传入一个<strong>POOL_BOUNDARY</strong>的内存地址，会从最后一个入栈的对象开始发送release消息，直到遇到这个<strong>POOL_BOUNDARY</strong></p><h3 id="autoreleasepool-与-runloop"><a href="#autoreleasepool-与-runloop" class="headerlink" title="autoreleasepool 与 runloop"></a>autoreleasepool 与 runloop</h3><p>autoreleasepool与runloop关系: App启动后,苹果在主线程Runloop里<em>**</em>注册了两个Obsever,其回调都是 _wapRunLoopWithAutoreleasePoolHandler().</p><p>第一个Observer监视的事件是Entry(即将进入Loop),其回调会调用objc_autoreleasePoolPush()创建自动释放池。其order是-2147483647,优先级最高,保证创建释放池发生在其他所有回调之前。</p><p>第二个Observer监听了两个事件: BeforeWaiting(准备进入休眠)时调用_objc_autoreleasePoolPop()和_objc_autoreleasePoolPush()释放这一次loop中使用autorelease的对象,并重新入栈新的POOL_BOUNDARY;<br>Exit(即将退出Loop)时调用_objc_autoreleasePoolPop()来释放最后一次loop中使用autorelease的对象。这个Observer的order是2147483647,优先级最低,保证</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>自动释放池是由 <strong>AutoreleasePoolPage</strong> 以双向链表的方式实现的</li><li>当对象调用 <strong>autorelease</strong> 方法时,会将对象加入 <strong>AutoreleasePoolPage</strong> 的栈中</li><li>调用 <strong>AutoreleasePoolPage::pop</strong> 方法会向栈中的对象发送 <strong>release</strong> 消息。</li></ul><p><strong>参考资料</strong></p><p><a href="https://juejin.im/entry/5a4302535188257d7242b387#autoreleaseFast" target="_blank" rel="external">原理部分</a></p><p><a href="https://juejin.im/post/5b052282f265da0b7156a2aa" target="_blank" rel="external">AutoreleasePool底层实现原理</a></p><p><a href="https://juejin.im/post/59eabe2451882578ca2dc145" target="_blank" rel="external">在ARC环境中autoreleasepool(runloop)的研究</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;autoreleasepool&quot;&gt;&lt;a href=&quot;#autoreleasepool&quot; class=&quot;headerlink&quot; title=&quot;@autoreleasepool&quot;&gt;&lt;/a&gt;@autoreleasepool&lt;/h3&gt;&lt;p&gt;@autoreleasepool{} 是一个__AtAutorereleasePool的结构体&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct __AtAutoreleasePool {
  __AtAutoreleasePool() {// 构造函数,在创建结构体的时候调用
          atautoreleasepoolobj = objc_autoreleasePoolPush();
      }

  ~__AtAutoreleasePool() {// 析构函数, 在结构体销毁的时候调用
      objc_autoreleasePoolPop(atautoreleasepoolobj);
  }

  void * atautoreleasepoolobj;
};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个结构体会在初始化时调用&lt;strong&gt;objc_autoreleasePoolPush()&lt;/strong&gt;方法,会在析构(对象结束其生命周期)时调用&lt;strong&gt;objc_autoreleasePoolPop&lt;/strong&gt;方法。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>20.多线程编程-GCD</title>
    <link href="http://waythought.duoshuo.com/2018/11/17/20.GCD/"/>
    <id>http://waythought.duoshuo.com/2018/11/17/20.GCD/</id>
    <published>2018-11-17T08:02:23.000Z</published>
    <updated>2019-10-15T02:53:28.712Z</updated>
    
    <content type="html"><![CDATA[<p>在实际开项目开发中为了能够给用户更好的体验，有些延时操作我们都会放在子线程中进行。今天我们就来聊聊多线程在实际项目中的运用。</p><h3 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h3><h4 id="进程-process"><a href="#进程-process" class="headerlink" title="进程(process)"></a>进程(process)</h4><ul><li>进程是一个具有一定独立功能的程序关于某次数据集合的一次运行活动,它是操作系统分配资源的基本单元</li><li>一个软件启动就是一个进程,每个进程之间是相互独立的,每个进程均运行在其专用且受保护的内存空间内。</li><li>进程状态: 进程有三个状态,就绪、运行和阻塞。就绪状态其实就是获取了除cpu外的所有资源,只要处理器分配资源马上就可以运行。运行状态就是获取了处理器分配ƒ的资源,程序开始执行。阻塞状态:当程序条件不够时,需要等待条件满足时才能执行;比如等待I/O操作的时候,此刻的状态就叫阻塞</li></ul><a id="more"></a><h4 id="线程-thread"><a href="#线程-thread" class="headerlink" title="线程(thread)"></a>线程(thread)</h4><ul><li>一个进程中的所有任务都是在线程中执行,所以一个进程要想执行任务,必须要有线程,至少有一条线程</li><li>应用程序启动的时候我们的系统会默认帮我们的应用程序开启一条线程,这条线程叫主线程</li></ul><h4 id="进程和线程的关系"><a href="#进程和线程的关系" class="headerlink" title="进程和线程的关系"></a>进程和线程的关系</h4><ul><li>进程是CPU分配资源和调度的单位</li><li>线程是CPU调用的最小单位</li><li>进程有独立的地址空间,一个进程crash后,在保护模式下不会对其他进程产生影响。</li><li>线程是一个进程中的不同执行路径。线程有自己的堆栈和局部变量,但是线程之间没有单独的地址空间。一个线程crash就等于整个进程crash</li></ul><h3 id="多线程编程"><a href="#多线程编程" class="headerlink" title="多线程编程"></a>多线程编程</h3><pre><code>OC源代码int main(){    id o = [[MyObject alloc] init]    [o execBlock]    return 0}</code></pre><p> Mac或iphone中执行OC源代码, 该源代码通过编译器转换为如下CPU命令列(二进制代码)</p><pre><code>000001ac:     b590  push    {r4, r7, 1r}000001ae: f240019c  movw    r1, :lower16:0x260-0x1c0+0xfffffffc000001b2:     af01  add     r7, sp, #4000001b4: f2c00100  movt    r1, :upper16:0x260-0x1c0+0xfffffffc...</code></pre><p> 汇集CPU命令列和数据,将其作为一个应用程序安装到Mac或iPhone上。</p><p> Mac、iPhone的操作系统OS X、iOS根据用户的指示启动该应用程序后,首先便将包含在应用程序中的CPU命令列配置到内存中。CPU从应用程序指定的地址开始,一个一个地执行CPU命令列。先执行1ac的命令列push,接着向后移动,执行地址lae的命令movw,再次向后移动,不断循环下去</p><p> 在控制语句或者函数调用的情况下,执行命令列的地址会远离当前的位置。由于一个CPU命令只能执行一个命令,不能执行某处分开的并列的两个命令,因此通过CPU执行的CPU命令就好像比一条无分叉的大道,执行不会出现分歧。</p><p><img src="http://ww1.sinaimg.cn/large/8af26a6dly1fyz6lpjp30j207v0aqjrp.jpg" alt=""></p><p>现在一个物理的CPU芯片实际上有多个核的CPU,例如iPhone-Xs搭配的A12是六核的,尽管如此,”一个CPU核执行的CPU命令列为一条无分叉路径”仍然不变。</p><p>这种无分叉路径不只1条,存在有多条时即为”多线程”。在多线程中,1个CPU核执行多条不同路径上的不同命令。如下图<br><img src="http://ww1.sinaimg.cn/large/8af26a6dly1fyz89ex30jj21am0j23ze.jpg" alt=""></p><p>队列中的任务,放到不同线程中相当于把命令列放到不同的渠道。单核的话,一个CPU核在一条命令列执行,和在多条命令列中调用执行任务效果其实是一样的,每个时刻只能执行一个命令。 因为CPU能够在某个线程和其他线程之间反复多次进行上下文切换,因此看上去就好像1个CPU核能够并列执行多个线程一样。而在具有多个CPU核的情况下,多个CPU核心在多个线程中调度,就真的提供了多个CPU核并行执行多个线程的技术。</p><p>但是,多线程编程实际上是一种易发生各种问题的编程技术。比如多个线程更新相同的资源会导致数据的不一致(数据竞争)、停止等待时间的线程会导致多个线程相互持续等待(死锁)、使用太多线程会消耗大量内存等。<br><img src="http://ww1.sinaimg.cn/large/8af26a6dly1fyz9g4kxlcj215i0giab9.jpg" alt=""></p><p>尽管极易发生各种问题,也应当使用多线程编程。因为使用多线程编程可保证应用程序的响应性能。</p><p>GCD大大简化了偏于复杂的多线程编程的代码。我们来看下GCD的API。</p><h3 id="GCD的API"><a href="#GCD的API" class="headerlink" title="GCD的API"></a>GCD的API</h3><ul><li>GCD是iOS4.0开始引入的新多线程编程技术,是异步执行任务的技术之一,提供的是系统级线程管理,执行效率更高。</li></ul><h4 id="Dispath-Queue"><a href="#Dispath-Queue" class="headerlink" title="Dispath Queue"></a>Dispath Queue</h4><p><strong>开发者要做的只是定义想执行的任务并追加到适当的 Dispath Queue中。</strong></p><p>通过dispath_async函数等API,在Block语法中记述想执行的处理并将其追加到Dispath Queue中。Dispath Queue按照追加的顺序(FIFO,先进先出)执行处理。</p><p><img src="http://ww1.sinaimg.cn/large/8af26a6dly1fz2qtp4hzej21gw0paabp.jpg" alt=""></p><p>现在有两种Dispath Queue,一种是等待现在执行中处理结束的<strong>Serial Dispatch</strong>,另一种是不等待现在执行中处理结束的<strong>Concurrent Queue</strong>.</p><p><img src="http://ww1.sinaimg.cn/large/8af26a6dly1fz2rmaxssij21g810ctc0.jpg" alt=""></p><p>比较这两种Dispath Queue。准备以下源代码:</p><pre><code>dispatch_queue_t serialQueue = dispatch_queue_create(&quot;test.example.serial&quot;, DISPATCH_QUEUE_SERIAL);for (int i = 0; i &lt; 100 ; i ++) {    dispatch_async(serialQueue, ^{        NSLog(@&quot;serialQueue%@&quot;,@(i));    });}</code></pre><p>当队列为Serial Dispatch(串行队列)时,因为需要等待现在执行中的处理结束,所以首先执行第一个block,第一个block执行结束后,接着执行第二个block,如此重复。同时执行的处理数只有1个。</p><pre><code>serialQueue0serialQueue1serialQueue2serialQueue3serialQueue4serialQueue5...serialQueue97serialQueue98serialQueue99</code></pre><p>当队列为Concurrent Dispath Queue时,因为不用等待现在执行中的处理结束,所以首先执行第一个block,不管第一个block的执行是否结束,都开始执行后面的第二个block,不管第二个block的执行是否结束,都开始执行后面的第三个block,如此重复循环。</p><p><strong>并行执行的处理数量取决于当前的系统的状态。即iOS和OS X基于Dispatch Queue中的处理数、CPU核数以及CPU负荷等当前系统的状态来决定Concurrent Dispath Queue中并行执行的处理数</strong></p><p><img src="http://ww1.sinaimg.cn/large/8af26a6dly1fz62icb3m2j21520qygne.jpg" alt=""></p><p>下面我们总结下不同种类的队列和不同执行方式的组合:</p><p>第一种: <strong>串行队列同步执行</strong></p><pre><code>//串行队列同步- (void)serialQueueSyncMethod{    //创建队列    dispatch_queue_t queue = dispatch_queue_create(&quot;serialQueueSyncMethod&quot;, DISPATCH_QUEUE_SERIAL);    //执行任务    for (int i = 0; i &lt; 6; i++) {        NSLog(@&quot;mainThread---&gt;%d&quot;,i);        dispatch_sync(queue, ^{            NSLog(@&quot;Current Thread=%@----&gt;%d-----&quot;,[NSThread currentThread],i);        });    }    NSLog(@&quot;串行队列同步end&quot;);}</code></pre><p>打印结果:</p><pre><code> mainThread---&gt;0 Current Thread=&lt;NSThread: 0x6000014a5480&gt;{number = 1, name = main}----&gt;0-----mainThread---&gt;1Current Thread=&lt;NSThread: 0x6000014a5480&gt;{number = 1, name = main}----&gt;1----- mainThread---&gt;2 Current Thread=&lt;NSThread: 0x6000014a5480&gt;{number = 1, name = main}----&gt;2-----mainThread---&gt;3 Current Thread=&lt;NSThread: 0x6000014a5480&gt;{number = 1, name = main}----&gt;3----- mainThread---&gt;4 Current Thread=&lt;NSThread: 0x6000014a5480&gt;{number = 1, name = main}----&gt;4-----mainThread---&gt;5 Current Thread=&lt;NSThread: 0x6000014a5480&gt;{number = 1, name = main}----&gt;5----- 串行队列同步end</code></pre><p>小结: 串行队列同步执行打印结果是交替进行的。<strong>同步执行不会开启新线程</strong>,串行队列需要等待现在执行中的处理结束,才会派发任务到当前线程(例子中当前线程是主线程)去执行,所以任务是依次执行的。</p><p>第二种: <strong>串行队列异步执行</strong></p><pre><code>//串行队列异步- (void)serialQueueAsyncMethod{    dispatch_queue_t queue = dispatch_queue_create(&quot;serialQueueAsyncMethod&quot;, DISPATCH_QUEUE_SERIAL);    for (int i = 0; i &lt; 6; i++) {        NSLog(@&quot;mainThread---&gt;%d&quot;,i);        dispatch_async(queue, ^{            NSLog(@&quot;Current Thread=%@----&gt;%d-----&quot;,[NSThread currentThread],i);        });    }    NSLog(@&quot;串行队列异步end&quot;);}</code></pre><p>打印结果:</p><pre><code>mainThread---&gt;0mainThread---&gt;1mainThread---&gt;2mainThread---&gt;3mainThread---&gt;4mainThread---&gt;5串行队列异步endCurrent Thread=&lt;NSThread: 0x6000028d8740&gt;{number = 3, name = (null)}----&gt;0-----Current Thread=&lt;NSThread: 0x6000028d8740&gt;{number = 3, name = (null)}----&gt;1-----Current Thread=&lt;NSThread: 0x6000028d8740&gt;{number = 3, name = (null)}----&gt;2-----Current Thread=&lt;NSThread: 0x6000028d8740&gt;{number = 3, name = (null)}----&gt;3-----Current Thread=&lt;NSThread: 0x6000028d8740&gt;{number = 3, name = (null)}----&gt;4-----Current Thread=&lt;NSThread: 0x6000028d8740&gt;{number = 3, name = (null)}----&gt;5-----</code></pre><p>小结:执行结果看出打印结果并不是交替执行的。打印中number=5,说明block任务是在一个新的线程中执行的。因为<strong>异步执行会开辟线程</strong>,串行队列需要等待现在执行中的处理结束,才会派发任务到这个新线程去执行,所以任务是依次执行的。</p><p>第三种: <strong>并发队列同步执行</strong></p><pre><code>//并行队列同步- (void)concurrentQueueSyncMethod{  dispatch_queue_t queue = dispatch_queue_create(&quot;concurrentQueueSyncMethod&quot;, DISPATCH_QUEUE_CONCURRENT);  for (int i = 0; i &lt; 6; i++) {      dispatch_sync(queue, ^{          NSLog(@&quot;Current Thread=%@----&gt;%d-----&quot;,[NSThread currentThread],i);      });  }  NSLog(@&quot;并行队列同步end&quot;);}</code></pre><p>打印结果:</p><pre><code>Current Thread=&lt;NSThread: 0x600002852fc0&gt;{number = 1, name = main}----&gt;0-----Current Thread=&lt;NSThread: 0x600002852fc0&gt;{number = 1, name = main}----&gt;1-----Current Thread=&lt;NSThread: 0x600002852fc0&gt;{number = 1, name = main}----&gt;2-----Current Thread=&lt;NSThread: 0x600002852fc0&gt;{number = 1, name = main}----&gt;3-----Current Thread=&lt;NSThread: 0x600002852fc0&gt;{number = 1, name = main}----&gt;4-----Current Thread=&lt;NSThread: 0x600002852fc0&gt;{number = 1, name = main}----&gt;5-----并行队列同步end</code></pre><p>小结: 并发队列同步执行与串行队列同步执行是相同的,并发队列不需要等待现在执行中的处理结束,由于同步执行没有创建新的线程,并发队列会派发所有任务到当前线程(例子中当前线程是主线程)去执行,由于队列遵循FIFO规则,所以执行结果也是依次的</p><p>第四种: <strong>并行队列异步</strong></p><pre><code>//并行队列异步- (void)concurrentQueueAsyncMethod{  dispatch_queue_t queue = dispatch_queue_create(&quot;concurrentQueueAsyncMethod&quot;, DISPATCH_QUEUE_CONCURRENT);  for (int i = 0; i &lt; 6; i++) {      dispatch_async(queue, ^{          NSLog(@&quot;Current Thread=%@----&gt;%d-----&quot;,[NSThread currentThread],i);      });  }  NSLog(@&quot;并行队列异步end&quot;);}</code></pre><p>打印结果:</p><pre><code>并行队列异步endCurrent Thread=&lt;NSThread: 0x6000028d8500&gt;{number = 10, name = (null)}----&gt;0-----Current Thread=&lt;NSThread: 0x6000028ddfc0&gt;{number = 5, name = (null)}----&gt;1-----Current Thread=&lt;NSThread: 0x6000028d8fc0&gt;{number = 11, name = (null)}----&gt;2-----Current Thread=&lt;NSThread: 0x6000028d8500&gt;{number = 10, name = (null)}----&gt;4-----Current Thread=&lt;NSThread: 0x6000028d9740&gt;{number = 12, name = (null)}----&gt;5-----Current Thread=&lt;NSThread: 0x6000028d9140&gt;{number = 13, name = (null)}----&gt;3-----</code></pre><p>小结:并发队列异步执行从结果看开辟了多个线程,并且不是顺序执行。主线程执行的”并行队列异步end”打印。<strong>异步执行会开启新的线程</strong>,并发队列不需要等待现在执行中的处理结束,就开始派发下一个队列中的任务,所以不是顺序。</p><p>补充:</p><ol><li>当生成多个Serial Dispath Queue<strong>异步</strong>执行时候,各个Serial Dispath Queue都将并行执行。虽然在一个Serial Dispath Queue中同时只能执行一个追加处理,但是如果将处理分别追加到多个Serial Dispath Queue中,各个Serial Dispath Queue执行1个,即为同时执行多个处理。</li></ol><p><img src="http://ww1.sinaimg.cn/large/8af26a6dly1fz63cr8d02j21860z0jt5.jpg" alt=""><br>一旦生成Serial Dispath Queue并追加处理,系统对于一个Serial Dispath Queue就只生成并使用一个线程。</p><p>2.主队列同步执行</p><p>我们来看第一段代码</p><pre><code>//获取主队列dispatch_queue_t queue = dispatch_get_main_queue();//执行任务dispatch_sync(queue, ^{    NSLog(@&quot;main_queue_sync%@&quot;,[NSThread currentThread]);});NSLog(@&quot;main_queue_sync_end&quot;);</code></pre><p>这样会死锁, dispatch_sync这个函数目前是在主线程中执行的,当这个函数执行完成后主队列才会将下一个任务派遣到主线程中执行,但dispatch_sync执行完成的条件是里面的block返回,里面的block是不会执行的, 因为dispatch_sync这个函数将block任务放到主队列中了,这个block任务需要等待主线程中的任务执行的dispatch_sync函数完成才会执行</p><p>我们来看第二段代码</p><pre><code>//创建队列dispatch_queue_t queue = dispatch_queue_create(&quot;serialQueueSyncMethod&quot;, DISPATCH_QUEUE_SERIAL);dispatch_sync(queue, ^{    NSLog(@&quot;Current Thread=%@&quot;,[NSThread currentThread]);});</code></pre><p>这样不会死锁,因为<strong>阻塞的是队列不是线程</strong>,输出的block确实也是在主线程中执行,如果sync阻塞的是主线程,那按道理这样确实会死锁,但实际上sync阻塞的是主队列,而不是主线程,这样写的运行结果是, dispatch_sync运行在主队列,而其block运行在queue队列,虽然两个队列都是主线程执行,由于dispatch_sync阻塞的只是主队列,block在queue队列由主线程执行完成并返回,从而dispatch_sync返回,之后主队列结束阻塞继续执行下面的任务。原理是此处的queue队列是运行在主队列中的另一串行队列。</p><p>正确的串行队列阻塞写法应该是:</p><pre><code>dispatch_queue_t serialQueue = dispatch_queue_create(&quot;com.excomple.serial&quot;, DISPATCH_QUEUE_SERIAL);dispatch_sync(serialQueue, ^{    dispatch_sync(serialQueue, ^{        NSLog(@&quot;模拟串行队列崩溃&quot;);    });});</code></pre><p>这样就把串行队列queue阻塞了</p><h4 id="dispatch-set-target-queue"><a href="#dispatch-set-target-queue" class="headerlink" title="dispatch_set_target_queue"></a>dispatch_set_target_queue</h4><p><strong>作用:</strong> 变更生成的Dispath Queue的执行优先级</p><h4 id="dispatch-after"><a href="#dispatch-after" class="headerlink" title="dispatch_after"></a>dispatch_after</h4><p><strong>作用:</strong> 在指定时间后执行处理的情况 </p><pre><code>dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3ull * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{    NSLog(@&quot;waited at least three seconds.&quot;);});</code></pre><p>因为Main Dispatch Queue在主线程中的RunLoop中执行,所以在比如每隔1/60秒执行的RunLoop中,Block最快在3秒后执行,最慢在3秒+1/60秒后执行,并且在Main Dispatch Queue有大量处理追加活主线程的处理本身有延迟时,这个时间会更长。</p><h4 id="Dispatch-Group"><a href="#Dispatch-Group" class="headerlink" title="Dispatch Group"></a>Dispatch Group</h4><p><strong>作用:</strong> 追加到Dispatch Queue中的多个处理全部结束后想执行结束处理。</p><p>在追加到Dispatch Queue中的多个处理全部结束后想执行结束处理,只使用一个Serial Dispatch Queue时,只要将想执行的处理全部追加到该Serial Dispatch Queue中并在最后追加结束处理,就可以实现。但是在使用Concurrent Dispatch Queue时或同时使用多个Dispatch Queue时,就需要用到Dispatch Group了</p><pre><code>    dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;example.test.com&quot;, DISPATCH_QUEUE_CONCURRENT);dispatch_group_t group = dispatch_group_create();for (int i = 0; i &lt; 5; i ++) {    dispatch_group_async(group, concurrentQueue, ^{         NSLog(@&quot;block%@&quot;,@(i));    });}dispatch_group_notify(group, concurrentQueue, ^{    NSLog(@&quot;done&quot;);});</code></pre><hr><p>执行结果为</p><pre><code>block3block1block0block2block4 done</code></pre><p>多个派发队列情况:</p><pre><code>dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;example.test.com&quot;, DISPATCH_QUEUE_CONCURRENT);dispatch_queue_t anotherConcurrentQueue = dispatch_queue_create(&quot;example.another.test.com&quot;, DISPATCH_QUEUE_CONCURRENT);dispatch_group_t group = dispatch_group_create();for (int i = 0; i &lt; 100; i ++) {    dispatch_group_async(group, concurrentQueue, ^{        NSLog(@&quot;block%@ === thread=%@&quot;,@(i),[NSThread currentThread]);    });    dispatch_group_async(group, anotherConcurrentQueue, ^{        NSLog(@&quot;anotherBlock%@ === thread=%@&quot;,@(i),[NSThread currentThread]);    });}dispatch_group_notify(group, concurrentQueue, ^{    NSLog(@&quot;done&quot;);});dispatch_group_notify(group, anotherConcurrentQueue, ^{    NSLog(@&quot;anotherDone&quot;);});</code></pre><p>打印结果:</p><pre><code>...block80 === thread=&lt;NSThread: 0x6000021b7040&gt;{number = 6, name = (null)}block98 === thread=&lt;NSThread: 0x6000021b0ec0&gt;{number = 24, name = (null)}anotherBlock98 === thread=&lt;NSThread: 0x6000021b1140&gt;{number = 30, name = (null)}block99 === thread=&lt;NSThread: 0x6000021b1200&gt;{number = 32, name = (null)}anotherBlock99 === thread=&lt;NSThread: 0x6000021b1400&gt;{number = 38, name = (null)}}anotherBlock85 === thread=&lt;NSThread: 0x60000218cbc0&gt;{number = 57, name = (null)}block85 === thread=&lt;NSThread: 0x6000021b1cc0&gt;{number = 60, name = (null)}doneanotherDone</code></pre><p>多个派发队列任务追加到Dispatch Group中,需要多个队列中的任务都执行完成,多个dispatch_group_notify才分别执行的</p><h4 id="dispatch-barrier-async"><a href="#dispatch-barrier-async" class="headerlink" title="dispatch_barrier_async"></a>dispatch_barrier_async</h4><ul><li>barrier顾名思义是栅栏、障碍物的意思<br>在访问数据库或者文件时,使用Serial Dispatch Queue可避免数据竞争的问题。</li></ul><p>写入处理确实不可与其他的写入处理以及包含读取处理的其他某些处理并行执行。但是如果读取处理只是与读取并行执行,那么多个并行执行就不会发生问题。</p><p>也就是说,为了高效率地进行访问,读取处理追加到Concurrent Dispatch Queue中,写入处理在任一个读取处理没有执行的状态下,追加到Serial Dispatch Queue中即可(在写入处理结束之前,读取处理不可执行)。</p><p>虽然利用Dispatch Group和dispath_set_target_queue函数也可实现,但代码会稍微复杂。有兴趣的可以尝试下。</p><p>GCD为我们提供了更为聪明的解决方法: dispatch_barrier_async函数。该函数同并发队列一起使用。</p><pre><code> void(^block1_reading)(void) = ^{    NSLog(@&quot;block1_reading&quot;);};void(^block2_reading)(void) = ^{    NSLog(@&quot;block2_reading&quot;);};void(^block3_reading)(void) = ^{    NSLog(@&quot;block3_reading&quot;);};void(^block4_reading)(void) = ^{    NSLog(@&quot;block4_reading&quot;);};void(^block5_reading)(void) = ^{    NSLog(@&quot;block5_reading&quot;);};void(^block_writing)(void) = ^{    NSLog(@&quot;block_writing&quot;);};dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;example.test.com&quot;, DISPATCH_QUEUE_CONCURRENT);dispatch_async(concurrentQueue, block1_reading);dispatch_async(concurrentQueue, block2_reading);dispatch_async(concurrentQueue, block3_reading);dispatch_barrier_async(concurrentQueue, block_writing);dispatch_async(concurrentQueue, block4_reading);dispatch_async(concurrentQueue, block5_reading);</code></pre><p>打印结果</p><pre><code>block2_readingblock1_readingblock3_readingblock_writingblock4_readingblock5_reading</code></pre><p><img src="http://ww1.sinaimg.cn/large/8af26a6dly1fz8hrhsef7j21a00swwgi.jpg" alt=""><br>    使用 Concurrent Dispatch Queue和dispatch_barrier_async函数可实现高效率的数据库访问和文件访问,但是栅栏函数只能保证<strong>这个队列</strong>同时只执行1个任务。</p><h4 id="dispatch-apply"><a href="#dispatch-apply" class="headerlink" title="dispatch_apply"></a>dispatch_apply</h4><ul><li>dispatch_apply函数是dispatch_sync函数和Dispatch Group的关联api。该函数按照指定的次数将指定的block追加到指定的Dispatch Queue中,并等待全部处理执行结束。</li></ul><p>使用方法</p><p><strong>dispatch_apply( 循环次数, 任务所在队列 ) {要循环执行的任务}。</strong></p><p>由于dispatch_apply函数也与dispatch_sync函数相同,会等待处理执行结束,因此推荐在dispatch_async函数中非同步的执行dispatch_apply函数。</p><pre><code>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);void(^blk1_reading)(void) = ^{    NSLog(@&quot;blk1---reading&quot;);};void(^blk2_reading)(void) = ^{    NSLog(@&quot;blk2---reading&quot;);};void(^blk3_reading)(void) = ^{    NSLog(@&quot;blk3---reading&quot;);};void(^blk_writing)(void) = ^{    NSLog(@&quot;blk---writing&quot;);};NSMutableArray *array = [NSMutableArray new];[array addObject:blk1_reading];[array addObject:blk2_reading];[array addObject:blk3_reading];[array addObject:blk_writing];dispatch_async(queue, ^{    dispatch_apply(array.count, queue, ^(size_t index) {        void (^blk)(void) = [array objectAtIndex:index];        blk();        NSLog(@&quot;%zu====%@&quot;,index,[array objectAtIndex:index]);    });    NSLog(@&quot;全部执行结束&quot;);    dispatch_async(dispatch_get_main_queue(), ^{        //在main Dispatch queue中执行处理，更新用户界面等待        NSLog(@&quot;done&quot;);    });});</code></pre><p>执行结果</p><pre><code>blk1---readingblk2---readingblk3---reading0====&lt;__NSGlobalBlock__: 0x101279ac8&gt;1====&lt;__NSGlobalBlock__: 0x101279b08&gt;blk---writing2====&lt;__NSGlobalBlock__: 0x101279b48&gt;3====&lt;__NSGlobalBlock__: 0x101279b88&gt;全部执行结束done</code></pre><h4 id="dispatch-suspend-dispatch-resume"><a href="#dispatch-suspend-dispatch-resume" class="headerlink" title="dispatch_suspend/dispatch_resume"></a>dispatch_suspend/dispatch_resume</h4><p>使用: dispatch_suspend(queue);// 挂起queue这个队列<br>      dispatch_resume(queue);// 唤醒queue这个队列</p><pre><code>//系统默认生成的，所以无法调用dispatch_resume()和dispatch_suspend()来控制执行继续或中断。dispatch_queue_t queue1 = dispatch_queue_create(&quot;queue1&quot;, 0);dispatch_queue_t queue2 = dispatch_queue_create(&quot;queue2&quot;, 0);dispatch_group_t group = dispatch_group_create();dispatch_async(queue1, ^{    for (int i = 0; i &lt; 5; i++) {        NSLog(@&quot;%@-------%d&quot;,[NSThread currentThread],i);        sleep(1);    }});dispatch_async(queue2, ^{    NSLog(@&quot;task2&quot;);});dispatch_group_async(group, queue1, ^{    NSLog(@&quot;task1 finished!&quot;);});dispatch_group_async(group, queue2, ^{    dispatch_suspend(queue1);//挂起    NSLog(@&quot;task2 finished!挂起queue1&quot;);    [NSThread sleepForTimeInterval:10.0];    dispatch_resume(queue1);//唤醒队列});dispatch_group_wait(group, DISPATCH_TIME_FOREVER);dispatch_async(queue1, ^{    NSLog(@&quot;task3&quot;);});dispatch_async(queue2, ^{    NSLog(@&quot;task4&quot;);});</code></pre><p>打印结果:</p><pre><code>ThreadDemo[54913:1615402] task2ThreadDemo[54913:1615006] &lt;NSThread: 0x600003499540&gt;{number = 3, name = (null)}-------0ThreadDemo[54913:1615402] task2 finished!挂起queue1ThreadDemo[54913:1615006] &lt;NSThread: 0x600003499540&gt;{number = 3, name = (null)}-------1ThreadDemo[54913:1615006] &lt;NSThread: 0x600003499540&gt;{number = 3, name = (null)}-------2ThreadDemo[54913:1615006] &lt;NSThread: 0x600003499540&gt;{number = 3, name = (null)}-------3ThreadDemo[54913:1615006] &lt;NSThread: 0x600003499540&gt;{number = 3, name = (null)}-------4ThreadDemo[54913:1615006] task1 finished!ThreadDemo[54913:1615006] task3ThreadDemo[54913:1615402] task4</code></pre><p>解释: 队列挂起之前,队列已经派遣的任务可以执行完成;未派遣的任务,需要等队列被唤醒之后才能执行。</p><h4 id="dispatch-once"><a href="#dispatch-once" class="headerlink" title="dispatch_once"></a>dispatch_once</h4><p><strong>作用:</strong> 保证应用程序执行中只执行一次指定处理的API。dispatch_once函数在多线程环境下执行,也可保证百分之百安全。</p><h3 id="GCD中的Dispatch-Queue"><a href="#GCD中的Dispatch-Queue" class="headerlink" title="GCD中的Dispatch Queue"></a>GCD中的Dispatch Queue</h3><p>编程人员所使用GCD的API全部为包含在libdispatch库中的C语言函数。 Dispatch Queue通过结构体和链表,被实现为FIFO队列。FIFO队列管理是通过dispatch_async等函数所谁家的Block。</p><p>Block并不是直接加入FIFO队列,而是先加入Dispatch Continuation这一dispatch_continuation_t类型结构体重,然后再加入FIFO队列。该Dispatch Continuation用于记忆Block所属的Dispatch Group和其他一些信息,相当于一般常说的执行上下文。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在实际开项目开发中为了能够给用户更好的体验，有些延时操作我们都会放在子线程中进行。今天我们就来聊聊多线程在实际项目中的运用。&lt;/p&gt;
&lt;h3 id=&quot;基本知识&quot;&gt;&lt;a href=&quot;#基本知识&quot; class=&quot;headerlink&quot; title=&quot;基本知识&quot;&gt;&lt;/a&gt;基本知识&lt;/h3&gt;&lt;h4 id=&quot;进程-process&quot;&gt;&lt;a href=&quot;#进程-process&quot; class=&quot;headerlink&quot; title=&quot;进程(process)&quot;&gt;&lt;/a&gt;进程(process)&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;进程是一个具有一定独立功能的程序关于某次数据集合的一次运行活动,它是操作系统分配资源的基本单元&lt;/li&gt;
&lt;li&gt;一个软件启动就是一个进程,每个进程之间是相互独立的,每个进程均运行在其专用且受保护的内存空间内。&lt;/li&gt;
&lt;li&gt;进程状态: 进程有三个状态,就绪、运行和阻塞。就绪状态其实就是获取了除cpu外的所有资源,只要处理器分配资源马上就可以运行。运行状态就是获取了处理器分配ƒ的资源,程序开始执行。阻塞状态:当程序条件不够时,需要等待条件满足时才能执行;比如等待I/O操作的时候,此刻的状态就叫阻塞&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>19.iOS Block详解(三)</title>
    <link href="http://waythought.duoshuo.com/2018/05/31/19.iOS%20Block%E8%AF%A6%E8%A7%A3(%E4%B8%89)/"/>
    <id>http://waythought.duoshuo.com/2018/05/31/19.iOS Block详解(三)/</id>
    <published>2018-05-31T03:12:36.000Z</published>
    <updated>2020-02-17T02:34:44.210Z</updated>
    
    <content type="html"><![CDATA[<h1 id="block的循环引用问题"><a href="#block的循环引用问题" class="headerlink" title="block的循环引用问题"></a>block的循环引用问题</h1><p>什么是block的循环引用,简单来说对象持有block, block持有这个对象</p><p>注意: block访问带下划线的属性,也会造成循环引用,因为block肯定是取到对象本身才能拿到属性。</p><h1 id="ARC-解决循环引用问题"><a href="#ARC-解决循环引用问题" class="headerlink" title="ARC-解决循环引用问题"></a>ARC-解决循环引用问题</h1><p>由于我们需要对象持有block,来控制block的声明周期,所以解决循环引用我们一般设置block对对象的引用是弱引用即可。</p><a id="more"></a><h2 id="使用-weak修饰对象"><a href="#使用-weak修饰对象" class="headerlink" title="使用__weak修饰对象"></a>使用__weak修饰对象</h2><p>我们需要使用__weak去修饰这个对象, block中的进行copy操作后,会调用block内部的copy函数,copy函数会调用_Block_object_assign函数,该函数会对根据对象的修饰符(__strong、__weak、__unsafe_unretained),做出相应的操作,形成强引用(retain)或者弱引用</p><p>在block中直接使用weakSelf有没有风险,如果不使用__strong修饰一遍的话?</p><p>有风险, 使用__strong修饰保证在block执行的时候self不会释放掉。 </p><h2 id="使用-unsafe-unretained修饰对象"><a href="#使用-unsafe-unretained修饰对象" class="headerlink" title="使用__unsafe_unretained修饰对象"></a>使用__unsafe_unretained修饰对象</h2><p>__weak只是不会产生强引用</p><p>__unsafe_unretained不会进行产生强引用,但是不安全</p><p>__weak在指向的对象销毁时,会自动把指针置为nil</p><p>__unsafe_unretained在指向的对象销毁时,不会置成nil,任然指向的是原对象内存地址</p><h2 id="补充使用-block解决循环引用问题"><a href="#补充使用-block解决循环引用问题" class="headerlink" title="补充使用  __block解决循环引用问题"></a>补充使用  __block解决循环引用问题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        __block MFPerson *person = [[MFPerson alloc] init];</div><div class="line">        person.age = 10;</div><div class="line">        person.block = ^&#123;</div><div class="line">            NSLog(@&quot;person age = %@&quot;, @(person.age));</div><div class="line">            person = nil;</div><div class="line">        &#125;;</div><div class="line">        person.block();</div><div class="line">    &#125;</div><div class="line">    NSLog(@&quot;autoreleasepool did end&quot;);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>打印结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">person age = 10</div><div class="line">-[MFPerson dealloc]</div><div class="line">autoreleasepool did end</div></pre></td></tr></table></figure><p>注意这里需要把person对象设置为nil</p><p>block对象对包装好的结构体(<strong>block修饰)是强引用,包装好的结构体里对实例对象是强引用(由于</strong>strong修饰),实例对象对block是强引用。是个三角循环引用</p><p><code>person = nil</code>是将包装好的结构体里对实例对象是引用设置为空了</p><p><strong>这里必须要执行block,并且在block的实现里面要把实例对象设置为nil</strong></p><h1 id="MRC-解决循环引用问题"><a href="#MRC-解决循环引用问题" class="headerlink" title="MRC-解决循环引用问题"></a>MRC-解决循环引用问题</h1><p>由于MRC下不支持弱指针,所以不能使用__weak,我们可以使用__unsafe_unretained去解决</p><h2 id="使用-unsafe-unretained修饰对象-1"><a href="#使用-unsafe-unretained修饰对象-1" class="headerlink" title="使用__unsafe_unretained修饰对象"></a>使用__unsafe_unretained修饰对象</h2><p>与ARC下原理相同</p><h2 id="使用-block解决循环引用问题"><a href="#使用-block解决循环引用问题" class="headerlink" title="使用  __block解决循环引用问题"></a>使用  __block解决循环引用问题</h2><p>上篇文章介绍了我们对block进行copy操作,__block做出相应的操作copy修饰</p><p> block中的系统包装好的结构体(__block修饰)在调用_Block_object_assign函数的时候,不会对访问的对象进行retain操作。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;block的循环引用问题&quot;&gt;&lt;a href=&quot;#block的循环引用问题&quot; class=&quot;headerlink&quot; title=&quot;block的循环引用问题&quot;&gt;&lt;/a&gt;block的循环引用问题&lt;/h1&gt;&lt;p&gt;什么是block的循环引用,简单来说对象持有block, block持有这个对象&lt;/p&gt;
&lt;p&gt;注意: block访问带下划线的属性,也会造成循环引用,因为block肯定是取到对象本身才能拿到属性。&lt;/p&gt;
&lt;h1 id=&quot;ARC-解决循环引用问题&quot;&gt;&lt;a href=&quot;#ARC-解决循环引用问题&quot; class=&quot;headerlink&quot; title=&quot;ARC-解决循环引用问题&quot;&gt;&lt;/a&gt;ARC-解决循环引用问题&lt;/h1&gt;&lt;p&gt;由于我们需要对象持有block,来控制block的声明周期,所以解决循环引用我们一般设置block对对象的引用是弱引用即可。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>18.iOS Block详解(二)</title>
    <link href="http://waythought.duoshuo.com/2018/05/01/18.iOS%20Block%E8%AF%A6%E8%A7%A3(%E4%BA%8C)/"/>
    <id>http://waythought.duoshuo.com/2018/05/01/18.iOS Block详解(二)/</id>
    <published>2018-05-01T07:02:04.000Z</published>
    <updated>2020-02-17T02:34:37.372Z</updated>
    
    <content type="html"><![CDATA[<h1 id="block使用和原理"><a href="#block使用和原理" class="headerlink" title="__block使用和原理"></a>__block使用和原理</h1><ul><li>__block可以用于解决block内部无法修改auto变量的问题</li><li>__block不能修饰全局变量、静态变量(static)</li><li>编译器会将__block变量包装成一个对象</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        MFPerson *person = [[MFPerson alloc] init];</div><div class="line">        person.age = 10;</div><div class="line">        void(^myBlock)(void) = ^&#123;</div><div class="line">            person = nil;</div><div class="line">            NSLog(@&quot;person == %d&quot;, person.age);</div><div class="line">        &#125;;</div><div class="line">        myBlock();</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里的person = nil会编译报错。person是声明在main函数中, 内存是在main函数的main空间, block执行的代码是在func函数中。独立的函数不能互相访问,作用域问题</p><a id="more"></a><p>我们来看下如下的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        MFPerson *person = [[MFPerson alloc] init];</div><div class="line">        person.age = 10;</div><div class="line">        void(^myBlock)(void) = ^&#123;</div><div class="line">            person.age = 20;</div><div class="line">            NSLog(@&quot;person age = %d&quot;, person.age);</div><div class="line">        &#125;;</div><div class="line">        myBlock();</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>打印结果为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">person age = 20</div></pre></td></tr></table></figure><p>虽然我们不能修改这个指针,我们可以拿过来这个指针使用。</p><p>我们如果想要在block内部访问外部变量,并且这个变量还是auto类型(使用static放在全局区,程序运行阶段不会销毁),需要使用__block</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        __block MFPerson *person = [[MFPerson alloc] init];</div><div class="line">        person.age = 10;</div><div class="line">        void(^myBlock)(void) = ^&#123;</div><div class="line">            person = nil;</div><div class="line">            NSLog(@&quot;person = %@&quot;, person);</div><div class="line">        &#125;;</div><div class="line">        myBlock();</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>打印结果为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">person = (null)</div></pre></td></tr></table></figure></p><p>这里的person指针还是在栈区, 还是auto类型</p><p>__block如何实现的呢</p><p>使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m</div></pre></td></tr></table></figure></p><p>将以下的OC代码转换成c++代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        __block int age = 10;</div><div class="line">        void(^myBlock)(void) = ^&#123;</div><div class="line">            age = 20;</div><div class="line">            NSLog(@&quot;person age is %d&quot;, age);</div><div class="line">        &#125;;</div><div class="line">        myBlock();</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>c++代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">    /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; </div><div class="line">    </div><div class="line">        __attribute__((__blocks__(byref))) __Block_byref_age_0 age = &#123;(void*)0,(__Block_byref_age_0 *)&amp;age, 0, sizeof(__Block_byref_age_0), 10&#125;;</div><div class="line">        </div><div class="line">        void(*myBlock)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_age_0 *)&amp;age, 570425344));</div><div class="line">        ((void (*)(__block_impl *))((__block_impl *)myBlock)-&gt;FuncPtr)((__block_impl *)myBlock);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">struct __Block_byref_age_0 &#123;</div><div class="line">  void *__isa;</div><div class="line">__Block_byref_age_0 *__forwarding;</div><div class="line"> int __flags;</div><div class="line"> int __size;</div><div class="line"> int age;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct __main_block_impl_0 &#123;</div><div class="line">  struct __block_impl impl;</div><div class="line">  struct __main_block_desc_0* Desc;</div><div class="line">  __Block_byref_age_0 *age; // by ref</div><div class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_age_0 *_age, int flags=0) : age(_age-&gt;__forwarding) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>__Block_byref_age_0结构体存储着isa和age, 在block中修改的age的值,存储在__Block_byref_age_0的结构体中, __size代表了他这个结构体占用的内存大小,</p><p>我们看下这个结构体如何赋值的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">__attribute__((__blocks__(byref))) __Block_byref_age_0 age = &#123;(void*)0,(__Block_byref_age_0 *)&amp;age, 0, sizeof(__Block_byref_age_0), 10&#125;;</div></pre></td></tr></table></figure></p><p>相当于把 &amp;age这个结构体赋值给第二个成员变量,也就是 <strong>Block_byref_age_0 *</strong>forwarding存储的地址, 指向这个<strong>Block_byref_age_0结构体他自己,也就是指向结构体自己的</strong>isa。 </p><p>把变量age的值赋值给结构体的第五个成员变量,保存起来</p><p>block实现的时候也会把上面的age结构体 &amp;age传给这个结构体, 也就是会把上面的age的结构体地址传递给__main_block_impl_0函数的第三个参数。</p><p>我们看下执行代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class="line">  __Block_byref_age_0 *age = __cself-&gt;age; // bound by ref</div><div class="line"></div><div class="line">            (age-&gt;__forwarding-&gt;age) = 20;</div><div class="line">            NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_cg_39bx6n8912b59t0sp6dr_rlm0000gn_T_main_4795a0_mi_0, (age-&gt;__forwarding-&gt;age));</div><div class="line">        &#125;</div></pre></td></tr></table></figure><p>取出这个结构体</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">__Block_byref_age_0 *age = __cself-&gt;age</div></pre></td></tr></table></figure><p>对结构体age的__forwarding指向的age成员进行赋值,结构体存储了这个值。NSLog函数也是这样取值的</p><p>使用__block修饰的age被block捕获, 再block内部或者外部访问age,访问的是block中捕获的结构体中的成员变量的age</p><h1 id="block的内存管理-基本数据类型"><a href="#block的内存管理-基本数据类型" class="headerlink" title="__block的内存管理 (基本数据类型)"></a>__block的内存管理 (基本数据类型)</h1><p>当block在栈上的时候,并不会对__block变量产生强引用</p><p>当block被拷贝到堆上时,会调用block内部的copy函数。copy函数内部会调用__Block_object_assgin函数,__Block_object_assgin函数会对__block形成强引用(retain),也就是会对block内部的<figure class="highlight plain"><figcaption><span>*age;```形成强引用</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line"> </div><div class="line">**block经过系统的copy放到了堆区,同时也会将block使用的__block变量也拷贝到堆上,并且block对__block变量是个强引用。**</div><div class="line"> </div><div class="line">多个block访问同一个__block变量,只会copy一次这个变量到堆上, 不会重复copy。第一次访问的时候会copy,但是这几个block都会对block进行强引用。</div><div class="line"> </div><div class="line"> </div><div class="line">当block从堆上移除的时候,对调用block内部的dispose函数。dispose函数内部会调用\_Block\_object\_dispose函数,此函数会自动释放引用的__block变量。</div><div class="line"> </div><div class="line"> </div><div class="line">如果是访问的 NSObject *object = [[NSObject alloc] init];</div><div class="line">由于系统会copy,把block升级为堆块,堆上的block会根据object是__strong修饰的还是__weak修饰的,来判断是否对这个对象进行强引用(因为alloc出来的对象就是在堆区的)</div><div class="line"></div><div class="line"></div><div class="line">_\_Block\_object\_assgin函数入参会根据不同类型变量做区分(例如__block修饰的int 类型传入的是8, NSObject类型传入的是 3)</div></pre></td></tr></table></figure></p><p>(age-&gt;__forwarding-&gt;age) = 20;</p><p>```<br>赋值的时候为什么是找到结构体后,再找__forwading指针,根据这个指针找到结构体,在给结构体中的成员变量赋值呢。</p><p>系统想要赋值给堆上的这个结构体。</p><p>如果block未copy, 栈上的结构体的__forwading指针指向的是本身栈上这个结构体</p><p>如果block进行copy后,栈上结构体的<strong>forwading指向的是拷贝到堆区的结构体。这样就能保证赋值的肯定是堆上的结构体。堆上的</strong>forwarding指针指向的是他自己</p><p>所以无论是栈上的__block结构体还是堆上的, 在赋值的时候都是堆上这个结构体。<br><img src="http://ww1.sinaimg.cn/large/8af26a6dly1fxw0c0mk9xj20j30e0q36.jpg" alt=""></p><p>问题: 将__block修饰的变量拷贝到堆区的话, block本身的变量指针指向的是栈区的还是堆区的呢?</p><p>发生变化了, 指向堆上的变量结构体了。</p><h1 id="被-block修饰对象类型"><a href="#被-block修饰对象类型" class="headerlink" title="被__block修饰对象类型"></a>被__block修饰对象类型</h1><p>也会将这个对象包装成为一个结构体,将对象的指针包装在结构体中, 这个指针指向malloc的对象的内存地址</p><p>不伦对象是<strong>strong修饰的还是</strong>weak修饰的,block指向的包装好的结构体是强指针(copy决定的),这里不存在弱引用。<strong>包装好的结构体拷贝到堆上,同时这个包装好的结构体也会调用自身的copy方法(非对象类型的包装成的结构体没有这个方法)。,会调用包装好结构体中的assign函数,</strong> 进行判断,包装好的结构体里面的person指针对这个对象的强弱引用是根据对象如果是<strong>strong修饰,结构体里面的person指针对这个对象就是强引用;如果是</strong>weak修饰,结构体里面的person指针对这个对象就是弱引用。</p><p>等到block销毁的时候,调用block的dispose函数, 解除对包装好的结构体的强引用,此时包装好的结构体也要进行销毁,调用自己的dispose函数,解除对该对象的引用(无论是强引用,还是弱引用)</p><p>assign函数会根据所指向对象的修饰符,做出相应的操作,形成强引用或者弱引用(注意:这里ARC下会retain操作,MRC下则不会retain)</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;block使用和原理&quot;&gt;&lt;a href=&quot;#block使用和原理&quot; class=&quot;headerlink&quot; title=&quot;__block使用和原理&quot;&gt;&lt;/a&gt;__block使用和原理&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;__block可以用于解决block内部无法修改auto变量的问题&lt;/li&gt;
&lt;li&gt;__block不能修饰全局变量、静态变量(static)&lt;/li&gt;
&lt;li&gt;编译器会将__block变量包装成一个对象&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;int main(int argc, const char * argv[]) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    @autoreleasepool &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        MFPerson *person = [[MFPerson alloc] init];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        person.age = 10;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        void(^myBlock)(void) = ^&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            person = nil;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            NSLog(@&amp;quot;person == %d&amp;quot;, person.age);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        myBlock();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    return 0;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里的person = nil会编译报错。person是声明在main函数中, 内存是在main函数的main空间, block执行的代码是在func函数中。独立的函数不能互相访问,作用域问题&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>17.iOS Block详解(一)</title>
    <link href="http://waythought.duoshuo.com/2018/04/23/17.iOS%20Block%E8%AF%A6%E8%A7%A3(%E4%B8%80)/"/>
    <id>http://waythought.duoshuo.com/2018/04/23/17.iOS Block详解(一)/</id>
    <published>2018-04-23T06:12:14.000Z</published>
    <updated>2020-02-17T02:34:29.626Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4><ul><li>Block本质是一个oc对象,它内部也有一个isa指针</li><li>Block的使用分为声明、实现、执行</li><li>Block是封装了函数调用以及函数调用环境的OC对象。函数调用就是block{}中的函数(存储了函数的调用地址),所谓的函数调用环境,就是内部函数调用需要的外界的变量</li></ul><a id="more"></a><h4 id="二、-Block的定义和使用"><a href="#二、-Block的定义和使用" class="headerlink" title="二、 Block的定义和使用"></a>二、 Block的定义和使用</h4><!-- More --><p><img src="http://ww1.sinaimg.cn/large/8af26a6dly1fxw0c0ryozj21bk0mu78c.jpg" alt=""></p><p>实际开发中常用typedef 定义Block</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// ^ 代表插入记号 typedef: 起别名  返回值(^名称)(参数列表)</div><div class="line">typedef void(^MyBlock)(int parameter);</div></pre></td></tr></table></figure><p>这时, MyBlock就成为了一种Block类型,在定义类的属性时可以这样:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, copy) MyBlock anotherBlock;</div></pre></td></tr></table></figure><h4 id="三、Block的底层数据结构"><a href="#三、Block的底层数据结构" class="headerlink" title="三、Block的底层数据结构"></a>三、Block的底层数据结构</h4><p>新建项目,使用以下命令将OC代码转成c++代码,来窥探本质</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m</div></pre></td></tr></table></figure><p>OC代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">     // 1. 定义block变量</div><div class="line">        void(^myBlock)(void) = ^&#123;</div><div class="line">            NSLog(@&quot;Hello, World!&quot;);</div><div class="line">        &#125;;</div><div class="line">        // 2. 调用block内部的代码</div><div class="line">        myBlock();</div><div class="line"> &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>转成的c++代码如下:(分别对应<strong>定义block变量</strong>和<strong>调用block内部的代码</strong>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">/* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; </div><div class="line">    // 1. 定义block变量</div><div class="line">    void(*myBlock)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</div><div class="line">// 2. 调用block内部的代码</div><div class="line">    ((void (*)(__block_impl *))((__block_impl *)myBlock)-&gt;FuncPtr)((__block_impl *)myBlock);</div><div class="line">&#125;</div><div class="line">return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="1-定义block变量删除多余修饰之后的代码为"><a href="#1-定义block变量删除多余修饰之后的代码为" class="headerlink" title="1. 定义block变量删除多余修饰之后的代码为"></a>1. 定义block变量删除多余修饰之后的代码为</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void(*myBlock)(void) = &amp;__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA);</div></pre></td></tr></table></figure><p>我们的block指向了<strong>__main_block_impl_0</strong>这个函数的返回值的地址。</p><p>我们发现<strong>__main_block_impl_0</strong>函数是定义在如下结构体中,在c++中这个函数是<strong>初始化方法并且返回它所在的这个结构体</strong>,也就是我们的block指向<strong>&amp;返回的结构体</strong>即<strong>这个结构体的内存地址</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">struct __main_block_impl_0 &#123;</div><div class="line">  struct __block_impl impl;</div><div class="line">  struct __main_block_desc_0* Desc;</div><div class="line">  // 构造函数,传参并返回函数所在的结构体</div><div class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>第一个成员变量<strong>impl</strong>的结构体为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">struct __block_impl &#123;</div><div class="line">  void *isa;</div><div class="line">  int Flags;</div><div class="line">  int Reserved;</div><div class="line">  void *FuncPtr;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p><strong>定义block的__main_block_impl_0函数的包含的参数有三个</strong></p><p><strong>第1个参数</strong>是 <strong>__main_block_func_0</strong>函数,代码如下。这个函数封装了block执行的逻辑(代码)。我们这里的block执行的代码只有NSLog这个一个函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_cg_39bx6n8912b59t0sp6dr_rlm0000gn_T_main_0781c4_mi_0);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们看到系统将<strong>__main_block_func_0</strong>函数地址赋值给了<strong>__main_block_impl_0</strong>结构体第一个变量<strong>impl</strong>的<strong>FuncPtr</strong>,也就是<strong>FuncPtr存储了将来要执行代码的函数的地址</strong>。</p><p><strong>注意: __main_block_impl_0</strong>函数除了这个fp参数,还定义了<strong>返回结构体的类型</strong>,存储在了<strong>impl</strong>的<strong>isa</strong>中,demo这个结构体是_NSConcreteStackBlock类型;关于<strong>Flags有默认值</strong>我们暂不谈论。</p><p><strong>第2个参数</strong>是<strong>__main_block_desc_0_DATA变量</strong>,这个结构体变量中包含(size_t reserved = 0)和<strong>这个block所占内存空间的大小</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">static struct __main_block_desc_0 &#123;</div><div class="line">  size_t reserved;</div><div class="line">  size_t Block_size;</div><div class="line">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</div></pre></td></tr></table></figure><p>我们看到系统将<strong>__main_block_desc_0_DATA变量</strong>函数地址赋值给了<strong>__main_block_impl_0</strong>结构体第二个变量<strong>Desc</strong>,也就是结构体中的<strong>Desc</strong>存储了这个block所占空间的大小。</p><p><strong>第3个参数</strong>是 flags默认为0可以不传</p><p>以上为block的定义</p><h4 id="2-调用block内部的代码删除多余修饰之后的代码为"><a href="#2-调用block内部的代码删除多余修饰之后的代码为" class="headerlink" title="2. 调用block内部的代码删除多余修饰之后的代码为"></a>2. 调用block内部的代码删除多余修饰之后的代码为</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">myBlock-&gt;FuncPtr(myBlock);</div></pre></td></tr></table></figure><p><strong>将block本身作为参数传递过去,myBlock内部的代码之所以能够执行,是由于myBlock结构体的第一个成员是impl,myBlock的地址就是impl, myBlock在强转类型之后能够调用impl的FuncPtr,而FuncPtr存储了执行代码的函数的地址</strong></p><h4 id="四、Block与外界变量"><a href="#四、Block与外界变量" class="headerlink" title="四、Block与外界变量"></a>四、Block与外界变量</h4><p>1、block内访问局部变量(auto)</p><p>1.1 默认情况</p><pre><code>int main(int argc, const char * argv[]) {    @autoreleasepool {        int age = 10;        void(^myBlock)(void) = ^{            NSLog(@&quot;age = %d&quot;, age);        };        age = 18;        myBlock();    }    return 0;}</code></pre><p>输出结果:</p><pre><code>age = 10    </code></pre><p>我们通过第三步骤中的clang命令将上面的OC代码转为C++来查看一下block底层实现,</p><p>// 转为c++代码如下</p><pre><code>int main(int argc, const char * argv[]) {    /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool;         int age = 10;        void(*myBlock)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, age));        age = 18;        ((void (*)(__block_impl *))((__block_impl *)myBlock)-&gt;FuncPtr)((__block_impl *)myBlock);    }    return 0;}</code></pre><p>与第三步相比, __main_block_impl_0函数多了一个参数<strong>age</strong>,我们看下结构体__main_block_impl_0的代码</p><pre><code>struct __main_block_impl_0 {  struct __block_impl impl;  struct __main_block_desc_0* Desc;  int age;  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _age, int flags=0) : age(_age) {    impl.isa = &amp;_NSConcreteStackBlock;    impl.Flags = flags;    impl.FuncPtr = fp;    Desc = desc;  }};</code></pre><p>c++的构造函数 __main_block_impl_0 ,关于age的写法是将_age的值赋给age这个成员。</p><p>此时impl的FuncPtr存储的block执行时的代码为</p><pre><code>static void __main_block_func_0(struct __main_block_impl_0 *__cself) {  int age = __cself-&gt;age; // bound by copy  NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_cg_39bx6n8912b59t0sp6dr_rlm0000gn_T_main_85b888_mi_0, age);}</code></pre><p>由<strong>__cself-&gt;age</strong>可知block执行的时候,使用的结构体本身这个age成员。因此在调用block之前对局部变量进行修改并不会影响block内部的值,同时内部的值也是不可修改的。</p><p>对于auto变量,变量是什么类型,block捕获的就是什么类型。如果是object类型,捕获的就是object,如果是基础数据类型,捕捉的就是基础数据类型。</p><p>2.block内访问局部变量(static)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        int age = 10;</div><div class="line">        static int height = 10;</div><div class="line">        void(^myBlock)(void) = ^&#123;</div><div class="line">            NSLog(@&quot;age = %d, height = %d&quot;, age, height);</div><div class="line">        &#125;;</div><div class="line">        age = 18;</div><div class="line">        height = 18;</div><div class="line">        myBlock();</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>将OC代码转换成c++代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">    /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; </div><div class="line">        int age = 10;</div><div class="line">        static int height = 10;</div><div class="line">        void(*myBlock)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, age, &amp;height));</div><div class="line">        age = 18;</div><div class="line">        height = 18;</div><div class="line">        ((void (*)(__block_impl *))((__block_impl *)myBlock)-&gt;FuncPtr)((__block_impl *)myBlock);</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>与age相比, __main_block_impl_0函数多了一个参数<strong>&amp;height</strong>,传入的是<strong>指向height的指针</strong>我们看下结构体__main_block_impl_0的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">struct __main_block_impl_0 &#123;</div><div class="line">  struct __block_impl impl;</div><div class="line">  struct __main_block_desc_0* Desc;</div><div class="line">  int age;</div><div class="line">  int *height;</div><div class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _age, int *_height, int flags=0) : age(_age), height(_height) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>这里__main_block_impl_0函数将<strong>&amp;height(指向height的指针)</strong>赋值给结构体的<strong>int *height</strong>成员 </p><p>此时impl的FuncPtr存储的block执行时的代码为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class="line">  int age = __cself-&gt;age; // bound by copy</div><div class="line">  int *height = __cself-&gt;height; // bound by copy</div><div class="line">  NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_cg_39bx6n8912b59t0sp6dr_rlm0000gn_T_main_93f885_mi_0, age, (*height));</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>NSLog</strong>的<strong>(*height)</strong>参数是指向height的指针,访问height的指针指向的内存地址,所以<strong>NSLog函数</strong>最终取的是height的指针指向的内存地址,此时值已经发生变化,打印的height为变化之后的值。</p><p><strong>注意:</strong></p><p>2.1 跨函数访问,所以需要捕获</p><p>2.2 局部变量会捕获,全局变量不会捕获 (包含self、_cmd等隐性参数)</p><p>2.3 block写在类中, block访问所在的类中的属性(self -&gt; _name)。则会捕获。先找到的self,</p><p>对于局部变量(static),变量是什么类型,block捕获的就是 (<em> + 什么类型)。如果是object类型,捕获的就是</em>object,有两颗 *。</p><p>3、block内访问全局变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">int age = 10;</div><div class="line">static int height = 10;</div><div class="line"></div><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        void(^myBlock)(void) = ^&#123;</div><div class="line">            NSLog(@&quot;age = %d, height = %d&quot;, age, height);</div><div class="line">        &#125;;</div><div class="line">        age = 18;</div><div class="line">        height = 18;</div><div class="line">        myBlock();</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>打印结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">age = 18, height = 18</div></pre></td></tr></table></figure><p>将OC代码转换成c++代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">    /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; </div><div class="line">        void(*myBlock)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</div><div class="line">        age = 18;</div><div class="line">        height = 18;</div><div class="line">        ((void (*)(__block_impl *))((__block_impl *)myBlock)-&gt;FuncPtr)((__block_impl *)myBlock);</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里__main_block_impl_0函数没有传递额外的参数,而且下面的__main_block_impl_0的结构体也没有除impl和Desc额外的参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">struct __main_block_impl_0 &#123;</div><div class="line">  struct __block_impl impl;</div><div class="line">  struct __main_block_desc_0* Desc;</div><div class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>impl的FuncPtr存储的block执行时的代码为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class="line"></div><div class="line">NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_cg_39bx6n8912b59t0sp6dr_rlm0000gn_T_main_cff453_mi_0, age, height);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里是直接访问的全局的age和height。所以block没有捕获全局变量到结构体的内部。</p><p><strong>全局变量所占用的内存只有一份,供所有函数共同调用,在block定义时并未将全局变量的值或者指针传给block变量所指向的结构体,因此在调用block之前对全局变量进行修改会影响到block内部的值,同时内部的值也是可以修改的。<br> 局部变量由于作用域问题,执行block的时候访问的自动变量有可能已经释放掉了,所以捕获定义block时的面值;执行block的时候访问的静态局部变量有可能超出作用域,获取不到这个静态局部变量了,所以捕获定义block时静态变量的指针</strong></p><h4 id="五、Block的类型"><a href="#五、Block的类型" class="headerlink" title="五、Block的类型"></a>五、Block的类型</h4><p>使用isa或者class方法来打印类型所有的block都继承NSBlock,而NSBlock继承NSObject</p><p>其实,block有三种类型:</p><ul><li>全局块 (_NSConcreteGlobalBlock)</li><li>栈块 (_NSConcreteStackBlock)</li><li>堆块 (_NSConcreteMallocBlock)</li></ul><p>这三种block各自的存储域如下图:<br><img src="http://ww1.sinaimg.cn/large/8af26a6dly1fxw0c0jrp9j20yg0ds0ss.jpg" alt=""></p><ul><li>全局块存在于数据段中。</li><li>栈块存在于栈内存中,超出其作用域则马上销毁</li><li>堆块存在于堆内存中,是一个带引用计数的对象,需要自行管理其内存</li></ul><p><strong>_NSConcreteGlobalBlock:</strong></p><p>block没有访问外部变量或访问的不是auto变量,而是staic或者全局变量),(用的比较少)</p><p><strong>_NSConcreteStackBlock</strong></p><p>MRC下block访问auto变量,则为stack类型。(block访问类中的属性也是这种情况);</p><p>原因: 虽然捕获局部变量到block中,但是block超出作用域会自动销毁,即使使用全局的block记录原block(内存地址),原内存地址结构体成员变量已经变成其他内容,再执行的时候使用内存地址去查找并调用会错乱。因此要将这种类型的block放到堆中,由程序员控制内存的释放,注意及时手动销毁。</p><p>还有一点就是由于ARC已经能很好地处理对象的生命周期的管理,这样所有对象都放到堆上管理,对于编译器来实现来说,会比较方便。</p><p><strong>_NSConcreteMallocBlock</strong><br>stack类型的block调用copy,就会升级为malloc类型 (global类型的block调用copy,不会有操作,还是global类型的block; malloc类型的block调用copy,引用计数器+1)</p><p>ARC下block为stack类型的,以下情况系统会自动对该block进行copy操作</p><ul><li>block作为函数返回值的时</li><li>将block赋值给__strong指针时(局部变量也有强指针指着, 没有引用就没有强指针)</li><li>block作为Cocoa Api中方法名含有usingBlock的方法参数时</li><li>block作为GCD Api的方法参数时</li></ul><p>关于以上三种类型,访问基础数据类型或者对象类型结果相同</p><h5 id="block持有外部变量"><a href="#block持有外部变量" class="headerlink" title="block持有外部变量"></a>block持有外部变量</h5><p><strong>MRC下:</strong></p><p>栈空间的block是不会持有外部这个对象变量的, 对stack类型的block进行copy,升级为malloc类型的block,这个block会对外部这个变量进行retain操作。</p><p><strong>ARC下:</strong></p><p>如果block为stack类型, 对外部的对象变量是弱引用;不负责外部变量的生命周期(不关心外部变量本身是强引用还是弱引用)</p><p>如果block为malloc类型,外部变量为__weak修饰的弱引用,则block对外部变量也是弱引用,外部变量为__strong修饰的强引用,则block对外部变量是强引用。</p><p>block主动copy或者系统copy会调用__main_block_copy_0的函数,该函数会调用_Block_object_assign函数,该函数会根据auto变量的修饰符(__strong, __weak, __unsafe_unretained)做出相应的操作,形成强引用还是弱引用。</p><p>block从堆上移除的时候,会调用dispose这个函数(_Block_object_dispose),来释放引用的auto变量(release)</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;Block本质是一个oc对象,它内部也有一个isa指针&lt;/li&gt;
&lt;li&gt;Block的使用分为声明、实现、执行&lt;/li&gt;
&lt;li&gt;Block是封装了函数调用以及函数调用环境的OC对象。函数调用就是block{}中的函数(存储了函数的调用地址),所谓的函数调用环境,就是内部函数调用需要的外界的变量&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>16.项目启动耗时性能优化</title>
    <link href="http://waythought.duoshuo.com/2018/02/13/16.%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8%E8%80%97%E6%97%B6%E6%B5%8B%E8%AF%95/"/>
    <id>http://waythought.duoshuo.com/2018/02/13/16.项目启动耗时测试/</id>
    <published>2018-02-13T06:34:14.000Z</published>
    <updated>2018-11-05T01:43:37.428Z</updated>
    
    <content type="html"><![CDATA[<p>近期项目线下反应app启动时间较长,本着对用户体验的追求,我们希望在业务扩张的同时优化启动时间。</p><h3 id="启动时间"><a href="#启动时间" class="headerlink" title="启动时间"></a>启动时间</h3><p>总时间 = T1(main函数之前的加载时间) + T2(main函数之后的加载时间)</p><p>T1: 加载系统dylib和可执行文件的时间</p><p>T2: 从mian函数到applicationWillFinishLaunching结束的时间,构建第一个界面,并完成渲染展示</p><h4 id="main-函数调用之前的加载过程"><a href="#main-函数调用之前的加载过程" class="headerlink" title="main()函数调用之前的加载过程"></a>main()函数调用之前的加载过程</h4><a id="more"></a><p>App开始启动后,系统首先加载可执行文件(自身App的所有的.o文件的集合),然后加载动态链接库dyld,dyld是一个专门用来加载动态链接库的库。执行从dyld开始,dyld从可执行文件的依赖开始,递归加载所有的依赖动态链接库。</p><p>动态链接库包括: iOS中用到的所有系统的framework, 加载OC runtime方法的libobjc,系统级别的libSystem,例如libdispath(GCD)和libsystem_block(Block)。</p><p>其实无论对于系统的动态链接库还是对于App本身的可执行文件而言,他们都算是image(镜像),而每个App都是以image(镜像)为单位进行加载的,那么image究竟是包括哪些呢?</p><p>#####什么是image</p><p>1.executable可执行文件 比如.o文件</p><p>2.dylib动态链接库framework就是动态链接库和相应资源包含在一起的一个文件夹结构。<br>3.bundle资源文件 只能用dlopen加载,不推荐使用这种方式加载。</p><p>除了我们App本身的可执行文件,系统中所有的framework 比如UIKit、Foundation等都是以动态链接库的方式集成进App中的。</p><h5 id="系统使用动态链接有几点好处"><a href="#系统使用动态链接有几点好处" class="headerlink" title="系统使用动态链接有几点好处:"></a>系统使用动态链接有几点好处:</h5><p>代码共用: 很多程序都动态链接了这些lib,但是它们在内存和磁盘中只有一份。易于维护: 由于被依赖的lib地程序执行时才链接的,所以这些lib很容易做更新,比如libSystem.dylib是libSystem.v1.dylib的替身,那天想升级直接换成libSystem.v2.dylib然后再替换替身就行了。减少可执行文件体积: 相比静态链接,动态链接在编译时不需要打进去,所以可执行文件的体积要小很多。</p><p>如上图所示,不同进程之间共用系统dylib的_TEXT区,但是各自维护对应的_DATA区。</p><p>所有动态链接库和我们App中的静态库.a和所有类文件编译后的.o文件最终都是有dyld(the dynamic link editor),Apple的动态链接器来加载到内存中。每个image都是一个叫做ImageLoader的类来负责加载(–对应),那么ImageLoader又是什么呢?</p><h5 id="什么是ImageLoader"><a href="#什么是ImageLoader" class="headerlink" title="什么是ImageLoader"></a>什么是ImageLoader</h5><p>image表示一个二进制文件(可执行文件或so文件),里面是呗编译过的符号、代码等,所以ImageLoader作用是将这些文件加载进内存,且每一个文件对应一个ImageLoader实例来负责加载。</p><p>两步走: 在程序运行时,它先将动态链接的image递归加载(也就是上面测试栈中一串的递归调用的时刻)。再从可执行文件image递归加载所有符号。</p><p>当然所有这些都发生在我们真正的main函数执行前。</p><h5 id="动态链接库加载的具体流程"><a href="#动态链接库加载的具体流程" class="headerlink" title="动态链接库加载的具体流程"></a>动态链接库加载的具体流程</h5><p>动态链接库的加载步骤具体分为5步:</p><pre><code>1. load dylibs image 读取库镜像文件2. Rebase image3. Blid image4. Objc setup5. initalizers</code></pre><h6 id="load-dylibs-image"><a href="#load-dylibs-image" class="headerlink" title="load dylibs image"></a>load dylibs image</h6><p>在每个动态库的加载过程中,dyld需要:</p><pre><code>1.分析所依赖的动态库2.找到动态库的mach-o文件3.打开文件4.验证文件5.在系统核心注册文件签名6.对动态库的每一个segment调用mmap()</code></pre><p>通常的,一个App需要加载100到400个dylibs,但是其中的系统库被优化,可以很快的加载。针对这一步骤的优化有:</p><pre><code>1.减少非系统库的依赖2.合并非系统库3.使用静态资源,比如把代码加入主程序</code></pre><h6 id="Rebase-Blid"><a href="#Rebase-Blid" class="headerlink" title="Rebase/Blid"></a>Rebase/Blid</h6><p>由于ASLR(address space layout randomization)的存在,可执行文件和动态链接库在虚拟内存中的加载地址每次启动都不固定,所以需要这个2步来修复镜像中的资源指针,来指向正确的地址。rebase修复的是指向当前镜像内部的资源指针;而blid指向的是镜像外部的资源指针。</p><p>rebase步骤先进性,需要把镜像读入内存,并以page为单位<br>进行加密验证,保证不会被篡改,所以这一步的瓶颈在IO。blid在其后进行,由于要查询符号表,来指向跨镜像的资源,加上在rebase阶段,镜像已被读入和加密验证,所以这一步的瓶颈在于CPU计算。</p><p>通过命名行可以查看相关的资源指针:</p><pre><code>xcrun dyldinfo -rebase -bind -lazy_bind myApp.App/myApp</code></pre><p>优化该阶段的关键在于减少__DATA segment中的指针数量。 我们可以优化的点有: </p><pre><code>1.减少Objc类数量,减少selector数量2.减少C++虚函数数量3.转而使用swift stuct (其实本质就是为了减少符号的数量)</code></pre><h6 id="Objc-setup"><a href="#Objc-setup" class="headerlink" title="Objc setup"></a>Objc setup</h6><p>这一步主要工作是:</p><pre><code>1. 注册Objc类(class registration)2. 把category的定义插图方法列表(category resightration)3. 保证每一个selector唯一(selector uniquing)</code></pre><p>由于之前2步骤的优化,这一步实际没有什么可做的。</p><h6 id="initializers"><a href="#initializers" class="headerlink" title="initializers"></a>initializers</h6><p>以上三步属于静态调整(fix-up),都是在修改__DATA segment中的内容,而这里则开始动态调整,开始在堆中堆栈中写入内容。在这里中工作有:</p><pre><code>1.Objc的+load()函数2.C++的构造函数属性函数 形如attribute((constructor)void DoSomeInitializationWork())3.非基本类型的C++静态全局变量的创建(通常是类或结构体)(non-trivial initializer)比如一个全局静态结构体的构建,如果在构造函数中有繁重的工作,那么会拖慢启动速度</code></pre><p>Objc的load函数和C++的静态构造函数采用由底向上的方式执行,来保证每个执行的方法,都可以找到所依赖的动态库。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近期项目线下反应app启动时间较长,本着对用户体验的追求,我们希望在业务扩张的同时优化启动时间。&lt;/p&gt;
&lt;h3 id=&quot;启动时间&quot;&gt;&lt;a href=&quot;#启动时间&quot; class=&quot;headerlink&quot; title=&quot;启动时间&quot;&gt;&lt;/a&gt;启动时间&lt;/h3&gt;&lt;p&gt;总时间 = T1(main函数之前的加载时间) + T2(main函数之后的加载时间)&lt;/p&gt;
&lt;p&gt;T1: 加载系统dylib和可执行文件的时间&lt;/p&gt;
&lt;p&gt;T2: 从mian函数到applicationWillFinishLaunching结束的时间,构建第一个界面,并完成渲染展示&lt;/p&gt;
&lt;h4 id=&quot;main-函数调用之前的加载过程&quot;&gt;&lt;a href=&quot;#main-函数调用之前的加载过程&quot; class=&quot;headerlink&quot; title=&quot;main()函数调用之前的加载过程&quot;&gt;&lt;/a&gt;main()函数调用之前的加载过程&lt;/h4&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>15.Object-C Runtime基本介绍和消息传递</title>
    <link href="http://waythought.duoshuo.com/2017/12/12/15.rutime%E7%B3%BB%E5%88%97-%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92/"/>
    <id>http://waythought.duoshuo.com/2017/12/12/15.rutime系列-消息传递/</id>
    <published>2017-12-12T06:34:14.000Z</published>
    <updated>2019-07-01T06:29:54.514Z</updated>
    
    <content type="html"><![CDATA[<p>本文内容</p><ul><li><a href="#缘由代码">缘由代码</a></li><li><a href="#Runtime基本介绍">Runtime基本介绍</a></li><li><a href="object_getClass(obj">object_getClass(obj)与[obj class]的区别</a>与[obj class]的区别)</li><li><a href="#objc_class结构体及其成员变量定义">objc_class结构体及其成员变量定义</a></li></ul><h3 id="1-objc-msgSend的介绍"><a href="#1-objc-msgSend的介绍" class="headerlink" title="1. objc_msgSend的介绍"></a>1. objc_msgSend的介绍</h3><a id="more"></a><h4 id="来看两段代码"><a href="#来看两段代码" class="headerlink" title="来看两段代码"></a>来看两段代码</h4><h4 id="第一段代码"><a href="#第一段代码" class="headerlink" title="第一段代码"></a>第一段代码</h4><pre><code>#import &quot;KNBFather.h&quot;@interface KNBSon : KNBFather@end</code></pre><p>-</p><pre><code>#import &quot;KNBSon.h&quot;@implementation KNBSon- (instancetype)init {    if (self = [super init]) {        NSLog(@&quot;[self class] --&gt; %@&quot;,[self class]);        NSLog(@&quot;[super class] --&gt; %@&quot;,[super class]);    }    return self;}@end</code></pre><p>实例化KNBSon控制台输出:</p><pre><code>2018-06-20 09:37:15.874949+0800 23- 数组的练习[50857:2147245] [self class] --&gt; KNBSon2018-06-20 09:37:15.875173+0800 23- 数组的练习[50857:2147245] [super class] --&gt; KNBSon</code></pre><p>分析:<br>我们想当然的认为self class是son, super class是father。但是输出的却是一样的,都是son。这是因为oc一切方法的本质都是消息的发送和接受,是动态的。具体的等看过第二节我们再探讨。</p><h4 id="第二段代码"><a href="#第二段代码" class="headerlink" title="第二段代码"></a>第二段代码</h4><pre><code>#import &lt;Foundation/Foundation.h&gt;@interface KNBFather : NSObject@property (nonatomic, copy) NSString *name;@end===================#import &quot;KNBFather.h&quot;@implementation KNBFather- (instancetype)init {    if (self = [super init]) {        self.name = @&quot;&quot;;    }    return self;}- (void)setName:(NSString *)name {    _name = name;    NSLog(@&quot;我是KNBFather,调用我的setName方法了&quot;);}@end</code></pre><p>-</p><pre><code>#import &quot;KNBFather.h&quot;@interface KNBSon : KNBFather@end=========================#import &quot;KNBSon.h&quot;@implementation KNBSon- (instancetype)init {    if (self = [super init]) {           NSLog(@&quot;[self class] --&gt; %@&quot;,[self class]);        NSLog(@&quot;[super class] --&gt; %@&quot;,[super class]);    }    return self;}- (void)setName:(NSString *)name {    NSLog(@&quot;我是KNBSon,调用我的setName方法了&quot;);}@end</code></pre><p>实例化KNBSon控制台输出:</p><pre><code>2018-06-20 09:58:03.162035+0800 23- 数组的练习[51199:2171942] 我是KNBSon,调用我的setName方法了2018-06-20 09:58:03.162231+0800 23- 数组的练习[51199:2171942] [self class] --&gt; KNBSon2018-06-20 09:58:03.162368+0800 23- 数组的练习[51199:2171942] [super class] --&gt; KNBSon</code></pre><p>分析:</p><p>我们在父类KNBFather中的init方法中设置了self.name = @””,是想初始化name的值。</p><p>按道理说,我们在父类使用self.name方法应该调用father的setName方法,在子类KNBSon中使用self.name方法也应该调用KNBSon的setName方法。(以前的理解 self在实例方法中表示的该实例)</p><p>但是实际上我们看到在父类中使用self.name调用的确实是子类的setName方法。</p><p>我们先看下runtime相关的一些知识,再来解释以上问题。</p><h3 id="2-Runtime基本介绍"><a href="#2-Runtime基本介绍" class="headerlink" title="2.Runtime基本介绍"></a>2.Runtime基本介绍</h3><p>Objective-C是基于C加入了面向对象特性和消息转发机制的动态语言。这意味着不仅需要编译器,还需要一个运行系统来执行编译后的代码。而这个运行系统就是runtime,也就是运行时机制,我理解的就是”中间调度系统”,来控制消息发送、消息转发、查看对象信息等等</p><p>给对象发消息可以这样写:</p><pre><code>id returnValue = [someObject messageName: parameter];</code></pre><p>在本例中, someObject叫做”接收者”(receiver),messageName叫做”选择器”(selector).选择器与参数合起来称为”消息”(message)。编译器看到此消息后,将其转换为一条标准的C语言函数调用,所调用的函数仍是消息传递机制中的核心函数,叫做objc_msgSend,其”原型”(prototype)如下:</p><pre><code>id returnValue = objc_msgSend(id self,SEL cmd, ...)</code></pre><p>这是个”参数个数可变的函数”(variadic function),能接受两个或两个以上的参数。第一个参数代表接收者,第二个参数代表”选择器”,后续参数就是消息中的那些参数,其顺序不变。”选择器”指的就是方法的名字。”选择子”与”方法”这两个词经常交替使用。编译器会把刚才那个例子中的消息转换为如下的函数。</p><pre><code>id returnValue = objc_msgSend(someObject,@selector(messageName:),parameter);</code></pre><p>PS: 如果要给超类发送消息,那么交由objc_msgSendSuper:处理。</p><h4 id="id"><a href="#id" class="headerlink" title="id"></a>id</h4><p>id 是一个指向类实例的指针:</p><pre><code>// objc.h中typedef struct objc_object *id;struct objc_object {    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;};</code></pre><h4 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h4><p>objc_msgSend函数的第二个参数类型是SEL,它是selector在Objc中的表示类型,他是个映射到方法的C字符串。</p><h4 id="isa指针"><a href="#isa指针" class="headerlink" title="isa指针"></a>isa指针</h4><p>上面的objc_msgSend实现原理里面提到了isa指针、类。也是我们平时经常接触的两个概念,但是他们内部具体如何实现,却很少深究。</p><p>我们OC中的基本所有的类都是继承于NSObject,NSObject是根类。我们来看下定义</p><pre><code>// NSObject.h定义@interface NSObject &lt;NSObject&gt; {    Class isa  OBJC_ISA_AVAILABILITY;}</code></pre><p>这个Class是什么?</p><pre><code>// objc.h中typedef struct objc_class *Class;// runtime.h中struct objc_class {    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;    Class _Nullable super_class                              OBJC2_UNAVAILABLE; // 父类    const char * _Nonnull name                               OBJC2_UNAVAILABLE; // 类名    long version                                             OBJC2_UNAVAILABLE;    long info                                                OBJC2_UNAVAILABLE;    long instance_size                                       OBJC2_UNAVAILABLE;// 该类的实例变量大小    struct objc_ivar_list * _Nullable ivars                  OBJC2_UNAVAILABLE;// 该类的成员变量链表    struct objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;// 方法定义的链表    struct objc_cache * _Nonnull cache                       OBJC2_UNAVAILABLE;// 方法缓存，对象接到一个消息会根据isa指针查找消息对象，这时会在method Lists中遍历，如果cache了，常用的方法调用时就能够提高调用的效率。    struct objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;// 协议链表} OBJC2_UNAVAILABLE;</code></pre><p>objc_class为什么也有个isa?<br>我们知道isa指针指向的是该对象所属的类,对于实例对象的isa指针,我们知道是指向其所属的类,但是实例对象所属的类的isa指针又指向谁呢?</p><p>类对象本身也是对象,类本身所属类是 元类!!!<br>所以实例对象所属的类的isa指针指向的是该类对象对应的元类。</p><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><h4 id="1-实例对象-instance对象"><a href="#1-实例对象-instance对象" class="headerlink" title="1.实例对象(instance对象)"></a>1.实例对象(instance对象)</h4><p>instance对象就是通过类alloc出来的对象,每次调用alloc都会产生新的instance对象。instance对象在内存中存储的信息包括 <strong>isa指针</strong>、<strong>其他成员变量的值</strong></p><h4 id="2-类对象-class对象"><a href="#2-类对象-class对象" class="headerlink" title="2.类对象(class对象)"></a>2.类对象(class对象)</h4><p>类对象是由编译器创建的,每个类在内存中有且只有一个class对象。这个类对象中存储了关于这个实例对象所属的类的定义的包括属性信息(名字)、对象方法、遵守的协议信息、成员变量信息等。</p><p>因此,类对象能访问所有关于这个类的信息,利用这些信息可以产生一个新的实例,但是类对象不能访问任何实例对象的内容。当调用一个类方法的时候,例如[NSObject alloc]的时候,实际上是发送了一个消息给他的类对象。</p><h4 id="3-元类对象-meta-class对象"><a href="#3-元类对象-meta-class对象" class="headerlink" title="3.元类对象(meta-class对象)"></a>3.元类对象(meta-class对象)</h4><p>meta-class对象和class对象的内存结构是一样的,但是用途是不一样的,在内存中存储的信息主要包括isa指针、superclass指针、类的类方法信息等</p><p>元类描述了一个类对象,就像类对象描述了普通的实例变量一样。不同的是元类的方法列表是类方法的集合,由类对象的选择器来响应。当向一个类发送消息时,objc_msgSend会通过类对象的isa指针定位到元类,并检查元类的方法列表来决定调用哪个方法。</p><p>整个指针链就是类的super_class指向其父类,而元类的super_class则指向其父类的元类。元类的super class链与类的super_class链平行,所以类方法的继承于实例方法的继承也是并行的。而根元类的super_class指向根元类。</p><p>当一个消息发送给任何一个对象的时候,方法检测都是从对象的isa指针开始依次去本类、父类方法列表中寻找。实例方法在类中定义,类方法在元类和根类中定义。 (根类的元类就是根类自己)。</p><p><img src="http://ww1.sinaimg.cn/large/8af26a6dly1fxw0036yjrj20iw0j00sz.jpg" alt=""></p><p>objc_msgSend函数会依据接收者与选择子的类型来调用适当的方法。为了完成此操作,该方法需要在接收者所属的类中搜寻其”方法列表”(list of methods),如果能找到与选择子名称相符的方法,就跳至其实现代码。若是找不到,那就沿着继承体系继续向上查找,等找到合适的方法之后再跳转。如果最终还是找不到相符的方法,那就执行”消息转发”(message forwarding)操作。</p><p>objc_msgSend会匹配结果缓存在”快速映射表”(fast map)里面,每个类都有这样一块缓存,若是稍后还向该类发送与选择子相同的消息,那么执行起来的就会快了。</p><h5 id="object-getClass-obj-与-obj-class-的区别"><a href="#object-getClass-obj-与-obj-class-的区别" class="headerlink" title="object_getClass(obj)与[obj class]的区别"></a>object_getClass(obj)与[obj class]的区别</h5><ol><li>object_getClass(obj)返回的是obj中的isa指针;</li><li>[obj class]分为两种情况:<ul><li>当obj为实例对象时,[obj class]调用的是实例方法: -(Class)class,返回的是isa指针;</li><li>当obj为类对象(包括元类和根类)时,调用的是类方法: +(Class)class,返回的结果为其本身。</li></ul></li><li><p>-(Class)class的实现如下:</p><pre><code>-(Class)class {    return object_getClass(self);}</code></pre></li></ol><h4 id="第一段代码解析"><a href="#第一段代码解析" class="headerlink" title="第一段代码解析"></a>第一段代码解析</h4><p>来让我们看看第一段代码为什么[self class]和[super class]都是输出的是KNSon。</p><h5 id="self-class"><a href="#self-class" class="headerlink" title="[self class]"></a>[self class]</h5><p>根据上面的知识,我们知道[self class]最终会转换为如下形式:</p><pre><code>id objc_msgSend(son的实例对象self, @selector(class), ...)</code></pre><p>消息的接受者是KNBSon的实例对象的self,然后调用他的class方法,它自己没有实现该方法,最终在NSObject中找到该方法的实现,然后返self的isa指针,此时self是KNBSon类的实例对象,那么isa指针也就是指向KNBSon类,所以[self class]返回的是 KNBSon。</p><h5 id="super-class"><a href="#super-class" class="headerlink" title="[super class]"></a>[super class]</h5><p>而当使用[super class]调用时,会使用objc_msgSendSuper函数。看下objc_msgSendSuper的函数定义:</p><pre><code>id objc_msgSendSuper(struct objc_super *super,  @selector(class), ...)</code></pre><p>第一个参数是个objc_super的结构体,第二个参数还是类似上面的类方法的selector,先看objc_super这个结构体是什么东西</p><pre><code>struct objc_super {   id receiver;   Class superClass;};</code></pre><p>此处上面的结构体转换为如下样式:</p><pre><code>struct objc_super {       KNBSon的实例对象self;       KNBFather;};</code></pre><p>那么调用[super class]后的内部流程如下:</p><ol><li>当使用[super class]时,这时要转化成objc_msgSendSuper的方法。</li><li>想构造objc_super的结构体,第一个成员变量就是self,第二个成员变量就是KNBFather,然后要找class这个selector,先去superClass也就是KNBFather中去找,没有,然后去KNBFather的父类中去找,结果还是在NSObject中找到了。</li><li>然后内部使用函数objc_msgSend(objc_super -&gt; receiver, @selector(class))去掉用,此时已经和我们用[self class]调用相同了,因为这里的receiver还是KNBSon的实例对象self,所以这里返回的还是实例对象self的isa指针(指向他的类对象),也就是KNBSon。</li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>很多人会想当然的认为”super和self类似,应该是指向父类的指针”。这其实是一个误区。</p><p>其实super是一个关键字,他的本质是一个编译器标志符,和self是指向同一个消息接受者!他俩的不同点在于: super会告诉编译器,调用class这个方法(或者其他方法)时,要去父类的方法去找,而不是本类里的。</p><p>所以当使用self调用的方法时,会从当前类的方法列表中开始找,如果没有,就从父类中再找;而当使用super时,则直接从父类的方法列表中开始找,不在从当前的类的方法列表中寻找了。<br>-</p><h4 id="第二段代码解析"><a href="#第二段代码解析" class="headerlink" title="第二段代码解析"></a>第二段代码解析</h4><p>第二段代码在KNBFather里面使用self.name = @””调用的是子类的setName方法<br>我们来看下子类实例化的代码</p><pre><code>- (instancetype)init {    if (self = [super init]) {        NSLog(@&quot;[self class] --&gt; %@&quot;,[self class]);        NSLog(@&quot;[super class] --&gt; %@&quot;,[super class]);    }    return self;}</code></pre><p>当调用[super init]的时候,消息的接受者依然是KNBSon的实例对象, 只是去查父类中调用init方法去了。在父类执行[self setName]的时候,接受消息的是KNBSon的实例对象,去查询的是KNBSon的方法列表,调用的是KNBSon的 setName方法。</p><p>所以我们要注意,如果子类重写了父类的方法,那么不管在子类还是在父类调用发方法,如果是子类调用,最终被执行的方法是子类的方法。</p><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>我们探讨了一些runtime的特性和机制,由此可见runtime的一些本质,但是也只是管中窥豹,做抛砖引玉之用,欢迎大家探讨。</p><p>参考资料:<br>    <a href="https://www.jianshu.com/p/7b8d834042e4" target="_blank" rel="external">https://www.jianshu.com/p/7b8d834042e4</a><br>    <a href="https://www.jianshu.com/p/1c52810f23d2" target="_blank" rel="external">https://www.jianshu.com/p/1c52810f23d2</a><br>    <a href="https://www.jianshu.com/p/d774ad33d165" target="_blank" rel="external">https://www.jianshu.com/p/d774ad33d165</a><br>    <a href="https://juejin.im/post/57a9516e7db2a2005aba4809" target="_blank" rel="external">https://juejin.im/post/57a9516e7db2a2005aba4809</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文内容&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#缘由代码&quot;&gt;缘由代码&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#Runtime基本介绍&quot;&gt;Runtime基本介绍&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;object_getClass(obj&quot;&gt;object_getClass(obj)与[obj class]的区别&lt;/a&gt;与[obj class]的区别)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#objc_class结构体及其成员变量定义&quot;&gt;objc_class结构体及其成员变量定义&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1-objc-msgSend的介绍&quot;&gt;&lt;a href=&quot;#1-objc-msgSend的介绍&quot; class=&quot;headerlink&quot; title=&quot;1. objc_msgSend的介绍&quot;&gt;&lt;/a&gt;1. objc_msgSend的介绍&lt;/h3&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>14.友盟 crash log 错误分析工具</title>
    <link href="http://waythought.duoshuo.com/2017/10/02/14.%E5%8F%8B%E7%9B%9F%20crash%20log%20%E9%94%99%E8%AF%AF%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/"/>
    <id>http://waythought.duoshuo.com/2017/10/02/14.友盟 crash log 错误分析工具/</id>
    <published>2017-10-02T01:34:14.000Z</published>
    <updated>2018-12-05T09:24:01.052Z</updated>
    
    <content type="html"><![CDATA[<p>开发完成,闲置时间对已上线版本进行crash log错误分析,crash展示文件除了帧调用就是内存地址,的确不好看明白 <img src="http://ww1.sinaimg.cn/large/8af26a6dly1fxvzq8sq7lj21f413in9b.jpg" alt=""></p><a id="more"></a><p>我们用友盟的错误分析工具umcrashtool<br><a href="下载地址:">http://dev.umeng.com/files/download/umcrashtool.zip</a></p><p>第一步:找到上线打包的xcarchive 保证存在就好<br><img src="http://ww1.sinaimg.cn/large/8af26a6dly1fxvzq7ggytj21lu17gdna.jpg" alt=""><br>第二步:去友盟错误统计的网页,下载对应的csv文件<br><img src="http://ww1.sinaimg.cn/large/8af26a6dly1fxvzq8vdo9j21m0126dsa.jpg" alt=""><br>第三步:将下载好的错误分析工具和csv文件放到同一目录下<br><img src="http://ww1.sinaimg.cn/large/8af26a6dly1fxvzq7mbgmj20n40kyacl.jpg" alt=""><br>第四步: 打开终端输入</p><pre><code>./umcrashtool csv路径</code></pre><p>显示结果:<br><img src="http://ww1.sinaimg.cn/large/8af26a6dly1fxvzq90jcgj20ye0ziwxm.jpg" alt=""></p><p>从上到下,是调用堆栈,可以清晰的看出来报错的地方</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开发完成,闲置时间对已上线版本进行crash log错误分析,crash展示文件除了帧调用就是内存地址,的确不好看明白 &lt;img src=&quot;http://ww1.sinaimg.cn/large/8af26a6dly1fxvzq8sq7lj21f413in9b.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>13.字符串特辑(转载)</title>
    <link href="http://waythought.duoshuo.com/2017/09/20/13.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%89%B9%E8%BE%91/"/>
    <id>http://waythought.duoshuo.com/2017/09/20/13.字符串特辑/</id>
    <published>2017-09-20T01:34:14.000Z</published>
    <updated>2018-08-25T03:20:20.176Z</updated>
    
    <content type="html"><![CDATA[<p>OC中的NSString不伦是在编译时还是在运行时都做了很多的优化,和普通的对象不同,它是一个比较复杂的存在。</p><p>首先我们做下测试:</p><a id="more"></a><p>定义宏方便打印:</p><pre><code>#if __has_feature(objc_arc)#define Obj_RetainCount(obj) \CFGetRetainCount((__bridge CFTypeRef)(obj))#else#define Obj_RetainCount(obj) \DebugLog(@&quot;%lu&quot;,[obj retainCount]);#endif#define KNLog(_var) NSLog(@&quot;%@ : class = %@ p = %p retainCount = %d&quot;,@#_var,NSStringFromClass([_var class]),_var,Obj_RetainCount(_var));</code></pre><p>测试代码:</p><pre><code>NSString *a = @&quot;str&quot;;NSString *b = [[NSString alloc]init];NSString *c = [[NSString alloc]initWithString:@&quot;str&quot;];NSString *d = [[NSString alloc]initWithFormat:@&quot;str&quot;];NSString *e = [NSString stringWithFormat:@&quot;str&quot;];NSString *f = [NSString stringWithFormat:@&quot;123456789&quot;];NSString *g = [NSString stringWithFormat:@&quot;1234567890&quot;];KNLog(a);KNLog(b);KNLog(c);KNLog(d);KNLog(e);KNLog(f);KNLog(g);</code></pre><p>打印结果:</p><pre><code>a : class = __NSCFConstantString p = 0x104038110 retainCount = -1b : class = __NSCFConstantString p = 0x1af4d3c28 retainCount = -1c : class = __NSCFConstantString p = 0x104038110 retainCount = -1d : class = NSTaggedPointerString p = 0xa000000007274733 retainCount = -1e : class = NSTaggedPointerString p = 0xa000000007274733 retainCount = -1f : class = NSTaggedPointerString p = 0xa1ea1f72bb30ab19 retainCount = -1g : class = __NSCFString p = 0x1c40366e0 retainCount = 2</code></pre><p>可以看到,不同的方式创建的字符串额立新不同,引用计数也有所区别,并不是我们常规理解的对象初始化后引用计数为1.创建的字符串有3种类型</p><ul><li>__NSCFConstantString</li><li>__NSCFString</li><li>NSTaggedPointerString</li></ul><p>造成这种结果的原因是由于OC对字符串做的内存优化。</p><h5 id="NSCFConstantString"><a href="#NSCFConstantString" class="headerlink" title="__NSCFConstantString"></a>__NSCFConstantString</h5><p>对变量类型名上就可以看出,这种类型的字符串是常亮字符串。该类型的字符串以字面量的方式创建,保存在字符串常亮区,是在编译时创建的。例如:</p><pre><code>NSString *a = @&quot;good afternoon!&quot;;NSString *b = [[NSString alloc]initWithString:@&quot;good afternoon!&quot;];NSString *c = [[NSString alloc]initWithFormat:a];</code></pre><p>对于initWithString实例方法以及stringWithString类方法,编译器会给出redundant警告,原因是该方法创建字符串等同于直接复制字符串字面量。    </p><ul><li>当创建的字符串变量值在常亮区已经存在时,会指向那个字符串,这是编译器做的优化。</li><li>由于是常量,因此其内存管理并不同于对象的内存管理,引用计数用用整形格式打出来始终为-1。</li></ul><h5 id="NSCFString"><a href="#NSCFString" class="headerlink" title="__NSCFString"></a>__NSCFString</h5><p>__NSCFString表示对象类型的字符串,在运行时创建,保存在堆区,初始引用计数为1,其内存管理方式就是对象的内存管理方式。该种类型字符串通过format方式创建,并且字符串内容仅由数字、字母和常规ASCII字符构成,且其长度不能太小,否则创建的是NSTaggedPointerString类型。</p><pre><code>NSString *d = [[NSString alloc]initWithFormat:@&quot;我是对象&quot;];//__NSCFStringNSString *e = [NSString stringWithFormat:@&quot;1234567890&quot;]; //__NSCFString</code></pre><h5 id="NSTaggedPointerString"><a href="#NSTaggedPointerString" class="headerlink" title="NSTaggedPointerString"></a>NSTaggedPointerString</h5><p>NSTaggedPointerString类型的字符串是对__NSCFString类型的一种优化,在运行时创建字符串时,会对字符串内容及长度作判断,若内容由ASCII字符构成且长度较小,这时候创建的字符串类型就是NSTaggedPointerString（标签指针字符串),字符串直接存储在指针的内容中。NSTaggedPointerString类型中字符串引用计数同样为-1,不适用对象的内存管理策略。</p><pre><code>NSString *e = [NSString stringWithFormat:@&quot;123456789&quot;]; //NSTaggedPointerString </code></pre><p>而上面以同样的方式创建的1234567890字符串却为 __NSCFString 类型。</p><h4 id="探究NSDictionary-NSArray-NSValue-NSNumber是否也做了优化"><a href="#探究NSDictionary-NSArray-NSValue-NSNumber是否也做了优化" class="headerlink" title="探究NSDictionary NSArray NSValue NSNumber是否也做了优化"></a>探究NSDictionary NSArray NSValue NSNumber是否也做了优化</h4><p>#####NSDictionary测试代码如下：</p><pre><code>NSDictionary *d1 = @{@&quot;aa&quot;:@&quot;11&quot;,@&quot;bb&quot;:@&quot;22&quot;};NSDictionary *d2 = [[NSDictionary alloc]init];NSDictionary *d3 = [[NSDictionary alloc]initWithObjectsAndKeys:@&quot;a&quot;,@&quot;1&quot;, nil];NSDictionary *d4 = [NSDictionary dictionaryWithObjectsAndKeys:@&quot;b&quot;,@&quot;2&quot;, nil];KNLog(d1);KNLog(d2);KNLog(d3);KNLog(d4);</code></pre><p>打印结果:</p><pre><code>d1 : class = __NSDictionaryI p = 0x7fddbad1e9d0 retainCount = 1d2 : class = __NSDictionary0 p = 0x7fddbae00dd0 retainCount = -1d3 : class = __NSDictionaryI p = 0x7fddbad044f0 retainCount = 1d4 : class = __NSDictionaryI p = 0x7fddbadbd8a0 retainCount = 2</code></pre><p>#####NSArray测试代码如下：</p><pre><code>NSDictionary *d1 = @{@&quot;aa&quot;:@&quot;11&quot;,@&quot;bb&quot;:@&quot;22&quot;};NSDictionary *d2 = [[NSDictionary alloc]init];NSDictionary *d3 = [[NSDictionary alloc]initWithObjectsAndKeys:@&quot;a&quot;,@&quot;1&quot;, nil];NSDictionary *d4 = [NSDictionary dictionaryWithObjectsAndKeys:@&quot;b&quot;,@&quot;2&quot;, nil];KNLog(d1);KNLog(d2);KNLog(d3);KNLog(d4);</code></pre><p>打印结果:</p><pre><code>d1 : class = __NSDictionaryI p = 0x7fddbad1e9d0 retainCount = 1d2 : class = __NSDictionary0 p = 0x7fddbae00dd0 retainCount = -1d3 : class = __NSDictionaryI p = 0x7fddbad044f0 retainCount = 1d4 : class = __NSDictionaryI p = 0x7fddbadbd8a0 retainCount = 2</code></pre><h5 id="NSArray测试代码如下："><a href="#NSArray测试代码如下：" class="headerlink" title="NSArray测试代码如下："></a>NSArray测试代码如下：</h5><pre><code>NSArray *a1 = @[@&quot;1&quot;,@&quot;2&quot;];NSArray *a2 = [[NSArray alloc]init];NSArray *a3 = [[NSArray alloc]initWithObjects:@&quot;1&quot;, nil];NSArray *a4 = [[NSArray alloc]initWithArray:@[@&quot;a&quot;,@&quot;b&quot;]];NSArray *a5 = [NSArray arrayWithObjects:@&quot;m&quot;,@&quot;n&quot;, nil];KNLog(a1);KNLog(a2);KNLog(a3);KNLog(a4);KNLog(a5);</code></pre><p>打印结果:</p><pre><code>a1 : class = __NSArrayI p = 0x7fddbae16970 retainCount = 1a2 : class = __NSArray0 p = 0x7fddbae00ce0 retainCount = -1a3 : class = __NSArrayI p = 0x7fddbae23ea0 retainCount = 1a4 : class = __NSArrayI p = 0x7fddbae0ab30 retainCount = 1a5 : class = __NSArrayI p = 0x7fddbae0ab10 retainCount = 2</code></pre><h5 id="NSValue测试代码如下："><a href="#NSValue测试代码如下：" class="headerlink" title="NSValue测试代码如下："></a>NSValue测试代码如下：</h5><pre><code>NSValue *v1 = [NSValue valueWithCGPoint:CGPointMake(10, 10)];CGPoint point = CGPointMake(20, 20);NSValue *v2 = [[NSValue alloc]initWithBytes:&amp;point objCType:@encode(CGPoint)];KNLog(v1);KNLog(v2);</code></pre><p>打印结果:</p><pre><code>v1 : class = NSConcreteValue p = 0x7fddbae153e0 retainCount = 2v2 : class = NSConcreteValue p = 0x7fddbae21fa0 retainCount = 1</code></pre><h5 id="NSNumber测试代码如下："><a href="#NSNumber测试代码如下：" class="headerlink" title="NSNumber测试代码如下："></a>NSNumber测试代码如下：</h5><pre><code>NSNumber *n1 = [NSNumber numberWithInt:123456789];NSNumber *n2 = [NSNumber numberWithInt:1234567890];int i = 10;NSNumber *n3 = [[NSNumber alloc]initWithBytes:&amp;i objCType:@encode(int)];KNLog(n1);KNLog(n2);KNLog(n3);</code></pre><p>打印结果:</p><pre><code>n1 : class = __NSCFNumber p = 0xb000000075bcd152 retainCount = -1n2 : class = __NSCFNumber p = 0xb000000499602d22 retainCount = -1n3 : class = NSConcreteValue p = 0x7fddbadb4df0 retainCount = 1</code></pre><p>结论:</p><ul><li>对于NSDictionary、NSArray以及NSValue实例,除了空字典和空字符串,其余实例都遵循对象的内存管理策略。</li><li>NSNumber类创建的对于普通数据类型的封装的实例,其内存管理同样做了优化,不遵循对象的内存管理策略。<br>另外可以看到,有些新创建的对象引用计数为1,有些为2.这是因为用类方法创建的实例,系统自动将其置入自动释放池。</li></ul><h5 id="mutable-variable"><a href="#mutable-variable" class="headerlink" title="mutable variable"></a>mutable variable</h5><p>测试代码如下:</p><pre><code>//NSMutableStringNSMutableString *ms1 = [[NSMutableString alloc]init];NSMutableString *ms2 = [[NSMutableString alloc]initWithString:@&quot;str&quot;];NSMutableString *ms3 = [[NSMutableString alloc]initWithFormat:@&quot;str&quot;];NSMutableString *ms4 = [NSMutableString stringWithFormat:@&quot;str&quot;];NSMutableString *ms5 = [NSMutableString stringWithFormat:@&quot;123456789&quot;];NSMutableString *ms6 = [NSMutableString stringWithFormat:@&quot;1234567890&quot;];XFLog(ms1);XFLog(ms2);XFLog(ms3);XFLog(ms4);XFLog(ms5);XFLog(ms6);//NSMutableDictionaryNSMutableDictionary *md1 = [[NSMutableDictionary alloc]init];NSMutableDictionary *md2 = [[NSMutableDictionary alloc]initWithObjectsAndKeys:@&quot;a&quot;,@&quot;1&quot;, nil];NSMutableDictionary *md3 = [NSMutableDictionary dictionaryWithObjectsAndKeys:@&quot;b&quot;,@&quot;2&quot;, nil];XFLog(md1);XFLog(md2);XFLog(md3);//NSMutableArrayNSMutableArray *ma1 = [[NSMutableArray alloc]init];NSMutableArray *ma2 = [[NSMutableArray alloc]initWithObjects:@&quot;1&quot;, nil];NSMutableArray *ma3 = [[NSMutableArray alloc]initWithArray:@[@&quot;a&quot;,@&quot;b&quot;]];NSMutableArray *ma4 = [NSMutableArray arrayWithObjects:@&quot;m&quot;,@&quot;n&quot;, nil];XFLog(ma1);XFLog(ma2);XFLog(ma3);XFLog(ma4); </code></pre><p>测试结果如下:</p><pre><code>ms1 : class = __NSCFString p = 0x7fd31070e6b0 retainCount = 1ms2 : class = __NSCFString p = 0x7fd310716d40 retainCount = 1ms3 : class = __NSCFString p = 0x7fd310719910 retainCount = 1ms4 : class = __NSCFString p = 0x7fd31071b610 retainCount = 2ms5 : class = __NSCFString p = 0x7fd31071bc40 retainCount = 2ms6 : class = __NSCFString p = 0x7fd310715350 retainCount = 2md1 : class = __NSDictionaryM p = 0x7fd31071be00 retainCount = 1md2 : class = __NSDictionaryM p = 0x7fd31070c270 retainCount = 1md3 : class = __NSDictionaryM p = 0x7fd310717960 retainCount = 2ma1 : class = __NSArrayM p = 0x7fd31060d860 retainCount = 1ma2 : class = __NSArrayM p = 0x7fd310605730 retainCount = 1ma3 : class = __NSArrayM p = 0x7fd310607f80 retainCount = 1ma4 : class = __NSArrayM p = 0x7fd310606dc0 retainCount = 2</code></pre><p>结论:<br>    可变变量实例均以对象的形式保存在堆中。</p><font color="#0099ff" size="face=" 黑体""="">color=#0099ff size=12 face=”黑体”</font>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;OC中的NSString不伦是在编译时还是在运行时都做了很多的优化,和普通的对象不同,它是一个比较复杂的存在。&lt;/p&gt;
&lt;p&gt;首先我们做下测试:&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>12.Effective Objective-C 2.0读书笔记</title>
    <link href="http://waythought.duoshuo.com/2017/08/17/12.Effective%20Objective-C%202.0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://waythought.duoshuo.com/2017/08/17/12.Effective Objective-C 2.0读书笔记/</id>
    <published>2017-08-17T07:34:14.000Z</published>
    <updated>2019-06-27T08:20:25.563Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第1条-动态绑定"><a href="#第1条-动态绑定" class="headerlink" title="第1条: 动态绑定"></a>第1条: 动态绑定</h3><p>// Messaging (Objective-C)</p><p>Object *obj = [Object new];</p><p>[obj performWith:parameterl and: parameterl2];</p><p>关键区别在于: 使用消息结构的语言,其运行时所应执行的代码由运行环境来决定;而使用函数调用的语言,则有编辑器决定。如果范例代码中调用的函数是多态的,那么在运行时就要按照 <strong>虚方法表: </strong>来查出到底应该执行哪个函数实现。而采取消息结构的语言,不论是否多态,总是在运行时才回去查找所要执行的方法。实际上,编辑器甚至不关心接受消息的对象是何种类型。接受消息的对象问题也要在运行时处理,其过程叫做”动态绑定”。</p><h3 id="第23条-通过代理与数据源进行对象间通信"><a href="#第23条-通过代理与数据源进行对象间通信" class="headerlink" title="第23条: 通过代理与数据源进行对象间通信"></a>第23条: 通过代理与数据源进行对象间通信</h3><p>如果给委托对象发送消息,那么需要提前判断该代理对象<strong>是否存在</strong>并且判断该代理<strong>是否实现了该方法</strong>。</p><pre><code>if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(hook_tableViewManagerShowBigEmpty:)]) {    [self.delegate hook_tableViewManagerShowBigEmpty:needShowBigEmpty];}</code></pre><p>对于代理模式,在iOS中分为两种:</p><ul><li>普通的代理模式: 信息从类流向代理者</li><li>信息源模式: 信息从数据源流向类</li></ul><p><img src="http://ww1.sinaimg.cn/large/8af26a6dly1g4fsa9cr0fj20f309gglm.jpg" alt=""></p><blockquote><p>类似于UITableView告诉他的代理(delegate)”我被点击了”; 而它的数据源(dataSource)告诉UITableView”你有这些数据”。这两个信息的传递方向是反的</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;第1条-动态绑定&quot;&gt;&lt;a href=&quot;#第1条-动态绑定&quot; class=&quot;headerlink&quot; title=&quot;第1条: 动态绑定&quot;&gt;&lt;/a&gt;第1条: 动态绑定&lt;/h3&gt;&lt;p&gt;// Messaging (Objective-C)&lt;/p&gt;
&lt;p&gt;Object *ob
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>11.关于iOS9.0 ~ iOS9.3 从App Store下载出现不规则奔溃问题</title>
    <link href="http://waythought.duoshuo.com/2017/07/15/11.%E5%85%B3%E4%BA%8EiOS9.0~9.3%20%E4%BB%8EApp%20Store%E4%B8%8B%E8%BD%BD%E5%87%BA%E7%8E%B0%E4%B8%8D%E8%A7%84%E5%88%99%E5%A5%94%E6%BA%83%E9%97%AE%E9%A2%98/"/>
    <id>http://waythought.duoshuo.com/2017/07/15/11.关于iOS9.0~9.3 从App Store下载出现不规则奔溃问题/</id>
    <published>2017-07-15T08:34:14.000Z</published>
    <updated>2019-11-01T15:23:58.090Z</updated>
    
    <content type="html"><![CDATA[<p>这次上线遇到了一个大坑,版本发布上线后,同事的iOS9.1系统的6sp手机运行闪退,而这个手机真机直接跑、扫描二维码安装ipa包,都是没有问题的。</p><a id="more"></a><p>去友盟错误列表反馈报以下错误提示:</p><pre><code>Application received signal SIGTRAP</code></pre><p>最终定位到了P3资源文件的问题上了,图片资源文件里有16位图,显示模式为P3</p><h4 id="⚠️⚠️⚠️"><a href="#⚠️⚠️⚠️" class="headerlink" title="⚠️⚠️⚠️"></a>⚠️⚠️⚠️</h4><p><strong>原理:</strong><br>如果你的app需要支持广色域显示的话，那你必须得把target设置成iOS 9.3+，相反，如果你的app不需要支持广色域且你想兼容 iOS 9.3 之前的项目，你就得把资源文件所有的16位的或者显示模式为’P3’图片全都替换成8位模式的SRGB颜色的图片</p><ul><li><p>替换16位模式的SRGB颜色的图片步骤:</p><p>  1.打一个ipa包,将该文件后缀名.ipa为.zip</p><p>  2.解压该.zip文件,解压后的目录里面会有一个Payload文件夹</p><p>  3.打开终端切换到Payload文件下的.app路径</p><pre><code>cd ~/路径/appname.app</code></pre><p>  4.用find命名定位到Asset.car文件</p><pre><code>find . -name &apos;Assets.car&apos;</code></pre><p>  5.使用使用 assetutil 命令导出图片的信息存储到Assets.json文件中</p></li></ul><pre><code>    sudo xcrun --sdk iphoneos assetutil --info ./Assets.car &gt; /tmp/Assets.json6.使用以下命令 打开上步生成的/tmp/Assets.json    open /tmp/Assets.json查找“DisplayGamut&quot;: “P3”,看到&quot;BitsPerComponent&quot; : 16,这个就是要被替换的图片</code></pre><ul><li><p>修改图片:</p><p>  使用ColorSync实用工具将这个描述文件修改下<br>  <img src="http://ww1.sinaimg.cn/large/8af26a6dly1fxvzn1k303j20s60lm0yz.jpg" alt=""><br>  指派它的描述文件为sRGB IEC61966-2.1，保存.</p><p>  <img src="http://ww1.sinaimg.cn/large/8af26a6dly1fxvzn1buhvj212802e756.jpg" alt=""></p><p>  <img src="http://ww1.sinaimg.cn/large/8af26a6dly1fxvzn1a7pzj20fe050gm6.jpg" alt=""><br>  至此我们的问题完美解决。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次上线遇到了一个大坑,版本发布上线后,同事的iOS9.1系统的6sp手机运行闪退,而这个手机真机直接跑、扫描二维码安装ipa包,都是没有问题的。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>10- 上传App Store 报错 ERROR ITMS-90087:&quot;Unsupported Architectures 解决办法</title>
    <link href="http://waythought.duoshuo.com/2017/06/15/10.%E4%B8%8A%E4%BC%A0App%20Store%20%E6%8A%A5%E9%94%99%20ERROR%20ITMS-90087-%20%22Unsupported%20Architectures%20%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%20/"/>
    <id>http://waythought.duoshuo.com/2017/06/15/10.上传App Store 报错 ERROR ITMS-90087- &quot;Unsupported Architectures 解决办法 /</id>
    <published>2017-06-15T06:45:43.000Z</published>
    <updated>2018-11-16T10:38:44.879Z</updated>
    
    <content type="html"><![CDATA[<h3 id="说明"><a href="#说明" class="headerlink" title="说明:"></a>说明:</h3><p>有些第三方提供商为了方便开发者使用,经常把i386 x86_64 armv7 arm64 等几个平台合并到一起,但是上传App Store的时候需要将i386 x86_64两个平台删除后,才能正常审核。</p><h3 id="一、几个重要概念"><a href="#一、几个重要概念" class="headerlink" title="一、几个重要概念"></a>一、几个重要概念</h3><ol><li>ARM:ARM处理器,特点是体积小、低功耗、低成本、高性能,所以几乎所有手机处理器都基于ARM,在嵌入式系统中应用广泛。</li><li>ARM处理器指令集: armv6 | armv7 | armv7s | arm64都是ARM处理器的指令集,这些指令集都是向下兼容的,例如armv7指令集兼容armv6,只是使用armv6的时候无法发挥出其性能,无法使用armv7的新特性,从而会导致程序执行效率没有那么高。<br>i386 | x86_64是Mac处理器的指令集,i386是针对intel通用微处理器32架构的(虚拟机: iPhone4s iPhone5)。x86_64是针对x86架构的64位处理器(虚拟机: iPhone5S iPhone6 iPhone6S iPhone7 iPhone8 iPhoneX)。</li><li><p>目前iOS移动设备指令集</p><a id="more"></a><p> arm64：真机64位处理器需要本架构 iPhone5S(以及以上)｜ iPad Air｜ iPad mini2(iPad mini with Retina Display)</p><p> armv7s：真机32位处理器需要本架构 iPhone5｜iPhone5C｜iPad4(iPad with Retina Display)</p><p> armv7：真机32位处理器需要本架构 iPhone3GS｜iPhone4｜iPhone4S｜iPad｜iPad2｜iPad3(The New iPad)｜iPad mini｜iPod Touch 3G｜iPod Touch4</p><p> armv6 设备： iPhone, iPhone2, iPhone3G, 第一代、第二代 iPod Touch（一般不需要去支持）</p></li><li><p>Xcode中指令集相关选项(Build Setting中)</p><p> (1) Architectures<br>Space-separated list of identifiers. Specifies the architectures (ABIs, processor models) to which the binary is targeted. When this build setting specifies more than one architecture, the generated binary may contain object code for each of the specified architectures. </p><p> 指定工程被编译成可支持哪些指令集类型，而支持的指令集越多，就会编译出包含多个指令集代码的数据包，对应生成二进制包就越大，也就是ipa包会变大。</p><p> (2) Valid Architectures<br>Space-separated list of identifiers. Specifies the architectures for which the binary may be built. During the build, this list is intersected with the value of ARCHS build setting; the resulting list specifies the architectures the binary can run on. If the resulting architecture list is empty, the target generates no binary. </p><p> 限制可能被支持的指令集的范围，也就是Xcode编译出来的二进制包类型最终从这些类型产生，而编译出哪种指令集的包，将由Architectures与Valid Architectures（因此这个不能为空）的交集来确定，例如：<br>比如，你的Valid Architectures设置的支持arm指令集版本有：armv7/armv7s/arm64，对应的Architectures设置的支持arm指令集版本有：armv7s，这时Xcode只会生成一个armv7s指令集的二进制包。<br>再比如：将Architectures支持arm指令集设置为：armv7,armv7s，对应的Valid Architectures的支持的指令集设置为：armv7s,arm64，那么此时，XCode生成二进制包所支持的指令集只有armv7s</p></li></ol><pre><code>在Xcode6.1.1里的 Valid Architectures  设置里， 默认为 Standard architectures(armv7,arm64),如果你想改的话，自己在other中更改。原因解释如下： </code></pre><p>使用 standard architectures (including 64-bit)(armv7,arm64) 参数，则打的包里面有32位、64位两份代码，在iPhone5s（ iPhone5s的cpu是64位的 ）下，会首选运行64位代码包， 其余的iPhone（ 其余iPhone都是32位的,iPhone5c也是32位 ），只能运行32位包，但是包含两种架构的代码包，只有运行在ios6，ios7系统上。<br>这也就是说，这种打包方式，对手机几乎没要求，但是对系统有要求，即ios6以上。<br>而使用 standard architectures (armv7,armv7s) 参数， 则打的包里只有32位代码， iPhone5s的cpu是64位，但是可以兼容32位代码，即可以运行32位代码。但是这会降低iPhone5s的性能。 其余的iPhone对32位代码包更没问题， 而32位代码包，对系统也几乎也没什么限制。 </p><pre><code>所以总结如下：  要发挥iPhone5s的64位性能，就要包含64位包，那么系统最低要求为ios6。 如果要兼容ios5以及更低的系统，只能打32位的包，系统都能通用，但是会丧失iPhone5s的性能。</code></pre><p>（3）Build Active Architecture Only<br>    指定是否只对当前连接设备所支持的指令集编译<br>    当其值设置为YES，这个属性设置为yes，是为了debug的时候编译速度更快，它只编译当前的architecture版本，而设置为no时，会编译所有的版本。 编译出的版本是向下兼容的，连接的设备的指令集匹配是由高到低（arm64 &gt; armv7s &gt; armv7）依次匹配的。比如你设置此值为yes，用iphone4编译出来的是armv7版本的，iphone5也可以运行，但是armv6的设备就不能运行。  所以，一般debug的时候可以选择设置为yes，release的时候要改为no，以适应不同设备。 </p><p>1）<br>Architectures:  armv7, armv7s, arm64<br>ValidArchitectures:  armv6, armv7s, arm64<br>生成二进制包支持的指令集： arm64</p><p>2）<br>Architectures: armv6, armv7, armv7s<br>Valid Architectures:  armv6, armv7s, arm64<br>生成二进制包支持的指令集： armv7s </p><p>3）<br>Architectures: armv7, armv7s, arm64<br>Valid Architectures: armv7，armv7s</p><p>这种情况是报错的，因为允许使用指令集中没有arm64。</p><p>注：如果你对ipa安装包大小有要求，可以减少安装包的指令集的数量，这样就可以尽可能的减少包的大小。当然这样做会使部分设备出现性能损失，当然在普通应用中这点体现几乎感觉不到，至少不会威胁到用户体检。</p><p>三、制作静态库.a是指令集选择</p><p>现在回归到正题，如何制作一个“没有问题”的.a静态库，通过以上信息了解到，当我们做App的时候，为了追求高效率，并且减小包的大小，Build Active Architecture Only设置成YES，Architectures按Xcode默认配置就可以，因为arm64向前兼容。但制作.a静态库就不同了，因为要保证兼容性，包括不同iOS设备以及模拟器运行不出错，所以结合当前行业情况，要做到最大的兼容性。</p><p>四、iOS使用lipo 拆分 合并 .a(我们用CBAiDirectSDK.framework为例子)</p><ol><li>将需要拆分和合并的.framework和.a文件拷贝出去(保留原文件,拆分合并完直接替换掉)</li><li><p>终端cd到拷贝的CBAiDirectSDK.framework路径,依次查看所有需要合并的lib库所支持的框架类型。</p><pre><code>lipo -info CBAiDirectSDK* 输出: Architectures in the &lt;font color=#DC143C size=4 face=&quot;黑体&quot;&gt;fat&lt;/font&gt; file: CBAiDirectSDK are: i386 x86_64 armv7 arm64 * 解释:看到红色的fat了吗,fat file表示这个库里面合并了多于1个框架。</code></pre></li><li><p>将lib库拆分出armv7、arm64类型的.a:</p><pre><code>    lipo CBAiDirectSDK -thin armv7 -output CBAiDirectSDK_armv7lipo CBAiDirectSDK -thin arm64 -output CBAiDirectSDK_arm64</code></pre></li><li><p>找到CBAiDirectSDK_armv7文件,查看下信息(CBAiDirectSDK_arm64相同)</p><pre><code>lipo -info CBAiDirectSDK_armv7* 输出:Non-fat file: CBAiDirectSDK_armv7 is architecture: armv7</code></pre></li><li><p>合并成最终的静态库</p><pre><code>lipo -create -output CBAiDirectSDK CBAiDirectSDK_armv7 CBAiDirectSDK_arm64</code></pre></li><li><p>查看合成支持的框架类型</p><pre><code>lipo -info CBAiDirectSDK* 输出: Architectures in the fat file: CBAiDirectSDK are: armv7 arm64</code></pre><p>最后替换掉原项目中的CBAiDirectSDK.framework</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明:&quot;&gt;&lt;/a&gt;说明:&lt;/h3&gt;&lt;p&gt;有些第三方提供商为了方便开发者使用,经常把i386 x86_64 armv7 arm64 等几个平台合并到一起,但是上传App Store的时候需要将i386 x86_64两个平台删除后,才能正常审核。&lt;/p&gt;
&lt;h3 id=&quot;一、几个重要概念&quot;&gt;&lt;a href=&quot;#一、几个重要概念&quot; class=&quot;headerlink&quot; title=&quot;一、几个重要概念&quot;&gt;&lt;/a&gt;一、几个重要概念&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;ARM:ARM处理器,特点是体积小、低功耗、低成本、高性能,所以几乎所有手机处理器都基于ARM,在嵌入式系统中应用广泛。&lt;/li&gt;
&lt;li&gt;ARM处理器指令集: armv6 | armv7 | armv7s | arm64都是ARM处理器的指令集,这些指令集都是向下兼容的,例如armv7指令集兼容armv6,只是使用armv6的时候无法发挥出其性能,无法使用armv7的新特性,从而会导致程序执行效率没有那么高。&lt;br&gt;i386 | x86_64是Mac处理器的指令集,i386是针对intel通用微处理器32架构的(虚拟机: iPhone4s iPhone5)。x86_64是针对x86架构的64位处理器(虚拟机: iPhone5S iPhone6 iPhone6S iPhone7 iPhone8 iPhoneX)。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;目前iOS移动设备指令集&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>09- iOS证书申请和使用详情</title>
    <link href="http://waythought.duoshuo.com/2017/05/25/09.iOS%E8%AF%81%E4%B9%A6%E7%94%B3%E8%AF%B7%E5%92%8C%E4%BD%BF%E7%94%A8%E8%AF%A6%E6%83%85/"/>
    <id>http://waythought.duoshuo.com/2017/05/25/09.iOS证书申请和使用详情/</id>
    <published>2017-05-25T05:55:42.000Z</published>
    <updated>2018-08-25T03:18:16.045Z</updated>
    
    <content type="html"><![CDATA[<pre><code>由于公司近期开始接入个推推送,自己也没有详细的总结过iOS证书相关,今天刚好有时间,也就当个记录吧</code></pre><h4 id="一-App-ID-bundle-idengtifier"><a href="#一-App-ID-bundle-idengtifier" class="headerlink" title="一. App ID(bundle idengtifier)"></a>一. App ID(bundle idengtifier)</h4><p>App ID一这是每个应用的独立标识,应该是和Xcode中的Bundle Identifier是一致(Explicit)的或匹配(Wildcard)的。<br>App ID字符串通常以反域名格式Company Identifier 例如 “com.apple.garageband”<br>App ID全名会被追加Application Identifier(一般为TeamID),分为两类:</p><pre><code>* Explicit App ID：唯一的App ID，用于唯一标识一个应用程序。* Wildcard App ID：含有通配符的App ID，用于标识一组应用程序。</code></pre><a id="more"></a><h4 id="二-Certification-证书-cer"><a href="#二-Certification-证书-cer" class="headerlink" title="二. Certification 证书 (.cer)"></a>二. Certification 证书 (.cer)</h4><h5 id="1-开发者证书"><a href="#1-开发者证书" class="headerlink" title="1.开发者证书"></a>1.开发者证书</h5><p>证书是对电脑开发资格的认证,每个开发者账号有一套(2两种):</p><h5 id="1-Developer-Certification-开发证书"><a href="#1-Developer-Certification-开发证书" class="headerlink" title="1) Developer Certification(开发证书)"></a>1) Developer Certification(开发证书)</h5><p>安装在电脑上提供权限: 开发人员通过设备进行真机调试。可以生成副本供多台电脑安装;</p><h5 id="2-Distribution-Certification-发布证书"><a href="#2-Distribution-Certification-发布证书" class="headerlink" title="2) Distribution Certification(发布证书)"></a>2) Distribution Certification(发布证书)</h5><p>安装在电脑提供发布iOS程序的权限: 开发人员可以制做测试版和发布版的程序。不可生成副本,仅有配置该证书的电脑才可使用。</p><h5 id="2-推送证书"><a href="#2-推送证书" class="headerlink" title="2.推送证书"></a>2.推送证书</h5><p>推送证书也分为开发和生产两种,类型分别为APNs Development iOS, APNs Production iOS,该证书在appID配置中创建生成,安装在开发者电脑上。</p><h4 id="三-Devices"><a href="#三-Devices" class="headerlink" title="三. Devices"></a>三. Devices</h4><p>苹果的测试证书、发布证书以及推送证书都有对应的Provisioning Profile文件,来验证当前开发者、当前应用、是否能在该真机设备上测试、安装或者运行。所以,需要对该真机设备的UDID进行注册,生成对应的Provisioning Profiles</p><h4 id="四-Provisioning-Profiles-授权证书-PP描述文件"><a href="#四-Provisioning-Profiles-授权证书-PP描述文件" class="headerlink" title="四. Provisioning Profiles(授权证书 PP描述文件)"></a>四. Provisioning Profiles(授权证书 PP描述文件)</h4><p>授权文件是对设备iPhone、iPad、iPod Touch的授权,文件内记录的是设备的UDID和程序的App ID,也就是被授权的设备即Xcode可以安装或者调试Bundle identifier与授权文件中记录的App id对应的程序</p><h5 id="1-Developer-Provisioning-Profile-开发授权文件"><a href="#1-Developer-Provisioning-Profile-开发授权文件" class="headerlink" title="1)Developer Provisioning Profile(开发授权文件)"></a>1)Developer Provisioning Profile(开发授权文件)</h5><p>在装有开发证书或者开发证书副本的电脑上使用,开发人员选择该授权文件通过电脑将程序安装到授权文件记录的设备中,也就是可以进行真机调试</p><h5 id="2-Distribution-Provisioning-Profile-发布授权文件"><a href="#2-Distribution-Provisioning-Profile-发布授权文件" class="headerlink" title="2)Distribution Provisioning Profile(发布授权文件)"></a>2)Distribution Provisioning Profile(发布授权文件)</h5><p>在装有发布证书的电脑上制作测试版本和发布版本的程序。</p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;由于公司近期开始接入个推推送,自己也没有详细的总结过iOS证书相关,今天刚好有时间,也就当个记录吧
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;一-App-ID-bundle-idengtifier&quot;&gt;&lt;a href=&quot;#一-App-ID-bundle-idengtifier&quot; class=&quot;headerlink&quot; title=&quot;一. App ID(bundle idengtifier)&quot;&gt;&lt;/a&gt;一. App ID(bundle idengtifier)&lt;/h4&gt;&lt;p&gt;App ID一这是每个应用的独立标识,应该是和Xcode中的Bundle Identifier是一致(Explicit)的或匹配(Wildcard)的。&lt;br&gt;App ID字符串通常以反域名格式Company Identifier 例如 “com.apple.garageband”&lt;br&gt;App ID全名会被追加Application Identifier(一般为TeamID),分为两类:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;* Explicit App ID：唯一的App ID，用于唯一标识一个应用程序。
* Wildcard App ID：含有通配符的App ID，用于标识一组应用程序。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>08-.gitignore相关</title>
    <link href="http://waythought.duoshuo.com/2017/04/15/08.gitignore/"/>
    <id>http://waythought.duoshuo.com/2017/04/15/08.gitignore/</id>
    <published>2017-04-15T05:25:42.000Z</published>
    <updated>2018-11-10T03:21:01.247Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-作用"><a href="#1-作用" class="headerlink" title="1.作用:"></a>1.作用:</h4><p>利用.gitignore过滤文件，如编译过程中的中间文件，等等，这些文件不需要被追踪管理。<br><a href="https://github.com/github/gitignore" target="_blank" rel="external"><font size="3">内容参考gitHub</font></a></p><h4 id="2-gitignore无效，不能过滤某些文件"><a href="#2-gitignore无效，不能过滤某些文件" class="headerlink" title="2.gitignore无效，不能过滤某些文件"></a>2.gitignore无效，不能过滤某些文件</h4><a id="more"></a><ul><li>现象：<br>在.gitignore添加file1文件，以过滤该文件，但是通过git status查看仍显示file1文件的状态。</li><li>原因：<br>在git库中已存在了这个文件，之前push提交过该文件。<br>.gitignore文件只对还没有加入版本管理的文件起作用，如果之前已经用git把这些文件纳入了版本库，就不起作用了</li><li>解决：<br>需要在git库中删除该文件，并更新。<br>然后再次git status查看状态，file1文件不再显示状态。</li></ul><p>注意:<br>    先在.gitignore中添加忽略的文件,再去添加文件(待验证)</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-作用&quot;&gt;&lt;a href=&quot;#1-作用&quot; class=&quot;headerlink&quot; title=&quot;1.作用:&quot;&gt;&lt;/a&gt;1.作用:&lt;/h4&gt;&lt;p&gt;利用.gitignore过滤文件，如编译过程中的中间文件，等等，这些文件不需要被追踪管理。&lt;br&gt;&lt;a href=&quot;https://github.com/github/gitignore&quot;&gt;&lt;font size=&quot;3&quot;&gt;内容参考gitHub&lt;/font&gt;
&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;2-gitignore无效，不能过滤某些文件&quot;&gt;&lt;a href=&quot;#2-gitignore无效，不能过滤某些文件&quot; class=&quot;headerlink&quot; title=&quot;2.gitignore无效，不能过滤某些文件&quot;&gt;&lt;/a&gt;2.gitignore无效，不能过滤某些文件&lt;/h4&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>07-JavaScript &amp;&amp; iOS原生交互</title>
    <link href="http://waythought.duoshuo.com/2017/03/15/07-JavaScript%20&amp;&amp;%20iOS%E5%8E%9F%E7%94%9F%E4%BA%A4%E4%BA%92/"/>
    <id>http://waythought.duoshuo.com/2017/03/15/07-JavaScript &amp;&amp; iOS原生交互/</id>
    <published>2017-03-15T08:23:12.000Z</published>
    <updated>2018-08-25T03:17:24.931Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JavaScript-amp-amp-iOS原生交互"><a href="#JavaScript-amp-amp-iOS原生交互" class="headerlink" title="JavaScript &amp;&amp; iOS原生交互"></a>JavaScript &amp;&amp; iOS原生交互</h3><p>JavaScript &amp;&amp; iOS原生交互第三方框架:<br><a href="https://github.com/marcuswestin/WebViewJavascriptBridge" target="_blank" rel="external">WebViewJavascriptBridge</a></p><h4 id="1-简单用法-OC执行JS"><a href="#1-简单用法-OC执行JS" class="headerlink" title="1. 简单用法(OC执行JS)"></a>1. 简单用法(OC执行JS)</h4><pre><code>UIWebView在webViewDidFinishLoad里使用 - (nullable NSString *)stringByEvaluatingJavaScriptFromString:(NSString *)script;// 获取当前页面的titleNSString *title = [webview stringByEvaluatingJavaScriptFromString:@&quot;document.title&quot;];// 获取当前页面的urlNSString *url = [webview stringByEvaluatingJavaScriptFromString:@&quot;document.location.href&quot;];</code></pre><a id="more"></a><h4 id="2-OC执行JS-amp-amp-JS执行OC"><a href="#2-OC执行JS-amp-amp-JS执行OC" class="headerlink" title="2. OC执行JS &amp;&amp; JS执行OC"></a>2. OC执行JS &amp;&amp; JS执行OC</h4><pre><code>2.1 JavaScriptCore:iOS7后引用,里面包含常见的对象及协议如下:JSContext：给JavaScript提供运行的上下文环境,通过-evaluateScript:方法就可以执行一JS代码JSValue：JavaScript和Objective-C数据和方法的桥梁,封装了JS与ObjC中的对应的类型，以及调用JS的API等JSManagedValue：管理数据和方法的类JSVirtualMachine：处理线程相关，使用较少JSExport：这是一个协议，如果采用协议的方法交互，自己定义的协议必须遵守此协议</code></pre><p>注:</p><blockquote><p>JSContext 和 JSValue : JSVirtualMachine 为JavaScript的运行提供了底层资源,JSContext为JavaScript其提供着运行环境,通过evaluateScript方法就可以执行一段JavaScript脚本,并且如果其中有方法,变量等信息都会被存储在其中以便在需要的时候使用。而JSContext的创建都是基于JSVirtualMachine(initwithVirtualMachine:),如果使用init进行初始化,那么在其内部会自动创建一个新的JSVirtualMachine对象然后调用前边的初始化方法。<br>JSValue是JSContext执行后的返回结果,封装了JS与ObjC中的对应的类型,可以方便的在两种类型之间转换,可以说是JavaScript和Object-C之间互换的桥梁</p></blockquote><pre><code>Objective-C type  |   JavaScript type</code></pre><p>   ——————–+———————<br>           nil         |     undefined<br>          NSNull       |        null<br>         NSString      |       string<br>         NSNumber      |   number, boolean<br>       NSDictionary    |   Object object<br>         NSArray       |    Array object<br>          NSDate       |     Date object<br>         NSBlock (1)   |   Function object (1)<br>            id (2)     |   Wrapper object (2)<br>          Class (3)    | Constructor object (3)</p><blockquote><p>JSVirtualMachine : “A JSVirtualMachine instance represents a self-contained environment for JavaScript execution.”，这段话是官方文档中对JSVirtualMachine的定义，我们使用JSVirtualMachine的目的主要有两个：支持JavaScript并发执行，管理用于衔接JavaScript 与 OC(Swift) 代码的对象的内存。</p></blockquote><p>#####2.1 简单直接调用JS代码<br>        // 一个JSContext对象<br>        self.jsContext = [[JSContext alloc] init];</p><pre><code>//  jscontext可以直接执行JS代码。[self.jsContext evaluateScript:@&quot;var num = 10&quot;];[self.jsContext evaluateScript:@&quot;var squareFunc = function(value) { return value * 2 }&quot;];// 计算正方形的面积JSValue *square = [self.jsContext evaluateScript:@&quot;squareFunc(num)&quot;];// 也可以通过下标的方式获取到方法JSValue *squareFunc = self.jsContext[@&quot;squareFunc&quot;];// 将参数传进去来调用方法JSValue *value = [squareFunc callWithArguments:@[@&quot;20&quot;]];NSLog(@&quot;%@&quot;, square.toNumber);NSLog(@&quot;%@&quot;, value.toNumber);</code></pre><p>#####2.2 快读调用Block,可以传入参数</p><pre><code>JSContext *context = [[JSContext alloc] init];context[@&quot;log&quot;] = ^() {NSLog(@&quot;+++++++Begin Log+++++++&quot;);// 获取当前参数列表NSArray *args = [JSContext currentArguments];for (JSValue *jsVal in args) {NSLog(@&quot;%@&quot;, jsVal);}// 获取当前调用该方法的对象JSValue *this = [JSContext currentThis];NSLog(@&quot;this: %@&quot;,this);NSLog(@&quot;-------End Log-------&quot;);};[context evaluateScript:@&quot;log(&apos;ider&apos;, [7, 21], { hello:&apos;world&apos;, js:100 });&quot;];//// Output:// +++++++Begin Log+++++++// ider// 7,21// [object Object]// this: [object GlobalObject]// -------End Log-------</code></pre><h3 id="3-协议、模型实现"><a href="#3-协议、模型实现" class="headerlink" title="3.协议、模型实现"></a>3.协议、模型实现</h3><p>事先和前端wap协商格式、定义方法的名字和参数的顺序<br>    3.1 定义一个模型 KNOCJSModel<br>    3.2 在该模型实现以下协议(协议中定义需要暴露给js的属性和方法)</p><pre><code>@protocol KNOCJSObjectProtocol &lt;JSExport&gt;// 在JS中调用时，函数名应该为showAlertMsg(arg1, arg2)// 这里是只两个参数的。- (void)showAlert:(NSString *)title msg:(NSString *)msg;// JS调用Oc，然后在OC中通过调用JS方法来传值给JS。- (void)jsCallObjcAndObjcCallJsWithDict:(NSDictionary *)params;@endtypedef void (^KNOCJSModelDetailAlertBlock)(NSString * title, NSString *message);typedef void (^KNOCJSModelDetailCallJsBlock)(NSDictionary *dic);@interface ObjCModel : NSObject &lt;JavaScriptObjectiveCDelegate&gt;@property (nonatomic, copy) KNOCJSModelDetailAlertBlock alertBlock;@property (nonatomic, copy) KNOCJSModelDetailCallJsBlock callJsBlock;@end</code></pre><p>3.3实现模型</p><pre><code>@implementation ObjCModel- (void)showAlert:(NSString *)title msg:(NSString *)msg {    if (self. alertBlock) {        self.alertBlock(title, msg)    }}- (void)jsCallObjcAndObjcCallJsWithDict:(NSDictionary *)params {    if (self. callJsBlock) {        self. callJsBlock(params);    }    }@end</code></pre><p>3.4 在控制器中webView加载完成的代理中,给JSContext注入模型</p><pre><code>#pragma mark - UIWebViewDelegate- (void)webViewDidFinishLoad:(UIWebView *)webView {  JSContext *context = [webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;]; // 通过模型调用方法，这种方式更好些。 KNOCJSModel *objectModel  = [[KNOCJSModel alloc] init]; context[@&quot;native&quot;] = objectModel;__weak typeof(self) weakSelf = selfobjectModel.alertBlock = ^(NSString *title, NSString *msg) {    dispatch_async(dispatch_get_main_queue(), ^{    UIAlertView *alert = [[UIAlertView alloc] initWithTitle:title message:msg delegate:nil cancelButtonTitle:@&quot;Ok&quot; otherButtonTitles:nil, nil];        [alert show];    });};objectModel.callJsBlock = ^(NSDictionary *dic) {    dispatch_async(dispatch_get_main_queue(), ^{        // 第一种方式        JSValue *jsParamFunc = context[@&quot;jsParamFunc&quot;];        [jsParamFunc callWithArguments:@[@{@&quot;age&quot;: @10, @&quot;name&quot;: @&quot;lili&quot;, @&quot;height&quot;: @158}]];        // 第二种方式         NSString *alertUserInfo = [NSString stringWithFormat:@&quot;jsParamFunc(&apos;%@&apos;,&apos;%@&apos;,&apos;%@&apos;)&quot;, @10, @&quot;lili&quot;, @158];        [context evaluateScript:alertUserInfo];    });}; context.exceptionHandler = ^(JSContext *context, JSValue *exceptionValue) {   context.exception = exceptionValue;   NSLog(@&quot;异常信息：%@&quot;, exceptionValue); };}</code></pre><p>3.5 在html中的body中添加以下代码:(这里要和wap端统一好)<font color="#0099ff" size="3" face="黑体">‘native’</font></p><pre><code>    &lt;div style=&quot;margin-top: 100px&quot;&gt;&lt;h1&gt;Test how to use objective-c call js&lt;/h1&gt;&lt;input type=&quot;button&quot; value=&quot;Call ObjC system alert&quot; onclick=&quot;native.showAlertMsg(&apos;js title&apos;, &apos;js message&apos;)&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;input type=&quot;button&quot; value=&quot;Call ObjC func with JSON and ObjC call js func to pass args.&quot; onclick=&quot;native.jsCallObjcAndObjcCallJsWithDict({&apos;name&apos;: &apos;testname&apos;, &apos;age&apos;: 10, &apos;height&apos;: 170})&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;span id=&quot;jsParamFuncSpan&quot; style=&quot;color: red; font-size: 50px;&quot;&gt;&lt;/span&gt;&lt;/div&gt;也可自己在控制器中执行js代码调用- (void)useJSExprot {      JSContext *context = [self.webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;];      KNOCJSModel *objectModel  = [[KNOCJSModel alloc] init];      context[@&quot;native&quot;] = objectModel;      [context evaluateScript:@&quot;objectModel.showAlertMsg()&quot;]}</code></pre><p>保留:<br>    1.在Block内都不要直接使用其外部定义的JSContext对象或者JSValue，应该将其当做参数传入到Block中，或者通过JSContext的类方法+ (JSContext *)currentContext;来获得。否则会造成循环引用使得内存无法被正确释放。<br>    2.如果js端的方法是这样的<br>func viewDetailLoginNamePassWord(String name, String passWord) {</p><p>}</p><p>我们可以用<br>第一种:</p><ul><li>(void)viewDetailLoginName:(NSString *)loginName<pre><code>PassWord:(NSString *)passWord;</code></pre></li></ul><p>第二种:<br>JSExportAs(viewDetailLoginNamePassWord,<br>           -(void)viewDetailLoginNamePassWord:(NSString <em>)loginName psd:(NSString </em>)psd;)<br><a href="http://www.jianshu.com/p/fad8c7844d3e" target="_blank" rel="external">http://www.jianshu.com/p/fad8c7844d3e</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;JavaScript-amp-amp-iOS原生交互&quot;&gt;&lt;a href=&quot;#JavaScript-amp-amp-iOS原生交互&quot; class=&quot;headerlink&quot; title=&quot;JavaScript &amp;amp;&amp;amp; iOS原生交互&quot;&gt;&lt;/a&gt;JavaScript &amp;amp;&amp;amp; iOS原生交互&lt;/h3&gt;&lt;p&gt;JavaScript &amp;amp;&amp;amp; iOS原生交互第三方框架:&lt;br&gt;&lt;a href=&quot;https://github.com/marcuswestin/WebViewJavascriptBridge&quot;&gt;WebViewJavascriptBridge&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;1-简单用法-OC执行JS&quot;&gt;&lt;a href=&quot;#1-简单用法-OC执行JS&quot; class=&quot;headerlink&quot; title=&quot;1. 简单用法(OC执行JS)&quot;&gt;&lt;/a&gt;1. 简单用法(OC执行JS)&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;UIWebView在webViewDidFinishLoad里使用 - (nullable NSString *)stringByEvaluatingJavaScriptFromString:(NSString *)script;
// 获取当前页面的title
NSString *title = [webview stringByEvaluatingJavaScriptFromString:@&amp;quot;document.title&amp;quot;];

// 获取当前页面的url
NSString *url = [webview stringByEvaluatingJavaScriptFromString:@&amp;quot;document.location.href&amp;quot;];
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>06-Objectview-C 中变量采用@property的各个关键字的含义</title>
    <link href="http://waythought.duoshuo.com/2016/12/15/06-Objectview-C%20%E4%B8%AD%E5%8F%98%E9%87%8F%E9%87%87%E7%94%A8@property%E7%9A%84%E5%90%84%E4%B8%AA%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%90%AB%E4%B9%89/"/>
    <id>http://waythought.duoshuo.com/2016/12/15/06-Objectview-C 中变量采用@property的各个关键字的含义/</id>
    <published>2016-12-15T05:47:16.000Z</published>
    <updated>2018-11-26T08:59:57.360Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Objectview-C-中变量采用-property的各个关键字的含义"><a href="#Objectview-C-中变量采用-property的各个关键字的含义" class="headerlink" title="Objectview-C 中变量采用@property的各个关键字的含义"></a>Objectview-C 中变量采用@property的各个关键字的含义</h3><h4 id="1-property的本质是什么"><a href="#1-property的本质是什么" class="headerlink" title="1.@property的本质是什么?"></a>1.@property的本质是什么?</h4><p>@property = ivar + getter + setter<br>“属性”(property) = 实例变量 + 存取方法<br>OC2.0开始,系统提供了自动生成设置变量值得方法或获取变量值得方法,让我们有更多的精力放在程序的业务逻辑上</p><h4 id="2-ARC下-不显示指定任何属性性关键字时-默认的关键字有哪些"><a href="#2-ARC下-不显示指定任何属性性关键字时-默认的关键字有哪些" class="headerlink" title="2.ARC下,不显示指定任何属性性关键字时,默认的关键字有哪些?"></a>2.ARC下,不显示指定任何属性性关键字时,默认的关键字有哪些?</h4><pre><code>对于基本数据类型默认关键字是:atomic,readwrite,assign对于普通的OC对象:atomic,readwrite,strong</code></pre><a id="more"></a><h4 id="3-copy关键字"><a href="#3-copy关键字" class="headerlink" title="3.copy关键字"></a>3.copy关键字</h4><pre><code>3.1 NSString,NSArray,NSDictionary等等经常使用copy关键字,是因为他们有对应的可变类型:NSMutableString、NSMutableArray、NSMutableDictionary；是对应的子类,他们之间可能进行赋值操作,为确保对象中的字符串值不会无意间变动,应该在设置新属性值时拷贝一份3.2 block 也经常使用copy关键字,这是从MRC遗留下的&quot;传统&quot;,在MRC中,方法内部的block是在栈区的,使用copy可以把它放在堆区;ARC中写不写都行: 对于block使用copy还是strong效果是一样的,但写上copy能够提醒我们:编译器自动对block进行了copy操作。3.3 小试牛刀:    这个写法会出什么问题 @property (copy) NSMutableArray *array;    3.3.1 添加,删除,修改数组内的元素的时候,程序会因为找不到对应的方法而崩溃,因为copy是复制的一个不可变的NSArray的对象    3.3.2 默认关键字是atomic属性会严重影响性能</code></pre><h4 id="4-weak-关键字"><a href="#4-weak-关键字" class="headerlink" title="4. weak 关键字"></a>4. weak 关键字</h4><pre><code>4.1 在ARC中,有可能出现循环引用的时候,往往要通过让其中一端使用weak来解决,比如delegate代理4.2 自身已经对它进行一次强引用,没有必要再强引用一次,此时也会使用weak,自定义IBOutlet控件的属性一般也使用weak。</code></pre><h4 id="5-assign"><a href="#5-assign" class="headerlink" title="5. assign"></a>5. assign</h4><pre><code>只会执行基本类型的简单赋值操作,既不保留新值,也不释放旧值。如果使用assign去修饰一个对象,这个对象会立即被释放,assign在被释放的时候是不会把指针设置为nil的,assigin会保留对象的指针地址,形成野指针,这个时候调用该对象的方法(给野指针发送消息)就会崩溃。</code></pre><h4 id="6-retain"><a href="#6-retain" class="headerlink" title="6. retain"></a>6. retain</h4><pre><code>释放旧的对象，将旧对象的值赋予输入对象，再提高输入对象的索引计数为1</code></pre><h4 id="7-nonnull"><a href="#7-nonnull" class="headerlink" title="7.nonnull:"></a>7.nonnull:</h4><pre><code>不能为空,用来修饰属性,或者方法的参数,方法的返回值,不适用于assign属性,因为他是专门用来修饰指针的 @property (nonatomic, copy, nonnull) NSString *name;  @property (nonatomic, copy) NSString * _Nonnull name;   @property (nonatomic, copy) NSString * __nonnull name;</code></pre><h4 id="8-nullable"><a href="#8-nullable" class="headerlink" title="8.nullable:"></a>8.nullable:</h4><pre><code>表示可以为空,代码提示会告诉你这个谁能够是可以为空的@property (nonatomic, copy, nullable) NSString *name;@property (nonatomic, copy) NSString *_Nullable name;@property (nonatomic, copy) NSString *__nullable name;</code></pre><h4 id="9-null-resettable"><a href="#9-null-resettable" class="headerlink" title="9.null_resettable:"></a>9.null_resettable:</h4><pre><code>表示get方法不能返回为空,set方法可以为空 ⚠️⚠️⚠️ 必须重写该属性的get方法,保证返回值不为空tan @property(nonatomic,strong,null_resettable) NSNumber * number;(只有这一种方式)</code></pre><h4 id="10-null-unspecified"><a href="#10-null-unspecified" class="headerlink" title="10.null_unspecified"></a>10.null_unspecified</h4><pre><code>表示不确定是否为空,使用方式有三种: @property(nonatomic,strong) NSNumber *_Null_unspecified height; @property(nonatomic,strong) NSNumber *__null_unspecified height;  @property(nonatomic,strong,null_unspecified) NSNumber * height;</code></pre><h3 id="11-atomic和nonatomic的区别"><a href="#11-atomic和nonatomic的区别" class="headerlink" title="11.atomic和nonatomic的区别?"></a>11.atomic和nonatomic的区别?</h3><p>11-1.介绍<br>atomic:是原子性,是默认的;系统生成的getter/setter方法会进行加锁操作,注意:这个锁仅仅保证了getter和setter存取方法的线程是安全的,</p><p>例如: 线程1调用了某一属性的setter方法并进行到了一半,线程2调用其getter方法,那么会执行完setter操作后,在执行getter操作,线程2会获取到线程1 setter后的完整的值.</p><p>当几个线程同时调用同一属性的setter、getter方法时,会get到一个完整的值,但get到的值不可控.</p><p>例如: 线程1 调用getter 线程2 调用setter 线程3 调用setter 这3个线程并行同时开始,线程1会get到一个值,但是这个值不可控,可能是线程2,线程3 set之前的原始值,可能是线程2 set的值,也可能是线程3 set的值</p><p>说atomic是线程安全的,这个是不准确的。这种安全仅仅是set/get的读写安全,并非真正意义上的线程安全,因为线程安全还有读写之外的其他操作(比如1:如果当一个线程正在get或set时,又有另一个线程进行release操作,可能会直接crash,比如2: 线程1 调用getter 线程2 调用setter 线程3 调用setter 这3个线程并行同时开始,线程1会get到一个值,但是这个值不可控,可能是线程2,线程3 set之前的原始值,可能是线程2 set的值,也可能是线程3 set的值)</p><p>nonatomic:不是默认的,速度快,线程不安全;如果有两个线程访问同一个属性,会出现数据紊乱</p><p>总之:使用nonatomic修饰NSMutableArray对象就可以,而使用锁、dispath_queue来保证NSMutableArray对象的线程安全。</p><p>11-2.打造线程安全的NSMutableArray</p><p>在《Effective Objective-C 2.0》中第41条:多用派发队列,少使用同步锁中指出:使用”串行同步队列”(serial synchronization queue),将读取操作及写入操作都安排在同一个队列里,即可保证数据同步。而通过并发队列,结合GCD中栅栏块(barrier)来不仅实现数据同步线程安全,还比串行同步队列方式更高效。</p><p>在一个并发队列中,读取操作是用普通的块来实现的,而写入操作则是用栅栏块来实现的。栅栏块单独执行,不能与其他块并行。直到当前所有并发块都执行完毕,才会单独执行这个栅栏块。(dispath_barrier_async栅栏块首先查看队列中有没有别的任务执行,如果有则会等待已有的任务执行完毕再执行)</p><p>注意:</p><p>1.同步栅栏函数与异步栅栏函数<br>相同点: 栅栏函数会在之前的任务都结束后才开始<br>不同点: 同步栅栏函数结束之后才会执行栅栏函数下一行代码,由于没有执行后面的代码,所以不会把后面的任务添加到队列中; 异步栅栏函数结束之后才会执行栅栏函数后面的任务,栅栏函数结束之前,后面的任务代码依然执行,只是把任务添加到队列中,单不会执行任务,只有等栅栏函数结束后才会执行任务。</p><p>同步栅栏<br><img src="http://payoeqxrw.bkt.clouddn.com/zhala_1.png" alt=""><br>打印结果<br><img src="http://payoeqxrw.bkt.clouddn.com/zhala_2.png" alt=""></p><p>异步栅栏<br><img src="http://payoeqxrw.bkt.clouddn.com/zhala_3.png" alt=""><br>打印结果<br><img src="http://payoeqxrw.bkt.clouddn.com/zhala_4.png" alt=""></p><p>主要是看”OperationBarrierSync”与”Hello World的顺序</p><p>线程安全的NSMutableArray实现如下:</p><pre><code>@interface QSThreadSafeMutableArray()@property (nonatomic, strong) dispatch_queue_t MSyncQueue;@property (nonatomic, strong) NSMutableArray*  MDataArray;@end@implementation QSThreadSafeMutableArray#pragma mark - init 方法- (instancetype)initCommon{    self = [super init];    if (self) {        //%p 以16进制的形式输出内存地址，附加前缀0x        NSString* uuid = [NSString stringWithFormat:@&quot;com.jzp.array_%p&quot;, self];        //注意：_MSyncQueue是并行队列        _MSyncQueue = dispatch_queue_create([uuid UTF8String], DISPATCH_QUEUE_CONCURRENT);    }    return self;}- (instancetype)init{    self = [self initCommon];    if (self) {        _MDataArray = [NSMutableArray array];    }    return self;}- (id)objectAtIndex:(NSUInteger)index{    __block id obj;    dispatch_sync(_MSyncQueue, ^{        if (index &lt; [_MDataArray count]) {            obj = _MDataArray[index];        }    });    return obj;}-(NSEnumerator *)objectEnumerator{    __block NSEnumerator *enu;    dispatch_sync(_MSyncQueue, ^{        enu = [_MDataArray objectEnumerator];    });    return enu;}- (void)insertObject:(id)anObject atIndex:(NSUInteger)index{    dispatch_barrier_async(_MSyncQueue, ^{        if (anObject &amp;&amp; index &lt; [_MDataArray count]) {            [_MDataArray insertObject:anObject atIndex:index];        }    });}- (void)addObject:(id)anObject{    dispatch_barrier_async(_MSyncQueue, ^{        if(anObject){            [_MDataArray addObject:anObject];        }    });}- (void)removeObjectAtIndex:(NSUInteger)index{    dispatch_barrier_async(_MSyncQueue, ^{        if (index &lt; [_MDataArray count]) {            [_MDataArray removeObjectAtIndex:index];        }    });}- (void)removeLastObject{    dispatch_barrier_async(_MSyncQueue, ^{        [_MDataArray removeLastObject];    });}- (void)replaceObjectAtIndex:(NSUInteger)index withObject:(id)anObject{    dispatch_barrier_async(_MSyncQueue, ^{        if (anObject &amp;&amp; index &lt; [_MDataArray count]) {            [_MDataArray replaceObjectAtIndex:index withObject:anObject];        }    });}- (NSUInteger)indexOfObject:(id)anObject{    __block NSUInteger index = NSNotFound;    dispatch_sync(_MSyncQueue, ^{        for (int i = 0; i &lt; [_MDataArray count]; i ++) {            if ([_MDataArray objectAtIndex:i] == anObject) {                index = i;                break;            }        }    });    return index;}- (void)dealloc{    if (_MSyncQueue) {        _MSyncQueue = NULL;    }}@end</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Objectview-C-中变量采用-property的各个关键字的含义&quot;&gt;&lt;a href=&quot;#Objectview-C-中变量采用-property的各个关键字的含义&quot; class=&quot;headerlink&quot; title=&quot;Objectview-C 中变量采用@property的各个关键字的含义&quot;&gt;&lt;/a&gt;Objectview-C 中变量采用@property的各个关键字的含义&lt;/h3&gt;&lt;h4 id=&quot;1-property的本质是什么&quot;&gt;&lt;a href=&quot;#1-property的本质是什么&quot; class=&quot;headerlink&quot; title=&quot;1.@property的本质是什么?&quot;&gt;&lt;/a&gt;1.@property的本质是什么?&lt;/h4&gt;&lt;p&gt;@property = ivar + getter + setter&lt;br&gt;“属性”(property) = 实例变量 + 存取方法&lt;br&gt;OC2.0开始,系统提供了自动生成设置变量值得方法或获取变量值得方法,让我们有更多的精力放在程序的业务逻辑上&lt;/p&gt;
&lt;h4 id=&quot;2-ARC下-不显示指定任何属性性关键字时-默认的关键字有哪些&quot;&gt;&lt;a href=&quot;#2-ARC下-不显示指定任何属性性关键字时-默认的关键字有哪些&quot; class=&quot;headerlink&quot; title=&quot;2.ARC下,不显示指定任何属性性关键字时,默认的关键字有哪些?&quot;&gt;&lt;/a&gt;2.ARC下,不显示指定任何属性性关键字时,默认的关键字有哪些?&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;对于基本数据类型默认关键字是:atomic,readwrite,assign
对于普通的OC对象:atomic,readwrite,strong
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>05-git教程</title>
    <link href="http://waythought.duoshuo.com/2016/11/13/05-git%E6%95%99%E7%A8%8B/"/>
    <id>http://waythought.duoshuo.com/2016/11/13/05-git教程/</id>
    <published>2016-11-13T12:45:06.000Z</published>
    <updated>2019-11-11T11:11:19.581Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>SVN: 集中式的版本控制系统. 本地只有文件,没有版本库,所有的代码只在服务器上有版本记录,如果要进行版本的回退,和一些tag操作,必须经过服务器</p></li><li><p>Git: 分布式版本控制系统,每个人电脑就有版本库.写完代码,先提交到本地的版本,让后提交到服务器上,最后每个电脑都有一个最新的代码</p><pre><code>git也要配置服务器, 但是服务器的作用, 只是作为一个中间桥梁供开发人员去同步代码用的.git有机器强大的分支管理,把SVN等远远抛在了后面</code></pre></li></ul><h4 id="1-远程仓库"><a href="#1-远程仓库" class="headerlink" title="1.远程仓库"></a>1.远程仓库</h4><ul><li><p>1.1 创建SSH Key. 在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。使用以下命令创建SSH Key：(替换成你的邮箱地址).</p><pre><code>$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</code></pre></li><li><p>1.2 在用户主目录中找到.ssh目录,里面有id_rsa(私钥)和id_rea.pub(公钥),打开id_rea.pub并记录下来.</p></li><li><p>1.3 登录GitHub,打开”Account settings”,”SSH Key”页面,添加Key,把id_rea.pub内容添加进去.</p><pre><code>git需要在GitHup,OsChina,GitLabel中添加自己的公钥由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的,GitHub只要知道了你的公钥,就可以在每台电脑上往GitHub推送了.</code></pre><a id="more"></a></li><li><p>1.4 添加远程库</p><pre><code>在GitHub上创建仓库,使用下面命令,把这个远程的仓库与本地已有的仓库进行关联,之后就可以把本地仓库的内容推送到GitHub仓库了,注意是SSH的,传输相比http稳定cd 到本地文件        $ git remote add origin git@github.com:WayThought/blog.gitgit remote  查看远程库的信息$ git remote origin或者，用git remote -v显示更详细的信息</code></pre></li><li><p>1.5 从远程库克隆(当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。)</p><pre><code> cd 到本地文件        $ git clone git@github.com:WayThought/blog.git</code></pre><p>这样就把远程的仓库克隆到了本地</p></li></ul><h4 id="2-本地分支管理"><a href="#2-本地分支管理" class="headerlink" title="2.本地分支管理"></a>2.本地分支管理</h4><p>git status: 查看文件的状态</p><p>git add : 提交有修改的文件,由工作区到暂存区</p><pre><code>git add 文件名  添加指定修改的文件到暂存区git add .  添加当前目录所有有修改的文件到暂存区</code></pre><p>git commit : 提交暂存区的文件到本地版本库</p><pre><code>git commit -m &quot;注释&quot; 文件名  提交指定的文件到本地仓库git commit -m &quot;注释&quot;        提交所有的文件到本地仓库</code></pre><p>(需要提交的改动文件,必须先add加到缓存区,再commit到版本区)</p><p>git pull和push命令是本地仓库和远程仓库(服务器)打交道的,一般在push之前都会先pull下代码,如果有冲突,解决完冲突再push</p><pre><code>git pull 从服务器上更新代码到本地仓库,切换到本地需要提交的分支(dev)git pull origin dev  把服务器远程仓库更新的代码拉到本地仓库git push origin dev  把本地仓库的代码更新推送到服务器上</code></pre><p>创建与合并分支(当前分支为master)</p><pre><code>git branch  查看当前分支git branch dev origin/dev 切换到分支devgit checkout dev    切换到分支devgit checkout -b dev   创建dev分支,然后切换到dev分支git merge dev  把dev的工作内容合并到master上(分支A合并分支B,与分支B合并分支A是一样的)</code></pre><h4 id="3-版本回退※"><a href="#3-版本回退※" class="headerlink" title="3.版本回退※"></a>3.版本回退※</h4><pre><code>git log  显示历史记录(写周报或者查看版本号)git reflog 来记录你的每一次命令(版本回退后,可以找到上一个版本的commit id )git reset --hard HEAD^ 回退到上一个版本git reset --hard HEAD^^ 回退到上上个版本git reset --hard HEAD 版本号 回退到指定的版本注: 如何找回删除的分支    3.1 通过git reflog 命令找到我们需要恢复的信息对应的commit_id (根据log 提交的日期时间)    3.2 通过git branch 新分支名字 对应的commit_id 来建立一个新的分支,吧丢失的东西恢复到新分支上    如何临时修复bug    git stash 把工作区的内容暂时隐藏    git stash pop 把工作区的内容显示到当前分支</code></pre><h4 id="4-补充"><a href="#4-补充" class="headerlink" title="4.补充:"></a>4.补充:</h4><p>4.1 常用命令:※</p><pre><code>git config user.name 查看用户名git config user.email 查看邮箱地址git config --global user.name &quot;Your Name&quot;  提交名字git config --global user.email you@example.com  提交邮箱git rm &lt;file&gt;       # 从版本库中删除文件git rm &lt;file&gt; --cached  # 从版本库中删除文件，但不删除文件git reset &lt;file&gt;    # 从暂存区恢复到工作文件git reset -- .      # 从暂存区恢复到工作文件git reset --hard    # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改git stash listgit stash pop  恢复的同时把stash内容也删了git checkout -- readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销git checkout -- . 把工作区的修改全部撤销git reset HEAD filepathname   来放弃指定文件的暂存区内容git reset HEAD .      放弃所有暂存区内容(head相同的两个分支)未add和commit的内容如果checkout另一个分支会带过去 可以来回切换</code></pre><p>4.2 常见问题:</p><p>4.2.1 git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接：</p><pre><code>$ git branch --set-upstream dev origin/dev</code></pre><p>4.2.2 将本地项目添加到远程的仓库 ※</p><pre><code>1.远程建立仓库,并克隆到本地(例如:storeHouse)2.将本地的项目拷贝到storeHouse文件中3.使用 git init 命令4.使用 $ git remote add origin git@github.com:WayThought/blog.git 5. git add . 6. git commit 7. git push </code></pre><p>4.2.3<br>将本地分支推送到远程分支:(如果远程分支不存在则会自动创建分支)<br>git push origin 本地分支名:远程分支名<br>4.2.4 远程分支版本的回退</p><pre><code>切换到本地分支对应着的远程分支git push origin HEAD --force #远程提交回退</code></pre><p>4.2.5 删除远程分支</p><pre><code>git push origin \-\-delete 远程分支名</code></pre><p>备注:如果删除远端分支后,合作的小伙伴需要git fetch -p  删除不存在的远程跟踪分支<br>4.2.6 强制覆盖分支 ※</p><pre><code>把本地的 develop 分支强制(-f)推送到远程 mastergit push origin develop:master -f</code></pre><p>4.3 补充：<br>查看本地分支与远端分支的差异：<br>git diff master..远程仓库名字/master</p><p>git tag 标签名 commitId  添加tag<br>git push origin 标签名  将本地tag推到远程</p><p>git tag -d 标签名 删除本地tag<br>git push origin –delete 标签名  删除远程tag</p><h4 id="5-0冲突"><a href="#5-0冲突" class="headerlink" title="5.0冲突"></a>5.0冲突</h4><h4 id="5-1常见冲突"><a href="#5-1常见冲突" class="headerlink" title="5.1常见冲突:"></a>5.1常见冲突:</h4><pre><code>第一种: 项目可以打开,报错-&gt;直接去找,对别人的改动要进行沟通决定是否要保留第二种: 项目打开失败git status 查看哪个文件冲突(一般是配置文件)open 路径 搜索&quot;===“,删除后没有恢复的话 说明删除错误了 -&gt;重新删除&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADCreating a new branch is quick &amp; simple.=======Creating a new branch is quick AND simple.&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1</code></pre><p>上面那个是HEAD分支的,下面这个是feature1分支,沟通后决定保留或删除</p><h4 id="5-2-pbxproj文件冲突"><a href="#5-2-pbxproj文件冲突" class="headerlink" title="5.2 pbxproj文件冲突"></a>5.2 pbxproj文件冲突</h4><p>比较麻烦的一种冲突,企业开发经常会遇到project.pbxproj文件冲突的问题,project.pbxproj文件主要包含了以下几项主要信息:</p><pre><code>1.工程文件关联信息, 如PBXBuildFile PBXFileReference2.组织结构分类信息, 如PBXGroup3.项目工程配置信息, 如XCBuildConfiguration XCConfigurationList</code></pre><p>解决办法:</p><pre><code>将冲突的地方,删除多余、添加必要的&quot;}&quot;,将格式恢复成上下没有冲突的代码格式。解决完全部冲突,代码应该可以正常编译了。如果还不能编译,说明恢复的格式不正确。</code></pre><h3 id="5-3-git-push-报以下错误"><a href="#5-3-git-push-报以下错误" class="headerlink" title="5.3 git push 报以下错误:"></a>5.3 git push 报以下错误:</h3><pre><code>错误error: RPC failed; result=22, HTTP code = 413fatal: The remote end hung up unexpectedlyfatal: The remote end hung up unexpectedly解决:第一种. 将http切换成ssh,在git的config中修改url( changed it to the SSH address, and everything resumed working flawlessly)第二种. 继续使用http,运行    git config http.postBuffer 524288000第三种。 git push -u origin 分支(这种没有亲自尝试过,可以试试)</code></pre><h3 id="6-0-为什么GitHub需要SSH-Key呢"><a href="#6-0-为什么GitHub需要SSH-Key呢" class="headerlink" title="6.0 为什么GitHub需要SSH Key呢"></a>6.0 为什么GitHub需要SSH Key呢</h3><p>因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。</p><h3 id="7-0-下载的工程带有submodule"><a href="#7-0-下载的工程带有submodule" class="headerlink" title="7.0 下载的工程带有submodule"></a>7.0 下载的工程带有submodule</h3><p>当使用git clone下来的工程中带有submodule时，初始的时候，submodule的内容并不会自动下载下来的。<br>此时，只需执行如下命令：</p><pre><code>git submodule update --init --recursive</code></pre><h3 id="8-0-修改已经push的commit的信息"><a href="#8-0-修改已经push的commit的信息" class="headerlink" title="8.0 修改已经push的commit的信息"></a>8.0 修改已经push的commit的信息</h3><p>1.查看提交的历史记录</p><pre><code>git log</code></pre><p>2.使用git rebase -i HEAD~3确定要修改哪些commit</p><pre><code>git rebase -i HEAD~3</code></pre><p>HEAD~3表示最近的3个，后面的3可以改成其他数字</p><pre><code>pick f429786 1pick 880cfbc 2pick c55cf56 3</code></pre><p>假如我们需要修改第2条commit的message, 点击”i”键进行INSERT,将<strong>pick</strong>修改为<strong>edit</strong>,然后保存退出</p><pre><code>pick f429786 1edit 880cfbc 2pick c55cf56 3</code></pre><p>3.先使用git commit –amend,再使用git rebase –continue修改每个edit的commit</p><p>4.使用以下命令强制更新远程服务器</p><pre><code>git push origin YourBranchName -f</code></pre><p>参考资料:<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/" target="_blank" rel="external">廖雪峰的博客</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;SVN: 集中式的版本控制系统. 本地只有文件,没有版本库,所有的代码只在服务器上有版本记录,如果要进行版本的回退,和一些tag操作,必须经过服务器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Git: 分布式版本控制系统,每个人电脑就有版本库.写完代码,先提交到本地的版本,让后提交到服务器上,最后每个电脑都有一个最新的代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git也要配置服务器, 但是服务器的作用, 只是作为一个中间桥梁供开发人员去同步代码用的.
git有机器强大的分支管理,把SVN等远远抛在了后面
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;1-远程仓库&quot;&gt;&lt;a href=&quot;#1-远程仓库&quot; class=&quot;headerlink&quot; title=&quot;1.远程仓库&quot;&gt;&lt;/a&gt;1.远程仓库&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;1.1 创建SSH Key. 在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。使用以下命令创建SSH Key：(替换成你的邮箱地址).&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ssh-keygen -t rsa -C &amp;quot;youremail@example.com&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;1.2 在用户主目录中找到.ssh目录,里面有id_rsa(私钥)和id_rea.pub(公钥),打开id_rea.pub并记录下来.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;1.3 登录GitHub,打开”Account settings”,”SSH Key”页面,添加Key,把id_rea.pub内容添加进去.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git需要在GitHup,OsChina,GitLabel中添加自己的公钥
由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的,GitHub只要知道了你的公钥,就可以在每台电脑上往GitHub推送了.
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>04-Code Review</title>
    <link href="http://waythought.duoshuo.com/2016/10/23/04-%E4%BB%A3%E7%A0%81%E5%AE%A1%E6%9F%A5%E6%B8%85%E5%8D%95/"/>
    <id>http://waythought.duoshuo.com/2016/10/23/04-代码审查清单/</id>
    <published>2016-10-23T11:35:16.000Z</published>
    <updated>2018-08-25T03:16:05.667Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Code-Review"><a href="#Code-Review" class="headerlink" title="Code Review"></a>Code Review</h2><h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><ul><li>1.在项目早起就能发现代码中的bug</li><li>2.项目统一代码风格,项目代码更容易维护</li><li>3.避免开发人员犯一些很常见,很普通的错误(可预测性检查)</li></ul><h4 id="常规项"><a href="#常规项" class="headerlink" title="常规项"></a>常规项</h4><ul><li>1.代码能够工作吗？它有没有实现预期的功能，逻辑是否正确等。</li><li>2.代码符合你遵循的编程规范吗？通常包括大括号的位置，变量名和函数名，行的长度，缩进，格式和注释等风格是否保持一致。</li><li>3.是否存在多余的或是重复的代码？</li><li>4.代码是否尽可能的模块化了？</li><li>5.是否有可以被替换的全局变量？</li><li>6.是否有被注释掉的代码？所有的注释是否是准确的?</li><li>7.健壮性：是否考虑线程安全；边界处理是否完整；数据的越界处理；被零除,有没有内存泄漏；逻辑是否健壮；循环引用（block中的self和weakSelf）<a id="more"></a></li></ul><h4 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h4><ul><li>1.所有的数据输入是否都进行了检查（检测正确的类型，长度，格式和范围）并且进行了编码？</li><li>2.在哪里使用了第三方工具，返回的错误是否被捕获？</li><li>3.输入的值是够进行了检查和编码？</li><li>4.无效的参数值是否能够处理？</li></ul><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>把使用清单作为你的起点，针对特定的使用案例，需要对其进行优化。一个比较棒的方式就是记录下那些在代码审查过程中临时发现的问题，有了这些数据，能够明确常犯的错误，然后可以量身定制一个审查清单。确保删除了那些没有出现过的错误。</p><h4 id="代码审查清单"><a href="#代码审查清单" class="headerlink" title="代码审查清单"></a>代码审查清单</h4><ul><li>1.基础: iOS规范指南</li><li>2.控件的创建尽量放到Setter和Getter中进行懒加载,不要写在viewDidLoad中</li><li>3.block中的self需要替换成weakSelf防止循环引用,形成好的习惯。</li><li>4.多余控件和控制器的删除。被注释掉的代码是否有必要保留？所有的注释是否是准确的?</li><li>5.base类中已经存在满足需求控件和方法不需要再重新定义(例如UITableView及其分页、刷新)</li><li>6.手动开启线程要谨慎。</li></ul><h4 id="获取认可并且保持更新"><a href="#获取认可并且保持更新" class="headerlink" title="获取认可并且保持更新"></a>获取认可并且保持更新</h4><p>基本规则是，清单上的人和条目都必须明确，而且，如果可能的话，对于一些条目你可以对其进行二元判断。这样可以防止判断的不一致。定期检查你的清单，以确保各条目仍然是有意义的。</p><h4 id="责任："><a href="#责任：" class="headerlink" title="责任："></a>责任：</h4><p>代码编写者，代码审核者共同对代码的质量承担责任。这样才能保证Code Review不是走过场.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Code-Review&quot;&gt;&lt;a href=&quot;#Code-Review&quot; class=&quot;headerlink&quot; title=&quot;Code Review&quot;&gt;&lt;/a&gt;Code Review&lt;/h2&gt;&lt;h4 id=&quot;目的&quot;&gt;&lt;a href=&quot;#目的&quot; class=&quot;headerlink&quot; title=&quot;目的&quot;&gt;&lt;/a&gt;目的&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;1.在项目早起就能发现代码中的bug&lt;/li&gt;
&lt;li&gt;2.项目统一代码风格,项目代码更容易维护&lt;/li&gt;
&lt;li&gt;3.避免开发人员犯一些很常见,很普通的错误(可预测性检查)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;常规项&quot;&gt;&lt;a href=&quot;#常规项&quot; class=&quot;headerlink&quot; title=&quot;常规项&quot;&gt;&lt;/a&gt;常规项&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;1.代码能够工作吗？它有没有实现预期的功能，逻辑是否正确等。&lt;/li&gt;
&lt;li&gt;2.代码符合你遵循的编程规范吗？通常包括大括号的位置，变量名和函数名，行的长度，缩进，格式和注释等风格是否保持一致。&lt;/li&gt;
&lt;li&gt;3.是否存在多余的或是重复的代码？&lt;/li&gt;
&lt;li&gt;4.代码是否尽可能的模块化了？&lt;/li&gt;
&lt;li&gt;5.是否有可以被替换的全局变量？&lt;/li&gt;
&lt;li&gt;6.是否有被注释掉的代码？所有的注释是否是准确的?&lt;/li&gt;
&lt;li&gt;7.健壮性：是否考虑线程安全；边界处理是否完整；数据的越界处理；被零除,有没有内存泄漏；逻辑是否健壮；循环引用（block中的self和weakSelf）&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
