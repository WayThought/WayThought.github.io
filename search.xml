<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[10- 上传App Store 报错 ERROR ITMS-90087:"Unsupported Architectures 解决办法]]></title>
    <url>%2F2018%2F01%2F30%2F10.%E4%B8%8A%E4%BC%A0App%20Store%20%E6%8A%A5%E9%94%99%20ERROR%20ITMS-90087-%20%22Unsupported%20Architectures%20%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%20%2F</url>
    <content type="text"><![CDATA[说明:有些第三方提供商为了方便开发者使用,经常把i386 x86_64 armv7 arm64 等几个平台合并到一起,但是上传App Store的时候需要将i386 x86_64两个平台删除后,才能正常审核。 一、几个重要概念 ARM:ARM处理器,特点是体积小、低功耗、低成本、高性能,所以几乎所有手机处理器都基于ARM,在嵌入式系统中应用广泛。 ARM处理器指令集: armv6 | armv7 | armv7s | arm64都是ARM处理器的指令集,这些指令集都是向下兼容的,例如armv7指令集兼容armv6,只是使用armv6的时候无法发挥出其性能,无法使用armv7的新特性,从而会导致程序执行效率没有那么高。i386 | x86_64是Mac处理器的指令集,i386是针对intel通用微处理器32架构的(虚拟机: iPhone4s iPhone5)。x86_64是针对x86架构的64位处理器(虚拟机: iPhone5S iPhone6 iPhone6S iPhone7 iPhone8 iPhoneX)。 目前iOS移动设备指令集 arm64：真机64位处理器需要本架构 iPhone5S(以及以上)｜ iPad Air｜ iPad mini2(iPad mini with Retina Display) armv7s：真机32位处理器需要本架构 iPhone5｜iPhone5C｜iPad4(iPad with Retina Display) armv7：真机32位处理器需要本架构 iPhone3GS｜iPhone4｜iPhone4S｜iPad｜iPad2｜iPad3(The New iPad)｜iPad mini｜iPod Touch 3G｜iPod Touch4 armv6 设备： iPhone, iPhone2, iPhone3G, 第一代、第二代 iPod Touch（一般不需要去支持） Xcode中指令集相关选项(Build Setting中) (1) ArchitecturesSpace-separated list of identifiers. Specifies the architectures (ABIs, processor models) to which the binary is targeted. When this build setting specifies more than one architecture, the generated binary may contain object code for each of the specified architectures. 指定工程被编译成可支持哪些指令集类型，而支持的指令集越多，就会编译出包含多个指令集代码的数据包，对应生成二进制包就越大，也就是ipa包会变大。 (2) Valid ArchitecturesSpace-separated list of identifiers. Specifies the architectures for which the binary may be built. During the build, this list is intersected with the value of ARCHS build setting; the resulting list specifies the architectures the binary can run on. If the resulting architecture list is empty, the target generates no binary. 限制可能被支持的指令集的范围，也就是Xcode编译出来的二进制包类型最终从这些类型产生，而编译出哪种指令集的包，将由Architectures与Valid Architectures（因此这个不能为空）的交集来确定，例如：比如，你的Valid Architectures设置的支持arm指令集版本有：armv7/armv7s/arm64，对应的Architectures设置的支持arm指令集版本有：armv7s，这时Xcode只会生成一个armv7s指令集的二进制包。再比如：将Architectures支持arm指令集设置为：armv7,armv7s，对应的Valid Architectures的支持的指令集设置为：armv7s,arm64，那么此时，XCode生成二进制包所支持的指令集只有armv7s 在Xcode6.1.1里的 Valid Architectures 设置里， 默认为 Standard architectures(armv7,arm64),如果你想改的话，自己在other中更改。 原因解释如下： 使用 standard architectures (including 64-bit)(armv7,arm64) 参数，则打的包里面有32位、64位两份代码，在iPhone5s（ iPhone5s的cpu是64位的 ）下，会首选运行64位代码包， 其余的iPhone（ 其余iPhone都是32位的,iPhone5c也是32位 ），只能运行32位包，但是包含两种架构的代码包，只有运行在ios6，ios7系统上。这也就是说，这种打包方式，对手机几乎没要求，但是对系统有要求，即ios6以上。而使用 standard architectures (armv7,armv7s) 参数， 则打的包里只有32位代码， iPhone5s的cpu是64位，但是可以兼容32位代码，即可以运行32位代码。但是这会降低iPhone5s的性能。 其余的iPhone对32位代码包更没问题， 而32位代码包，对系统也几乎也没什么限制。 所以总结如下： 要发挥iPhone5s的64位性能，就要包含64位包，那么系统最低要求为ios6。 如果要兼容ios5以及更低的系统，只能打32位的包，系统都能通用，但是会丧失iPhone5s的性能。 （3）Build Active Architecture Only 指定是否只对当前连接设备所支持的指令集编译 当其值设置为YES，这个属性设置为yes，是为了debug的时候编译速度更快，它只编译当前的architecture版本，而设置为no时，会编译所有的版本。 编译出的版本是向下兼容的，连接的设备的指令集匹配是由高到低（arm64 &gt; armv7s &gt; armv7）依次匹配的。比如你设置此值为yes，用iphone4编译出来的是armv7版本的，iphone5也可以运行，但是armv6的设备就不能运行。 所以，一般debug的时候可以选择设置为yes，release的时候要改为no，以适应不同设备。 1）Architectures: armv7, armv7s, arm64ValidArchitectures: armv6, armv7s, arm64生成二进制包支持的指令集： arm64 2）Architectures: armv6, armv7, armv7sValid Architectures: armv6, armv7s, arm64生成二进制包支持的指令集： armv7s 3）Architectures: armv7, armv7s, arm64Valid Architectures: armv7，armv7s 这种情况是报错的，因为允许使用指令集中没有arm64。 注：如果你对ipa安装包大小有要求，可以减少安装包的指令集的数量，这样就可以尽可能的减少包的大小。当然这样做会使部分设备出现性能损失，当然在普通应用中这点体现几乎感觉不到，至少不会威胁到用户体检。 三、制作静态库.a是指令集选择 现在回归到正题，如何制作一个“没有问题”的.a静态库，通过以上信息了解到，当我们做App的时候，为了追求高效率，并且减小包的大小，Build Active Architecture Only设置成YES，Architectures按Xcode默认配置就可以，因为arm64向前兼容。但制作.a静态库就不同了，因为要保证兼容性，包括不同iOS设备以及模拟器运行不出错，所以结合当前行业情况，要做到最大的兼容性。 四、iOS使用lipo 拆分 合并 .a(我们用CBAiDirectSDK.framework为例子) 将需要拆分和合并的.framework和.a文件拷贝出去(保留原文件,拆分合并完直接替换掉) 终端cd到拷贝的CBAiDirectSDK.framework路径,依次查看所有需要合并的lib库所支持的框架类型。 lipo -info CBAiDirectSDK * 输出: Architectures in the &lt;font color=#DC143C size=4 face=&quot;黑体&quot;&gt;fat&lt;/font&gt; file: CBAiDirectSDK are: i386 x86_64 armv7 arm64 * 解释:看到红色的fat了吗,fat file表示这个库里面合并了多于1个框架。 将lib库拆分出armv7、arm64类型的.a: lipo CBAiDirectSDK -thin armv7 -output CBAiDirectSDK_armv7 lipo CBAiDirectSDK -thin arm64 -output CBAiDirectSDK_arm64 找到CBAiDirectSDK_armv7文件,查看下信息(CBAiDirectSDK_arm64相同) lipo -info CBAiDirectSDK_armv7 * 输出:Non-fat file: CBAiDirectSDK_armv7 is architecture: armv7 合并成最终的静态库 lipo -create -output CBAiDirectSDK CBAiDirectSDK_armv7 CBAiDirectSDK_arm64 查看合成支持的框架类型 lipo -info CBAiDirectSDK * 输出: Architectures in the fat file: CBAiDirectSDK are: armv7 arm64 最后替换掉原项目中的CBAiDirectSDK.framework]]></content>
  </entry>
  <entry>
    <title><![CDATA[09- iOS证书申请和使用详情]]></title>
    <url>%2F2018%2F01%2F25%2F09.iOS%E8%AF%81%E4%B9%A6%E7%94%B3%E8%AF%B7%E5%92%8C%E4%BD%BF%E7%94%A8%E8%AF%A6%E6%83%85%2F</url>
    <content type="text"><![CDATA[由于公司近期开始接入个推推送,自己也没有详细的总结过iOS证书相关,今天刚好有时间,也就当个记录吧 一. App ID(bundle idengtifier)App ID一这是每个应用的独立标识,应该是和Xcode中的Bundle Identifier是一致(Explicit)的或匹配(Wildcard)的。App ID字符串通常以反域名格式Company Identifier 例如 “com.apple.garageband”App ID全名会被追加Application Identifier(一般为TeamID),分为两类: * Explicit App ID：唯一的App ID，用于唯一标识一个应用程序。 * Wildcard App ID：含有通配符的App ID，用于标识一组应用程序。 二. Certification 证书 (.cer)1.开发者证书证书是对电脑开发资格的认证,每个开发者账号有一套(2两种): 1) Developer Certification(开发证书)安装在电脑上提供权限: 开发人员通过设备进行真机调试。可以生成副本供多台电脑安装; 2) Distribution Certification(发布证书)安装在电脑提供发布iOS程序的权限: 开发人员可以制做测试版和发布版的程序。不可生成副本,仅有配置该证书的电脑才可使用。 2.推送证书推送证书也分为开发和生产两种,类型分别为APNs Development iOS, APNs Production iOS,该证书在appID配置中创建生成,安装在开发者电脑上。 三. Devices苹果的测试证书、发布证书以及推送证书都有对应的Provisioning Profile文件,来验证当前开发者、当前应用、是否能在该真机设备上测试、安装或者运行。所以,需要对该真机设备的UDID进行注册,生成对应的Provisioning Profiles 四. Provisioning Profiles(授权证书 PP描述文件)授权文件是对设备iPhone、iPad、iPod Touch的授权,文件内记录的是设备的UDID和程序的App ID,也就是被授权的设备即Xcode可以安装或者调试Bundle identifier与授权文件中记录的App id对应的程序 1)Developer Provisioning Profile(开发授权文件)在装有开发证书或者开发证书副本的电脑上使用,开发人员选择该授权文件通过电脑将程序安装到授权文件记录的设备中,也就是可以进行真机调试 2)Distribution Provisioning Profile(发布授权文件)在装有发布证书的电脑上制作测试版本和发布版本的程序。]]></content>
  </entry>
  <entry>
    <title><![CDATA[08-.gitignore相关]]></title>
    <url>%2F2017%2F10%2F27%2F08.gitignore%2F</url>
    <content type="text"><![CDATA[1.作用:利用.gitignore过滤文件，如编译过程中的中间文件，等等，这些文件不需要被追踪管理。内容参考gitHub 2.gitignore无效，不能过滤某些文件 现象：在.gitignore添加file1文件，以过滤该文件，但是通过git status查看仍显示file1文件的状态。 原因：在git库中已存在了这个文件，之前push提交过该文件。.gitignore文件只对还没有加入版本管理的文件起作用，如果之前已经用git把这些文件纳入了版本库，就不起作用了 解决：需要在git库中删除该文件，并更新。然后再次git status查看状态，file1文件不再显示状态。]]></content>
  </entry>
  <entry>
    <title><![CDATA[07-JavaScript && iOS原生交互]]></title>
    <url>%2F2017%2F10%2F21%2F07-JavaScript%20%26%26%20iOS%E5%8E%9F%E7%94%9F%E4%BA%A4%E4%BA%92%2F</url>
    <content type="text"><![CDATA[JavaScript &amp;&amp; iOS原生交互JavaScript &amp;&amp; iOS原生交互第三方框架:WebViewJavascriptBridge 1. 简单用法(OC执行JS)UIWebView在webViewDidFinishLoad里使用 - (nullable NSString *)stringByEvaluatingJavaScriptFromString:(NSString *)script; // 获取当前页面的title NSString *title = [webview stringByEvaluatingJavaScriptFromString:@&quot;document.title&quot;]; // 获取当前页面的url NSString *url = [webview stringByEvaluatingJavaScriptFromString:@&quot;document.location.href&quot;]; 2. OC执行JS &amp;&amp; JS执行OC2.1 JavaScriptCore:iOS7后引用,里面包含常见的对象及协议如下: JSContext：给JavaScript提供运行的上下文环境,通过-evaluateScript:方法就可以执行一JS代码 JSValue：JavaScript和Objective-C数据和方法的桥梁,封装了JS与ObjC中的对应的类型，以及调用JS的API等 JSManagedValue：管理数据和方法的类 JSVirtualMachine：处理线程相关，使用较少 JSExport：这是一个协议，如果采用协议的方法交互，自己定义的协议必须遵守此协议 注: JSContext 和 JSValue : JSVirtualMachine 为JavaScript的运行提供了底层资源,JSContext为JavaScript其提供着运行环境,通过evaluateScript方法就可以执行一段JavaScript脚本,并且如果其中有方法,变量等信息都会被存储在其中以便在需要的时候使用。而JSContext的创建都是基于JSVirtualMachine(initwithVirtualMachine:),如果使用init进行初始化,那么在其内部会自动创建一个新的JSVirtualMachine对象然后调用前边的初始化方法。JSValue是JSContext执行后的返回结果,封装了JS与ObjC中的对应的类型,可以方便的在两种类型之间转换,可以说是JavaScript和Object-C之间互换的桥梁 Objective-C type | JavaScript type ——————–+——————— nil | undefined NSNull | null NSString | string NSNumber | number, boolean NSDictionary | Object object NSArray | Array object NSDate | Date object NSBlock (1) | Function object (1) id (2) | Wrapper object (2) Class (3) | Constructor object (3) JSVirtualMachine : “A JSVirtualMachine instance represents a self-contained environment for JavaScript execution.”，这段话是官方文档中对JSVirtualMachine的定义，我们使用JSVirtualMachine的目的主要有两个：支持JavaScript并发执行，管理用于衔接JavaScript 与 OC(Swift) 代码的对象的内存。 #####2.1 简单直接调用JS代码 // 一个JSContext对象 self.jsContext = [[JSContext alloc] init]; // jscontext可以直接执行JS代码。 [self.jsContext evaluateScript:@&quot;var num = 10&quot;]; [self.jsContext evaluateScript:@&quot;var squareFunc = function(value) { return value * 2 }&quot;]; // 计算正方形的面积 JSValue *square = [self.jsContext evaluateScript:@&quot;squareFunc(num)&quot;]; // 也可以通过下标的方式获取到方法 JSValue *squareFunc = self.jsContext[@&quot;squareFunc&quot;]; // 将参数传进去来调用方法 JSValue *value = [squareFunc callWithArguments:@[@&quot;20&quot;]]; NSLog(@&quot;%@&quot;, square.toNumber); NSLog(@&quot;%@&quot;, value.toNumber); #####2.2 快读调用Block,可以传入参数 JSContext *context = [[JSContext alloc] init]; context[@&quot;log&quot;] = ^() { NSLog(@&quot;+++++++Begin Log+++++++&quot;); // 获取当前参数列表 NSArray *args = [JSContext currentArguments]; for (JSValue *jsVal in args) { NSLog(@&quot;%@&quot;, jsVal); } // 获取当前调用该方法的对象 JSValue *this = [JSContext currentThis]; NSLog(@&quot;this: %@&quot;,this); NSLog(@&quot;-------End Log-------&quot;); }; [context evaluateScript:@&quot;log(&apos;ider&apos;, [7, 21], { hello:&apos;world&apos;, js:100 });&quot;]; // // Output: // +++++++Begin Log+++++++ // ider // 7,21 // [object Object] // this: [object GlobalObject] // -------End Log------- 3.协议、模型实现事先和前端wap协商格式、定义方法的名字和参数的顺序 3.1 定义一个模型 KNOCJSModel 3.2 在该模型实现以下协议(协议中定义需要暴露给js的属性和方法) @protocol KNOCJSObjectProtocol &lt;JSExport&gt; // 在JS中调用时，函数名应该为showAlertMsg(arg1, arg2) // 这里是只两个参数的。 - (void)showAlert:(NSString *)title msg:(NSString *)msg; // JS调用Oc，然后在OC中通过调用JS方法来传值给JS。 - (void)jsCallObjcAndObjcCallJsWithDict:(NSDictionary *)params; @end typedef void (^KNOCJSModelDetailAlertBlock)(NSString * title, NSString *message); typedef void (^KNOCJSModelDetailCallJsBlock)(NSDictionary *dic); @interface ObjCModel : NSObject &lt;JavaScriptObjectiveCDelegate&gt; @property (nonatomic, copy) KNOCJSModelDetailAlertBlock alertBlock; @property (nonatomic, copy) KNOCJSModelDetailCallJsBlock callJsBlock; @end 3.3实现模型 @implementation ObjCModel - (void)showAlert:(NSString *)title msg:(NSString *)msg { if (self. alertBlock) { self.alertBlock(title, msg) } } - (void)jsCallObjcAndObjcCallJsWithDict:(NSDictionary *)params { if (self. callJsBlock) { self. callJsBlock(params); } } @end 3.4 在控制器中webView加载完成的代理中,给JSContext注入模型 #pragma mark - UIWebViewDelegate - (void)webViewDidFinishLoad:(UIWebView *)webView { JSContext *context = [webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;]; // 通过模型调用方法，这种方式更好些。 KNOCJSModel *objectModel = [[KNOCJSModel alloc] init]; context[@&quot;native&quot;] = objectModel; __weak typeof(self) weakSelf = self objectModel.alertBlock = ^(NSString *title, NSString *msg) { dispatch_async(dispatch_get_main_queue(), ^{ UIAlertView *alert = [[UIAlertView alloc] initWithTitle:title message:msg delegate:nil cancelButtonTitle:@&quot;Ok&quot; otherButtonTitles:nil, nil]; [alert show]; }); }; objectModel.callJsBlock = ^(NSDictionary *dic) { dispatch_async(dispatch_get_main_queue(), ^{ // 第一种方式 JSValue *jsParamFunc = context[@&quot;jsParamFunc&quot;]; [jsParamFunc callWithArguments:@[@{@&quot;age&quot;: @10, @&quot;name&quot;: @&quot;lili&quot;, @&quot;height&quot;: @158}]]; // 第二种方式 NSString *alertUserInfo = [NSString stringWithFormat:@&quot;jsParamFunc(&apos;%@&apos;,&apos;%@&apos;,&apos;%@&apos;)&quot;, @10, @&quot;lili&quot;, @158]; [context evaluateScript:alertUserInfo]; }); }; context.exceptionHandler = ^(JSContext *context, JSValue *exceptionValue) { context.exception = exceptionValue; NSLog(@&quot;异常信息：%@&quot;, exceptionValue); }; } 3.5 在html中的body中添加以下代码:(这里要和wap端统一好)‘native’ &lt;div style=&quot;margin-top: 100px&quot;&gt; &lt;h1&gt;Test how to use objective-c call js&lt;/h1&gt; &lt;input type=&quot;button&quot; value=&quot;Call ObjC system alert&quot; onclick=&quot;native.showAlertMsg(&apos;js title&apos;, &apos;js message&apos;)&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;input type=&quot;button&quot; value=&quot;Call ObjC func with JSON and ObjC call js func to pass args.&quot; onclick=&quot;native.jsCallObjcAndObjcCallJsWithDict({&apos;name&apos;: &apos;testname&apos;, &apos;age&apos;: 10, &apos;height&apos;: 170})&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;span id=&quot;jsParamFuncSpan&quot; style=&quot;color: red; font-size: 50px;&quot;&gt;&lt;/span&gt; &lt;/div&gt; 也可自己在控制器中执行js代码调用 - (void)useJSExprot { JSContext *context = [self.webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;]; KNOCJSModel *objectModel = [[KNOCJSModel alloc] init]; context[@&quot;native&quot;] = objectModel; [context evaluateScript:@&quot;objectModel.showAlertMsg()&quot;] } 保留: 1.在Block内都不要直接使用其外部定义的JSContext对象或者JSValue，应该将其当做参数传入到Block中，或者通过JSContext的类方法+ (JSContext *)currentContext;来获得。否则会造成循环引用使得内存无法被正确释放。 2.如果js端的方法是这样的func viewDetailLoginNamePassWord(String name, String passWord) { } 我们可以用第一种: (void)viewDetailLoginName:(NSString *)loginNamePassWord:(NSString *)passWord; 第二种:JSExportAs(viewDetailLoginNamePassWord, -(void)viewDetailLoginNamePassWord:(NSString )loginName psd:(NSString )psd;)http://www.jianshu.com/p/fad8c7844d3e]]></content>
  </entry>
  <entry>
    <title><![CDATA[06-Objectview-C 中变量采用@property的各个关键字的含义]]></title>
    <url>%2F2017%2F10%2F17%2F06-Objectview-C%20%E4%B8%AD%E5%8F%98%E9%87%8F%E9%87%87%E7%94%A8%40property%E7%9A%84%E5%90%84%E4%B8%AA%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%90%AB%E4%B9%89%2F</url>
    <content type="text"><![CDATA[Objectview-C 中变量采用@property的各个关键字的含义1.@property的本质是什么?@property = ivar + getter + setter“属性”(property) = 实例变量 + 存取方法OC2.0开始,系统提供了自动生成设置变量值得方法或获取变量值得方法,让我们有更多的精力放在程序的业务逻辑上 2.ARC下,不显示指定任何属性性关键字时,默认的关键字有哪些?对于基本数据类型默认关键字是:atomic,readwrite,assign 对于普通的OC对象:atomic,readwrite,strong 3.copy关键字3.1 NSString,NSArray,NSDictionary等等经常使用copy关键字,是因为他们有对应的可变类型:NSMutableString、NSMutableArray、NSMutableDictionary；是对应的子类,他们之间可能进行赋值操作,为确保对象中的字符串值不会无意间变动,应该在设置新属性值时拷贝一份 3.2 block 也经常使用copy关键字,这是从MRC遗留下的&quot;传统&quot;,在MRC中,方法内部的block是在栈区的,使用copy可以把它放在堆区;ARC中写不写都行: 对于block使用copy还是strong效果是一样的,但写上copy能够提醒我们:编译器自动对block进行了copy操作。 3.3 小试牛刀: 这个写法会出什么问题 @property (copy) NSMutableArray *array; 3.3.1 添加,删除,修改数组内的元素的时候,程序会因为找不到对应的方法而崩溃,因为copy是复制的一个不可变的NSArray的对象 3.3.2 默认关键字是atomic属性会严重影响性能 4. weak 关键字4.1 在ARC中,有可能出现循环引用的时候,往往要通过让其中一端使用weak来解决,比如delegate代理 4.2 自身已经对它进行一次强引用,没有必要再强引用一次,此时也会使用weak,自定义IBOutlet控件的属性一般也使用weak。 5. assign只会执行基本类型的简单赋值操作,既不保留新值,也不释放旧值。 6. retain释放旧的对象，将旧对象的值赋予输入对象，再提高输入对象的索引计数为1 7.nonnull:不能为空,用来修饰属性,或者方法的参数,方法的返回值,不适用于assign属性,因为他是专门用来修饰指针的 @property (nonatomic, copy, nonnull) NSString *name; @property (nonatomic, copy) NSString * _Nonnull name; @property (nonatomic, copy) NSString * __nonnull name; 8.nullable:表示可以为空,代码提示会告诉你这个谁能够是可以为空的 @property (nonatomic, copy, nullable) NSString *name; @property (nonatomic, copy) NSString *_Nullable name; @property (nonatomic, copy) NSString *__nullable name; 9.null_resettable:表示get方法不能返回为空,set方法可以为空 ⚠️⚠️⚠️ 必须重写该属性的get方法,保证返回值不为空 tan @property(nonatomic,strong,null_resettable) NSNumber * number;(只有这一种方式) 10.null_unspecified表示不确定是否为空,使用方式有三种: @property(nonatomic,strong) NSNumber *_Null_unspecified height; @property(nonatomic,strong) NSNumber *__null_unspecified height; @property(nonatomic,strong,null_unspecified) NSNumber * height;]]></content>
  </entry>
  <entry>
    <title><![CDATA[05-git教程]]></title>
    <url>%2F2017%2F07%2F07%2F05-git%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[SVN: 集中式的版本控制系统. 本地只有文件,没有版本库,所有的代码只在服务器上有版本记录,如果要进行版本的回退,和一些tag操作,必须经过服务器 Git: 分布式版本控制系统,每个人电脑就有版本库.写完代码,先提交到本地的版本,让后提交到服务器上,最后每个电脑都有一个最新的代码 git也要配置服务器, 但是服务器的作用, 只是作为一个中间桥梁供开发人员去同步代码用的. git有机器强大的分支管理,把SVN等远远抛在了后面 1.远程仓库 1.1 创建SSH Key. 在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。使用以下命令创建SSH Key：(替换成你的邮箱地址). $ ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 1.2 在用户主目录中找到.ssh目录,里面有id_rsa(私钥)和id_rea.pub(公钥),打开id_rea.pub并记录下来. 1.3 登录GitHub,打开”Account settings”,”SSH Key”页面,添加Key,把id_rea.pub内容添加进去. git需要在GitHup,OsChina,GitLabel中添加自己的公钥 由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的,GitHub只要知道了你的公钥,就可以在每台电脑上往GitHub推送了. 1.4 添加远程库 在GitHub上创建仓库,使用下面命令,把这个远程的仓库与本地已有的仓库进行关联,之后就可以把本地仓库的内容推送到GitHub仓库了,注意是SSH的,传输相比http稳定 cd 到本地文件 $ git remote add origin git@github.com:WayThought/blog.git git remote 查看远程库的信息 $ git remote origin或者，用git remote -v显示更详细的信息： 1.5 从远程库克隆(当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。) cd 到本地文件 $ git clone git@github.com:WayThought/blog.git 这样就把远程的仓库克隆到了本地 2.本地分支管理git status: 查看文件的状态 git add : 提交有修改的文件,由工作区到暂存区 git add 文件名 添加指定修改的文件到暂存区 git add . 添加当前目录所有有修改的文件到暂存区 git commit : 提交暂存区的文件到本地版本库 git commit -m &quot;注释&quot; 文件名 提交指定的文件到本地仓库 git commit -m &quot;注释&quot; 提交所有的文件到本地仓库 (需要提交的改动文件,必须先add加到缓存区,再commit到版本区) git pull和push命令是本地仓库和远程仓库(服务器)打交道的,一般在push之前都会先pull下代码,如果有冲突,解决完冲突再push git pull 从服务器上更新代码到本地仓库,切换到本地需要提交的分支(dev) git pull origin dev 把服务器远程仓库更新的代码拉到本地仓库 git push origin dev 把本地仓库的代码更新推送到服务器上 创建与合并分支(当前分支为master) git branch 查看当前分支 git branch dev origin/dev 切换到分支dev git checkout dev 切换到分支dev git checkout -b dev 创建dev分支,然后切换到dev分支 git merge dev 把dev的工作内容合并到master上(分支A合并分支B,与分支B合并分支A是一样的) 3.版本回退git log 显示历史记录(写周报或者查看版本号) git reflog 来记录你的每一次命令(版本回退后,可以找到上一个版本的commit id ) git reset --hard HEAD^ 回退到上一个版本 git reset --hard HEAD^^ 回退到上上个版本 git reset --hard HEAD 版本号 回退到指定的版本 注: 如何找回删除的分支 3.1 通过git reflog 命令找到我们需要恢复的信息对应的commit_id (根据log 提交的日期时间) 3.2 通过git branch 新分支名字 对应的commit_id 来建立一个新的分支,吧丢失的东西恢复到新分支上 4.补充:4.1 常用命令: git config user.name 查看用户名 git config user.email 查看邮箱地址 git config –global user.name “Your Name” 提交名字 git config –global user.email you@example.com 提交邮箱 git co -- &lt;file&gt; # 抛弃工作区修改 git co . # 抛弃工作区修改 git rm &lt;file&gt; # 从版本库中删除文件 git rm &lt;file&gt; --cached # 从版本库中删除文件，但不删除文件 git reset &lt;file&gt; # 从暂存区恢复到工作文件 git reset -- . # 从暂存区恢复到工作文件 git reset --hard # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改 git stash list git stash pop 恢复的同时把stash内容也删了 git checkout -- readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销 git checkout -- . 把工作区的修改全部撤销 (版本相同的两个分支)未add和commit的内容如果checkout另一个分支会带过去 可以来回切换 4.2 常见问题: 4.2.1 git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接： $ git branch --set-upstream dev origin/dev 4.2.2 将本地项目添加到远程的仓库 1.远程建立仓库,并克隆到本地(例如:storeHouse) 2.将本地的项目拷贝到storeHouse文件中 3.使用 git init 命令 4.使用 $ git remote add origin git@github.com:WayThought/blog.git 5. git add . 6. git commit 7. git push 4.2.3 将本地分支推送到远程分支:(如果远程分支不存在则会自动创建分支)git push origin 本地分支名:远程分支名4.2.4 远程分支版本的回退 切换到本地分支对应着的远程分支 git push origin HEAD --force #远程提交回退 4.2.5 删除远程分支git push origin –delete 远程分支名 4.2.6 强制覆盖分支git push origin develop:master -f把本地的 develop 分支强制(-f)推送到远程 master 4.3 补充：查看本地分支与远端分支的差异：git diff master..远程仓库名字/master4.4 将本地分支推送到远端服务器：git push 远程仓库名字 分支名字4.4 寻找回退的commit-id(后悔药)git reflog ea34578 HEAD@{0}: reset: moving to HEAD^3628164 HEAD@{1}: commit: append GPLea34578 HEAD@{2}: commit: add distributed做完后面的操作的形成前面的commit-id 5.0冲突5.1常见冲突:第一种: 项目可以打开,报错-&gt;直接去找,对别人的改动要进行沟通决定是否要保留 第二种: 项目打开失败 git status 查看哪个文件冲突(一般是配置文件) open 路径 搜索&quot;===“,删除后没有恢复的话 说明删除错误了 -&gt;重新删除 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD Creating a new branch is quick &amp; simple. ======= Creating a new branch is quick AND simple. &gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1 上面那个是HEAD分支的,下面这个是feature1分支,沟通后决定保留或删除 5.2 pbxproj文件冲突比较麻烦的一种冲突,企业开发经常会遇到project.pbxproj文件冲突的问题,project.pbxproj文件主要包含了以下几项主要信息: 1.工程文件关联信息, 如PBXBuildFile PBXFileReference 2.组织结构分类信息, 如PBXGroup 3.项目工程配置信息, 如XCBuildConfiguration XCConfigurationList 解决办法: 1. 1.1 笨方法1: 由于删除自己的修改的部分还是没有办法打开工程,所以要将上一个版本的project.pbxproj文件导出来，替换掉现有的project.pbxproj文件,但是添加到工程中的文件不见了,后来其实在工程里面看不到了而已,在对应文件目录还是能找到的,只要将这些文件拖一遍到工程里就ok了,(注意看下工程的Compile Sources,有时候会不显示添加的类) 1.2 笨方法2: 将project.pbxproj文件文件中一个版本的的冲突都删除掉,根据编译报的错误去添加对应的类(注意不要重复添加),在对应文件目录还是能找到的,只要将这些文件拖一遍到工程里就ok了 2.预防:需要增加文件时先增加完空文件后立刻check一次，让别人每次改动 pbxproj的时候改动之前check一次，保证有交叉时间是可能性最小 3.将不同分支导致的对象进行重新排序,先排序冲突里面相同的对象,然后是重命名或移动了的对象,最后是两边各自新增的对象,(根据sourceCode进行排序) 5.3 git push 报以下错误:错误 error: RPC failed; result=22, HTTP code = 413 fatal: The remote end hung up unexpectedly fatal: The remote end hung up unexpectedly 解决: 第一种. 将http切换成ssh,在git的config中修改url( changed it to the SSH address, and everything resumed working flawlessly) 第二种. 继续使用http,运行 git config http.postBuffer 524288000 第三种。 git push -u origin 分支(这种没有亲自尝试过,可以试试) 6.0 建议项目开发的时候 可以单独建立一个分支dev_x 并行发开人员的每天或者几天合并下代码,合并到dev_x 比较方便,避免最后批量合并代码 参考资料:廖雪峰的博客]]></content>
  </entry>
  <entry>
    <title><![CDATA[04-Code Review]]></title>
    <url>%2F2017%2F06%2F21%2F04-%E4%BB%A3%E7%A0%81%E5%AE%A1%E6%9F%A5%E6%B8%85%E5%8D%95%2F</url>
    <content type="text"><![CDATA[Code Review目的 1.在项目早起就能发现代码中的bug 2.项目统一代码风格,项目代码更容易维护 3.避免开发人员犯一些很常见,很普通的错误(可预测性检查) 常规项 1.代码能够工作吗？它有没有实现预期的功能，逻辑是否正确等。 2.代码符合你遵循的编程规范吗？通常包括大括号的位置，变量名和函数名，行的长度，缩进，格式和注释等风格是否保持一致。 3.是否存在多余的或是重复的代码？ 4.代码是否尽可能的模块化了？ 5.是否有可以被替换的全局变量？ 6.是否有被注释掉的代码？所有的注释是否是准确的? 7.健壮性：是否考虑线程安全；边界处理是否完整；数据的越界处理；被零除,有没有内存泄漏；逻辑是否健壮；循环引用（block中的self和weakSelf） 安全 1.所有的数据输入是否都进行了检查（检测正确的类型，长度，格式和范围）并且进行了编码？ 2.在哪里使用了第三方工具，返回的错误是否被捕获？ 3.输入的值是够进行了检查和编码？ 4.无效的参数值是否能够处理？ 优化把使用清单作为你的起点，针对特定的使用案例，需要对其进行优化。一个比较棒的方式就是记录下那些在代码审查过程中临时发现的问题，有了这些数据，能够明确常犯的错误，然后可以量身定制一个审查清单。确保删除了那些没有出现过的错误。 代码审查清单 1.基础: iOS规范指南 2.控件的创建尽量放到Setter和Getter中进行懒加载,不要写在viewDidLoad中 3.block中的self需要替换成weakSelf防止循环引用,形成好的习惯。 4.多余控件和控制器的删除。被注释掉的代码是否有必要保留？所有的注释是否是准确的? 5.base类中已经存在满足需求控件和方法不需要再重新定义(例如UITableView及其分页、刷新) 6.手动开启线程要谨慎。 获取认可并且保持更新基本规则是，清单上的人和条目都必须明确，而且，如果可能的话，对于一些条目你可以对其进行二元判断。这样可以防止判断的不一致。和你的团队分享这份清单并且让他们认同你的清单的内容是个好主意。同样的，要定期检查你的清单，以确保各条目仍然是有意义的。 责任：代码编写者，代码审核者共同对代码的质量承担责任。这样才能保证Code Review不是走过场，其中代码编写者承担主要责任，代码审核者承担次要责任。]]></content>
  </entry>
  <entry>
    <title><![CDATA[03-iOS单元测试]]></title>
    <url>%2F2017%2F06%2F21%2F03-iOS%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[单元测试我是从去年开始写单元测试的,平常也只是使用测试一下接口的测试,最近有时间网上查找下了资料总结一下,也是有个归纳吧 单元测试简介 单元测试是指开发者编写代码,检测代码。合理的利用单元测试可以提高软件的质量 代码检测通常需要预先设置边界条件,因为UI测试的时候,很多边界条件不容易满足。主要针对业务逻辑进行测试,不适合做UI的测试。 MVVM的设计模式,把几乎所有重要的业务逻辑全部封装在视图模型中,通过单元测试就很方便检测条件以及代码质量。 什么方法或者函数需要测试1.私有方法不需要测试,面向对象有一个原则:开闭原则! 暴露在.h中的方法需要测试, 2. 所有跟UI有关的都不需要测试,有UI的交互。MVVM 把小的业务逻辑封装出来,变成可以测试的代码,让程序更加健壮。 3.一般而言,代码的覆盖度大概在50% ~ 70% 苹果自带的XCTest/** 单元测试开始前调用 */ - (void)setUp { [supersetUp]; // Put setup code here. This method is called before the invocation of each test method in the class. } /** 单元测试结束前调用 */ - (void)tearDown { // Put teardown code here. This method is called after the invocation of each test method in the class. [supertearDown]; } /** 测试代码可以写到以test开头的方法中 并且test开头的方法左边会生成一个菱形图标，点击即可运行检测当前test方法内的代码 */ - (void)testExample { // This is an example of a functional test case. // Use XCTAssert and related functions to verify your tests produce the correct results. } /** 测试性能 */ - (void)testPerformanceExample { // This is an example of a performance test case. [selfmeasureBlock:^{ // 测量执行时间的代码放到这里 // Put the code you want to measure the time of here. }]; } 断言命令XCTFail(format…) 生成一个失败的测试； XCTAssertNil(a1, format…)为空判断，a1为空时通过，反之不通过； XCTAssertNotNil(a1, format…)不为空判断，a1不为空时通过，反之不通过； XCTAssert(expression, format…)当expression求值为TRUE时通过； XCTAssertTrue(expression, format…)当expression求值为TRUE时通过； XCTAssertFalse(expression, format…)当expression求值为False时通过； XCTAssertEqualObjects(a1, a2, format…)判断相等，[a1 isEqual:a2]值为TRUE时通过，其中一个不为空时，不通过； XCTAssertNotEqualObjects(a1, a2, format…)判断不等，[a1 isEqual:a2]值为False时通过， XCTAssertEqual(a1, a2, format…)判断相等（当a1和a2是 C语言标量、结构体或联合体时使用,实际测试发现NSString也可以）； XCTAssertNotEqual(a1, a2, format…)判断不等（当a1和a2是 C语言标量、结构体或联合体时使用）； XCTAssertEqualWithAccuracy(a1, a2, accuracy, format…)判断相等，（double或float类型）提供一个误差范围，当在误差范围（+/-accuracy）以内相等时通过测试； XCTAssertNotEqualWithAccuracy(a1, a2, accuracy, format…) 判断不等，（double或float类型）提供一个误差范围，当在误差范围以内不等时通过测试； XCTAssertThrows(expression, format…)异常测试，当expression发生异常时通过；反之不通过；（很变态） XCTAssertThrowsSpecific(expression, specificException, format…) 异常测试，当expression发生specificException异常时通过；反之发生其他异常或不发生异常均不通过； XCTAssertThrowsSpecificNamed(expression, specificException, exception_name, format…)异常测试，当expression发生具体异常、具体异常名称的异常时通过测试，反之不通过； XCTAssertNoThrow(expression, format…)异常测试，当expression没有发生异常时通过测试； 单元测试的适用情况以及覆盖率对于测试用例覆盖度多少合适这个话题,也是仁者见仁智者见智,其实一个软件覆盖度在50%以上就可以成为一个健壮的软件了,要达到70%,80%这些已经非常难了,不过我们常见的一些第三方开源框架的测试用例覆盖率还是非常高的,例如AFNNetWorking的覆盖率高达87%,SDWebImage的覆盖率高达77%]]></content>
  </entry>
  <entry>
    <title><![CDATA[02-Mac上安装oh-my-zsh以及iterm2的使用]]></title>
    <url>%2F2017%2F06%2F21%2F02-mac%E4%B8%8A%E5%AE%89%E8%A3%85oh-my-zsh%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Mac上安装oh-my-zsh 1 克隆项目本地(Mac默认已经安装git) git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh 2 创建一个zsh的配置文件 cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc 备注:~ 代表:你的/home/用户名的目录,假设你的用户名是user,那么~/就是/home/user/. .是代表此目录本身,但是一般可以不写,所以cd ~/. 和 cd ~ 和cd ~/效果是一样的.但是.后面有东西又是另外一个问题,点在文件名头部,代表一个隐藏文件. ~/.local是你的主目录下下一个.local的文件夹的路径,并且从.可以看出,这是一个隐藏文件,使用ls -a显示. 3 设置zsh为默认的shell chsh -s /bin/zsh 4 重启终端生效 5 设置ZSH主题: 5.1 到你的用户名目录 $ cd ~/ 5.2 显示文件(包括隐藏文件),并打开.zshrc $ ls -a $ open .zshrc 5.3 找到 ZSH_THEME=“robbyrussell”,并注释掉(行头加 #),另起一行,换上你喜欢的主题,我使用的ys.zsh-theme(补充:直接在原来的行上替换,有时候会出现替换是失败的情况,所以注释掉原来的,重新写是最好的选择) ZSH_THEME=&quot;ys&quot; 6 补充:卸载oh my zsh：在命令行输入如下命令，回车即可 uninstall_oh_my_zsh iterm2的使用下载地址: http://www.iterm2.com/ 使用: 1.cmd+f 弹出iterm2的查找模式,确认找到的是自己的内容之后,使用tab键,查找窗口将自动变化内容,并将其复制.如果是shift+tab,则自动将查找内容的左边选中并复制. 2.自动使用前-Tab路径,设置perferces-&gt;Profiles-&gt;选中Login shell 和Reuse previous tab&apos;s directory 3.command+d: 垂直分割 command+shift+d: 水平分割 4.系统热键:设置好系统热键之后,将在正常的浏览器或者编辑器等窗口的上面,以半透明窗口的上面,以半透明窗口形式直接调出iterm2 shell-&gt;perferces-&gt;Key-&gt;Hotkey 5.自动完成:输入打头几个字母,然后输入cmd + ; iterm2将自动列出之前输入过的类似命令 6.剪切历史:输入cmd + shift + h iterm2将自动列出剪切板的历史记录.如果需要将剪切板的历史记录保存到磁盘,在Perferences-&gt;General-&gt;Save copy/paste history to disk. 7.全屏切换: cmd + enter 进入和返回全屏模式]]></content>
  </entry>
  <entry>
    <title><![CDATA[01-状态栏]]></title>
    <url>%2F2017%2F05%2F22%2F01-%E7%8A%B6%E6%80%81%E6%A0%8F%2F</url>
    <content type="text"><![CDATA[状态栏typedef NS_ENUM(NSInteger, UIStatusBarStyle) { UIStatusBarStyleDefault = 0, // 白底黑子 UIStatusBarStyleLightContent NS_ENUM_AVAILABLE_IOS(7_0) = 1, 黑底白字 UIStatusBarStyleBlackTranslucent NS_ENUM_DEPRECATED_IOS(2_0, 7_0, &quot;Use UIStatusBarStyleLightContent&quot;) = 1, UIStatusBarStyleBlackOpaque NS_ENUM_DEPRECATED_IOS(2_0, 7_0, &quot;Use UIStatusBarStyleLightContent&quot;) = 2, } __TVOS_PROHIBITED; //默认的值是黑色的-(UIStatusBarStyle)preferredStatusBarStyle{ return UIStatusBarStyleDefault; }如果项目中root是UINavigationController,那我们自己的UIViewController的preferredStatusBarStyle的方法根本不会调用 // 是否隐藏状态栏 (BOOL)prefersStatusBarHidden{ return NO;} http://www.cnblogs.com/ilovelqq/p/4769655.html 参考]]></content>
  </entry>
</search>
