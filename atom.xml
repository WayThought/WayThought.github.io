<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>钱多多的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://waythought.duoshuo.com/"/>
  <updated>2018-06-28T07:06:14.415Z</updated>
  <id>http://waythought.duoshuo.com/</id>
  
  <author>
    <name>Qian.G.j</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>15.Object-C Runtime基本介绍和消息传递</title>
    <link href="http://waythought.duoshuo.com/2018/05/09/15.%E8%BD%AC%E5%8F%91%E6%B6%88%E6%81%AF%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    <id>http://waythought.duoshuo.com/2018/05/09/15.转发消息备忘录/</id>
    <published>2018-05-09T06:34:14.000Z</published>
    <updated>2018-06-28T07:06:14.415Z</updated>
    
    <content type="html"><![CDATA[<p>本文内容</p><ul><li><a href="#缘由代码">缘由代码</a></li><li><a href="#Runtime基本介绍">Runtime基本介绍</a></li><li><a href="#object_getClass(obj">object_getClass(obj)与[obj class]的区别</a>与[obj class]的区别)</li><li><a href="#objc_class结构体及其成员变量定义">objc_class结构体及其成员变量定义</a></li></ul><h3 id="1-objc-msgSend的介绍"><a href="#1-objc-msgSend的介绍" class="headerlink" title="1. objc_msgSend的介绍"></a>1. objc_msgSend的介绍</h3><h4 id="来看两段代码"><a href="#来看两段代码" class="headerlink" title="来看两段代码"></a>来看两段代码</h4><h4 id="第一段代码"><a href="#第一段代码" class="headerlink" title="第一段代码"></a>第一段代码</h4><pre><code>#import &quot;KNBFather.h&quot;@interface KNBSon : KNBFather@end</code></pre><p>-</p><pre><code>#import &quot;KNBSon.h&quot;@implementation KNBSon- (instancetype)init {    if (self = [super init]) {        NSLog(@&quot;[self class] --&gt; %@&quot;,[self class]);        NSLog(@&quot;[super class] --&gt; %@&quot;,[super class]);    }    return self;}@end</code></pre><p>实例化KNBSon控制台输出:</p><pre><code>2018-06-20 09:37:15.874949+0800 23- 数组的练习[50857:2147245] [self class] --&gt; KNBSon2018-06-20 09:37:15.875173+0800 23- 数组的练习[50857:2147245] [super class] --&gt; KNBSon</code></pre><p>分析:</p><pre><code>我们想当然的认为self class是son, super class是father。但是输出的却是一样的,都是son。这是因为oc一切方法的本质都是消息的发送和接受,是动态的。具体的等看过第二节我们再探讨。</code></pre><h4 id="第二段代码"><a href="#第二段代码" class="headerlink" title="第二段代码"></a>第二段代码</h4><pre><code>#import &lt;Foundation/Foundation.h&gt;@interface KNBFather : NSObject@property (nonatomic, copy) NSString *name;@end===================#import &quot;KNBFather.h&quot;@implementation KNBFather- (instancetype)init {    if (self = [super init]) {        self.name = @&quot;&quot;;    }    return self;}- (void)setName:(NSString *)name {    _name = name;    NSLog(@&quot;我是KNBFather,调用我的setName方法了&quot;);}@end</code></pre><p>-</p><pre><code>#import &quot;KNBFather.h&quot;@interface KNBSon : KNBFather@end=========================#import &quot;KNBSon.h&quot;@implementation KNBSon- (instancetype)init {    if (self = [super init]) {        NSLog(@&quot;[self class] --&gt; %@&quot;,[self class]);        NSLog(@&quot;[super class] --&gt; %@&quot;,[super class]);    }    return self;}- (void)setName:(NSString *)name {    NSLog(@&quot;我是KNBSon,调用我的setName方法了&quot;);}@end</code></pre><p>实例化KNBSon控制台输出:</p><pre><code>2018-06-20 09:58:03.162035+0800 23- 数组的练习[51199:2171942] 我是KNBSon,调用我的setName方法了2018-06-20 09:58:03.162231+0800 23- 数组的练习[51199:2171942] [self class] --&gt; KNBSon2018-06-20 09:58:03.162368+0800 23- 数组的练习[51199:2171942] [super class] --&gt; KNBSon</code></pre><p>分析:</p><p>我们在父类KNBFather中的init方法中设置了self.name = @””,只是想初始化name的值。</p><p>按道理说,我们在父类使用self.name方法应该调用father的setName方法(以前的理解 self在实例方法中表示的该实例),在子类KNBSon中使用self.name方法也应该调用KNBSon的setName方法。但是实际上我们看到在父类中使用self.name调用的确实是子类的setName方法。</p><p>我们先看下runtime相关的一些知识,再来解释以上问题。</p><h3 id="2-Runtime基本介绍"><a href="#2-Runtime基本介绍" class="headerlink" title="2.Runtime基本介绍"></a>2.Runtime基本介绍</h3><p>Objective-C是基于C加入了面向对象特性和消息转发机制的动态语言。这意味着不仅需要编译器,还需要一个运行系统来执行编译后的代码。而这个运行系统就是runtime,也就是运行时机制,我理解的就是”中间调度系统”,来控制消息发送、消息转发、查看对象信息等等</p><p>给对象发消息可以这样写:</p><pre><code>id returnValue = [someObject messageName: parameter];</code></pre><p>在本例中, someObject叫做”接收者”(receiver),messageName叫做”选择器”(selector).选择子与参数合起来称为”消息”(message)。编译器看到此消息后,将其转换为一条标准的C语言函数调用,所调用的函数仍是消息传递机制中的核心函数,叫做objc_msgSend,其”原型”(prototype)如下:</p><pre><code>id objc_msgSend(id self,SEL cmd, ...)</code></pre><p>这是个”参数个数可变的函数”(variadic function),能接受两个或两个以上的参数。第一个参数代表接收者,第二个参数代表”选择器”,后续参数就是消息中的那些参数,其顺序不变。”选择器”指的就是方法的名字。”选择子”与”方法”这两个词经常交替使用。编译器会把刚才那个例子中的消息转换为如下的函数。</p><pre><code>id returnValue = objc_msgSend(someObject,@selector(messageName:),parameter);</code></pre><ul><li>objc_msgSendSuper: 如果要给超类发送消息,那么交由此函数处理。</li></ul><h4 id="id"><a href="#id" class="headerlink" title="id"></a>id</h4><p>id 是一个指向类实例的指针:</p><pre><code>// objc.h中typedef struct objc_object *id;struct objc_object {    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;};</code></pre><p>objc_object是一个结构体,包含一个isa指针,根据这个isa指针可以顺藤摸瓜找到对象所属的类。(isa指针不总是指向实例对象所属的类,不能依靠它来确定类型,而是应该是class方法来确定实例对象的类。因为KVO的实现机理就是将被观察对象的isa指针指向一个中间类而不是真实的类,这是一种叫做isa-swizzling的技术)。</p><p><a href="https://juejin.im/post/59e6b6215188255b5b2abd56" target="_blank" rel="external">感兴趣的可以去这个链接介绍isa-swizzling</a></p><h4 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h4><p>objc_msgSend函数的第二个参数类型是SEL,它是selector在Objc中的表示类型,他是个映射到方法的C字符串。</p><h4 id="isa指针"><a href="#isa指针" class="headerlink" title="isa指针"></a>isa指针</h4><p>上面的objc_msgSend实现原理里面提到了isa指针、类。也是我们平时经常接触的两个概念,但是他们内部具体如何实现,却很少深究。</p><p>我们OC中的基本所有的类都是继承于NSObject,NSObject是根类。我们来看下定义</p><pre><code>// NSObject.h定义@interface NSObject &lt;NSObject&gt; {    Class isa  OBJC_ISA_AVAILABILITY;}</code></pre><p>这个Class是什么?</p><pre><code>// objc.h中typedef struct objc_class *Class;// runtime.h中struct objc_class {    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;    Class _Nullable super_class                              OBJC2_UNAVAILABLE;    const char * _Nonnull name                               OBJC2_UNAVAILABLE;    long version                                             OBJC2_UNAVAILABLE;    long info                                                OBJC2_UNAVAILABLE;    long instance_size                                       OBJC2_UNAVAILABLE;    struct objc_ivar_list * _Nullable ivars                  OBJC2_UNAVAILABLE;    struct objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;    struct objc_cache * _Nonnull cache                       OBJC2_UNAVAILABLE;    struct objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;} OBJC2_UNAVAILABLE;</code></pre><p>objc_class为什么也有个isa?<br>我们知道isa指针指向的是该对象所属的类,对于实例对象的isa指针,我们知道是指向其所属的类,但是实例对象所属的类的isa指针又指向谁呢?</p><p>类对象本身也是对象,类本身所属类是 元类!!!<br>所以实例对象所属的类的isa指针指向的是元类。</p><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><h4 id="1-类对象的实质"><a href="#1-类对象的实质" class="headerlink" title="1.类对象的实质"></a>1.类对象的实质</h4><p>类对象是由编译器创建的,任何直接或间接机场NSObject的类,它的实例对象(instance object)中都有一个isa指针,指向它的类对象(class object)。这个类对象中存储了关于这个实例对象所属的类的定义的包括变量、方法、遵守的协议等。</p><p>因此,类对象能访问所有关于这个类的信息,利用这些信息可以产生一个新的实例,但是类对象不能访问任何实例对象的内容。222</p><h4 id="2-类对象和实例对象的区别"><a href="#2-类对象和实例对象的区别" class="headerlink" title="2.类对象和实例对象的区别"></a>2.类对象和实例对象的区别</h4><p>类对象虽然保留了一个该类实例对象的原型,但是不能执行实例方法。然而,类的定义能包括那些特意为类对象准备的方法–类方法。类对象也可以从父类那里继承类方法。</p><p>类对象是一个功能完整的对象,所以也能被动态识别(dynamically typed),接受消息,从其他类继承方法。特殊之处是在于它们由编辑器创建,缺少它们自己的数据结构(实例变量)。</p><h4 id="元类"><a href="#元类" class="headerlink" title="元类"></a>元类</h4><p>实际上,类对象是元类对象的一个实例!!</p><p>元类描述了一个类对象,就像类对象描述了普通的实例变量一样。不同的是元类的方法列表是类方法的集合,由类对象的选择器来响应。当向一个类发送消息时,objc_msgSend会通过类对象的isa指针定位到元类,并检查元类的方法列表来决定调用哪个方法。</p><p>很显然,元类也是对象,也应该是其他类的实例,实际上元类是根类(root class’s metaclass)的实例,而根类是其自身的实例,即根类的isa指针指向自身。</p><p>整个指针链就是类的super_class指向其父类,而元类的super_class则指向父类的元类。元类的super class链与类的super_class链平行,所以类方法的继承于实例方法的继承也是并行的。而根元类的super_class指向根元类。</p><p>当一个消息发送给任何一个对象的时候,方法检测都是从对象的isa指针开始依次去父类方法列表中寻找。实例方法在类中定义,类方法在元类和根类中定义。 (根类的元类就是根类自己)。</p><p><img src="http://payoeqxrw.bkt.clouddn.com/15_1.jpg" alt=""></p><p>objc_msgSend函数会依据接收者与选择子的类型来调用适当的方法。为了完成此操作,该方法需要在接收者所属的类中搜寻其”方法列表”(list of methods),如果能找到与选择子名称相符的方法,就跳至其实现代码。若是找不到,那就沿着继承体系继续向上查找,等找到合适的方法之后再跳转。如果最终还是找不到相符的方法,那就执行”消息转发”(message forwarding)操作。</p><p>objc_msgSend会匹配结果缓存在”快速映射表”(fast map)里面,每个类都有这样一块缓存,若是稍后还向该类发送与选择子相同的消息,那么执行起来的就和快了。</p><h5 id="object-getClass-obj-与-obj-class-的区别"><a href="#object-getClass-obj-与-obj-class-的区别" class="headerlink" title="object_getClass(obj)与[obj class]的区别"></a>object_getClass(obj)与[obj class]的区别</h5><ol><li>object_getClass(obj)返回的是obj中的isa指针;</li><li><p>[obj class]分为两种情况:</p><ul><li>当obj为实例对象时,[obj class]调用的是实例方法: -(Class)class,返回的是isa指针;</li><li>当obj为类对象(包括元类和根类)时,调用的是类方法: +(Class)class,返回的结果为其本身。</li></ul></li><li><p>-(Class)class的实现如下:</p><pre><code>-(Class)class {    return object_getClass(self);}</code></pre></li></ol><h4 id="第一段代码解析"><a href="#第一段代码解析" class="headerlink" title="第一段代码解析"></a>第一段代码解析</h4><p>来让我们看看第一段代码为什么[self class]和[super class]都是输出的是son。</p><h5 id="self-class"><a href="#self-class" class="headerlink" title="[self class]"></a>[self class]</h5><p>根据上面的知识,我们知道[self class]最终会转换为如下形式:</p><pre><code>id objc_msgSend(son的实例对象self, @selector(class), ...)</code></pre><p>消息的接受者是KNBSon的实例对象的self,然后调用他的class方法,它自己没有实现该方法,最终在NSObject中找到该方法的实现,然后返self的isa指针,此时self是KNBSon类的实例对象,那么isa指针也就是指向KNBSon类,所以[self class]返回的是 KNBSon。</p><h5 id="super-class"><a href="#super-class" class="headerlink" title="[super class]"></a>[super class]</h5><p>而当使用[super class]调用时,会使用objc_msgSendSuper函数。看下objc_msgSendSuper的函数定义:</p><pre><code>id objc_msgSendSuper(struct objc_super *super,  @selector(class), ...)</code></pre><p>第一个参数是个objc_super的结构体,第二个参数还是类似上面的类方法的selector,先看objc_super这个结构体是什么东西</p><pre><code>struct objc_super {   id receiver;   Class superClass;};</code></pre><p>此处上面的结构体转换为如下样式:</p><pre><code>struct objc_super {       KNBSon的实例对象self;       KNBFather;};</code></pre><p>那么调用[super class]后的内部流程如下:</p><ol><li>当使用[super class]时,这时要转化成objc_msgSendSuper的方法。</li><li>想构造objc_super的结构体,第一个成员变量就是self,第二个成员变量就是KNBFather,然后要找class这个selector,先去superClass也就是KNBFather中去找,没有,然后去KNBFather的父类中去找,结果还是在NSObject中找到了。</li><li>然后内部使用函数objc_msgSend(objc_super -&gt; receiver, @selector(class))去掉用,此时已经和我们用[self class]调用相同了,因为这里的receiver还是KNBSon的实例对象self,所以这里返回的还是实例对象self的isa指针(指向他的类对象),也就是KNBSon。</li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>很多人会想当然的认为”super和self类似,应该是指向父类的指针”。这其实是一个误区。</p><p>其实super是一个关键字,他的本质是一个编译器标志符,和self是指向同一个消息接受者!他俩的不同点在于: super会告诉编译器,调用class这个方法(或者其他方法)时,要去父类的方法,而不是本类里的。</p><p>所以当使用self调用的方法时,会从当前类的方法列表中开始找,如果没有,就从父类中再找;而当使用super时,则直接从父类的方法列表中开始找,不在从当前的类的方法列表中寻找了。</p><p>-</p><h4 id="第二段代码解析"><a href="#第二段代码解析" class="headerlink" title="第二段代码解析"></a>第二段代码解析</h4><p>第二段代码在KNBFather里面使用self.name = @””调用的是子类的setName方法<br>我们来看下子类实例化的代码</p><pre><code>- (instancetype)init {    if (self = [super init]) {        NSLog(@&quot;[self class] --&gt; %@&quot;,[self class]);        NSLog(@&quot;[super class] --&gt; %@&quot;,[super class]);    }    return self;}</code></pre><p>当调用[super init]的时候,消息的接受者依然是KNBSon的实例对象, 只是去chan父类中调用init方法,在父类执行[self setName]的时候,接受消息的是KNBSon的实例对象,去查询的是KNBSon的方法列表,调用的是KNBSon的 setName方法。</p><p>所以我们要注意,如果自雷重写了父类的方法,那么不管在子类还是在父类调用发方法,如果是子类调用,最终被执行的方法是子类的方法。</p><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>我们探讨了一些runtime的特性和机制,由此可见runtime的一些本质,但是也只是管中窥豹,做抛砖引玉之用,欢迎大家探讨。</p><p>参考资料:<br>    <a href="https://www.jianshu.com/p/7b8d834042e4" target="_blank" rel="external">https://www.jianshu.com/p/7b8d834042e4</a><br>    <a href="https://www.jianshu.com/p/1c52810f23d2" target="_blank" rel="external">https://www.jianshu.com/p/1c52810f23d2</a><br>    <a href="https://www.jianshu.com/p/d774ad33d165" target="_blank" rel="external">https://www.jianshu.com/p/d774ad33d165</a><br>    <a href="https://juejin.im/post/57a9516e7db2a2005aba4809" target="_blank" rel="external">https://juejin.im/post/57a9516e7db2a2005aba4809</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文内容&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#缘由代码&quot;&gt;缘由代码&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#Runtime基本介绍&quot;&gt;Runtime基本介绍&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#object_getClass(obj&quot;&gt;object
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>14.友盟 crash log 错误分析工具</title>
    <link href="http://waythought.duoshuo.com/2018/04/18/14.%E5%8F%8B%E7%9B%9F%20crash%20log%20%E9%94%99%E8%AF%AF%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/"/>
    <id>http://waythought.duoshuo.com/2018/04/18/14.友盟 crash log 错误分析工具/</id>
    <published>2018-04-18T01:34:14.000Z</published>
    <updated>2018-06-28T07:07:58.539Z</updated>
    
    <content type="html"><![CDATA[<p>开发完成,闲置时间对已上线版本进行crash log错误分析,crash展示文件除了帧调用就是内存地址,的确不好看明白 <img src="http://payoeqxrw.bkt.clouddn.com/14_crash1.png" alt=""></p><p>我们用友盟的错误分析工具umcrashtool<br><a href="下载地址:">http://dev.umeng.com/files/download/umcrashtool.zip</a></p><p>第一步:找到上线打包的xcarchive 保证存在就好<br><img src="http://payoeqxrw.bkt.clouddn.com/14_crash2.png" alt=""><br>第二步:去友盟错误统计的网页,下载对应的csv文件<br><img src="http://payoeqxrw.bkt.clouddn.com/14_crash3.png" alt=""><br>第三步:将下载好的错误分析工具和csv文件放到同一目录下<br><img src="http://payoeqxrw.bkt.clouddn.com/14_crash4.png" alt=""><br>第四步: 打开终端输入</p><pre><code>./umcrashtool csv路径</code></pre><p>显示结果:<br><img src="http://payoeqxrw.bkt.clouddn.com/14_crash5.png" alt=""></p><p>从上到下,是调用堆栈,可以清晰的看出来报错的地方</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;开发完成,闲置时间对已上线版本进行crash log错误分析,crash展示文件除了帧调用就是内存地址,的确不好看明白 &lt;img src=&quot;http://payoeqxrw.bkt.clouddn.com/14_crash1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们用友
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>13.字符串特辑(转载)</title>
    <link href="http://waythought.duoshuo.com/2018/04/17/13.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%89%B9%E8%BE%91/"/>
    <id>http://waythought.duoshuo.com/2018/04/17/13.字符串特辑/</id>
    <published>2018-04-17T01:34:14.000Z</published>
    <updated>2018-04-17T06:15:49.692Z</updated>
    
    <content type="html"><![CDATA[<p>OC中的NSString不伦是在编译时还是在运行时都做了很多的优化,和普通的对象不同,它是一个比较复杂的存在。</p><p>首先我们做下测试:</p><p>定义宏方便打印:</p><pre><code>#if __has_feature(objc_arc)#define Obj_RetainCount(obj) \CFGetRetainCount((__bridge CFTypeRef)(obj))#else#define Obj_RetainCount(obj) \DebugLog(@&quot;%lu&quot;,[obj retainCount]);#endif#define KNLog(_var) NSLog(@&quot;%@ : class = %@ p = %p retainCount = %d&quot;,@#_var,NSStringFromClass([_var class]),_var,Obj_RetainCount(_var));</code></pre><p>测试代码:</p><pre><code>NSString *a = @&quot;str&quot;;NSString *b = [[NSString alloc]init];NSString *c = [[NSString alloc]initWithString:@&quot;str&quot;];NSString *d = [[NSString alloc]initWithFormat:@&quot;str&quot;];NSString *e = [NSString stringWithFormat:@&quot;str&quot;];NSString *f = [NSString stringWithFormat:@&quot;123456789&quot;];NSString *g = [NSString stringWithFormat:@&quot;1234567890&quot;];KNLog(a);KNLog(b);KNLog(c);KNLog(d);KNLog(e);KNLog(f);KNLog(g);</code></pre><p>打印结果:</p><pre><code>a : class = __NSCFConstantString p = 0x104038110 retainCount = -1b : class = __NSCFConstantString p = 0x1af4d3c28 retainCount = -1c : class = __NSCFConstantString p = 0x104038110 retainCount = -1d : class = NSTaggedPointerString p = 0xa000000007274733 retainCount = -1e : class = NSTaggedPointerString p = 0xa000000007274733 retainCount = -1f : class = NSTaggedPointerString p = 0xa1ea1f72bb30ab19 retainCount = -1g : class = __NSCFString p = 0x1c40366e0 retainCount = 2</code></pre><p>可以看到,不同的方式创建的字符串额立新不同,引用计数也有所区别,并不是我们常规理解的对象初始化后引用计数为1.创建的字符串有3种类型</p><ul><li>__NSCFConstantString</li><li>__NSCFString</li><li>NSTaggedPointerString</li></ul><p>造成这种结果的原因是由于OC对字符串做的内存优化。</p><h5 id="NSCFConstantString"><a href="#NSCFConstantString" class="headerlink" title="__NSCFConstantString"></a>__NSCFConstantString</h5><p>对变量类型名上就可以看出,这种类型的字符串是常亮字符串。该类型的字符串以字面量的方式创建,保存在字符串常亮区,是在编译时创建的。例如:</p><pre><code>NSString *a = @&quot;good afternoon!&quot;;NSString *b = [[NSString alloc]initWithString:@&quot;good afternoon!&quot;];NSString *c = [[NSString alloc]initWithFormat:a];</code></pre><p>对于initWithString实例方法以及stringWithString类方法,编译器会给出redundant警告,原因是该方法创建字符串等同于直接复制字符串字面量。    </p><ul><li>当创建的字符串变量值在常亮区已经存在时,会指向那个字符串,这是编译器做的优化。</li><li>由于是常量,因此其内存管理并不同于对象的内存管理,引用计数用用整形格式打出来始终为-1。</li></ul><h5 id="NSCFString"><a href="#NSCFString" class="headerlink" title="__NSCFString"></a>__NSCFString</h5><p>__NSCFString表示对象类型的字符串,在运行时创建,保存在堆区,初始引用计数为1,其内存管理方式就是对象的内存管理方式。该种类型字符串通过format方式创建,并且字符串内容仅由数字、字母和常规ASCII字符构成,且其长度不能太小,否则创建的是NSTaggedPointerString类型。</p><pre><code>NSString *d = [[NSString alloc]initWithFormat:@&quot;我是对象&quot;];//__NSCFStringNSString *e = [NSString stringWithFormat:@&quot;1234567890&quot;]; //__NSCFString</code></pre><h5 id="NSTaggedPointerString"><a href="#NSTaggedPointerString" class="headerlink" title="NSTaggedPointerString"></a>NSTaggedPointerString</h5><p>NSTaggedPointerString类型的字符串是对__NSCFString类型的一种优化,在运行时创建字符串时,会对字符串内容及长度作判断,若内容由ASCII字符构成且长度较小,这时候创建的字符串类型就是NSTaggedPointerString（标签指针字符串),字符串直接存储在指针的内容中。NSTaggedPointerString类型中字符串引用计数同样为-1,不适用对象的内存管理策略。</p><pre><code>NSString *e = [NSString stringWithFormat:@&quot;123456789&quot;]; //NSTaggedPointerString </code></pre><p>而上面以同样的方式创建的1234567890字符串却为 __NSCFString 类型。</p><h4 id="探究NSDictionary-NSArray-NSValue-NSNumber是否也做了优化"><a href="#探究NSDictionary-NSArray-NSValue-NSNumber是否也做了优化" class="headerlink" title="探究NSDictionary NSArray NSValue NSNumber是否也做了优化"></a>探究NSDictionary NSArray NSValue NSNumber是否也做了优化</h4><p>#####NSDictionary测试代码如下：</p><pre><code>NSDictionary *d1 = @{@&quot;aa&quot;:@&quot;11&quot;,@&quot;bb&quot;:@&quot;22&quot;};NSDictionary *d2 = [[NSDictionary alloc]init];NSDictionary *d3 = [[NSDictionary alloc]initWithObjectsAndKeys:@&quot;a&quot;,@&quot;1&quot;, nil];NSDictionary *d4 = [NSDictionary dictionaryWithObjectsAndKeys:@&quot;b&quot;,@&quot;2&quot;, nil];KNLog(d1);KNLog(d2);KNLog(d3);KNLog(d4);</code></pre><p>打印结果:</p><pre><code>d1 : class = __NSDictionaryI p = 0x7fddbad1e9d0 retainCount = 1d2 : class = __NSDictionary0 p = 0x7fddbae00dd0 retainCount = -1d3 : class = __NSDictionaryI p = 0x7fddbad044f0 retainCount = 1d4 : class = __NSDictionaryI p = 0x7fddbadbd8a0 retainCount = 2</code></pre><p>#####NSArray测试代码如下：</p><pre><code>NSDictionary *d1 = @{@&quot;aa&quot;:@&quot;11&quot;,@&quot;bb&quot;:@&quot;22&quot;};NSDictionary *d2 = [[NSDictionary alloc]init];NSDictionary *d3 = [[NSDictionary alloc]initWithObjectsAndKeys:@&quot;a&quot;,@&quot;1&quot;, nil];NSDictionary *d4 = [NSDictionary dictionaryWithObjectsAndKeys:@&quot;b&quot;,@&quot;2&quot;, nil];KNLog(d1);KNLog(d2);KNLog(d3);KNLog(d4);</code></pre><p>打印结果:</p><pre><code>d1 : class = __NSDictionaryI p = 0x7fddbad1e9d0 retainCount = 1d2 : class = __NSDictionary0 p = 0x7fddbae00dd0 retainCount = -1d3 : class = __NSDictionaryI p = 0x7fddbad044f0 retainCount = 1d4 : class = __NSDictionaryI p = 0x7fddbadbd8a0 retainCount = 2</code></pre><h5 id="NSArray测试代码如下："><a href="#NSArray测试代码如下：" class="headerlink" title="NSArray测试代码如下："></a>NSArray测试代码如下：</h5><pre><code>NSArray *a1 = @[@&quot;1&quot;,@&quot;2&quot;];NSArray *a2 = [[NSArray alloc]init];NSArray *a3 = [[NSArray alloc]initWithObjects:@&quot;1&quot;, nil];NSArray *a4 = [[NSArray alloc]initWithArray:@[@&quot;a&quot;,@&quot;b&quot;]];NSArray *a5 = [NSArray arrayWithObjects:@&quot;m&quot;,@&quot;n&quot;, nil];KNLog(a1);KNLog(a2);KNLog(a3);KNLog(a4);KNLog(a5);</code></pre><p>打印结果:</p><pre><code>a1 : class = __NSArrayI p = 0x7fddbae16970 retainCount = 1a2 : class = __NSArray0 p = 0x7fddbae00ce0 retainCount = -1a3 : class = __NSArrayI p = 0x7fddbae23ea0 retainCount = 1a4 : class = __NSArrayI p = 0x7fddbae0ab30 retainCount = 1a5 : class = __NSArrayI p = 0x7fddbae0ab10 retainCount = 2</code></pre><h5 id="NSValue测试代码如下："><a href="#NSValue测试代码如下：" class="headerlink" title="NSValue测试代码如下："></a>NSValue测试代码如下：</h5><pre><code>NSValue *v1 = [NSValue valueWithCGPoint:CGPointMake(10, 10)];CGPoint point = CGPointMake(20, 20);NSValue *v2 = [[NSValue alloc]initWithBytes:&amp;point objCType:@encode(CGPoint)];KNLog(v1);KNLog(v2);</code></pre><p>打印结果:</p><pre><code>v1 : class = NSConcreteValue p = 0x7fddbae153e0 retainCount = 2v2 : class = NSConcreteValue p = 0x7fddbae21fa0 retainCount = 1</code></pre><h5 id="NSNumber测试代码如下："><a href="#NSNumber测试代码如下：" class="headerlink" title="NSNumber测试代码如下："></a>NSNumber测试代码如下：</h5><pre><code>NSNumber *n1 = [NSNumber numberWithInt:123456789];NSNumber *n2 = [NSNumber numberWithInt:1234567890];int i = 10;NSNumber *n3 = [[NSNumber alloc]initWithBytes:&amp;i objCType:@encode(int)];KNLog(n1);KNLog(n2);KNLog(n3);</code></pre><p>打印结果:</p><pre><code>n1 : class = __NSCFNumber p = 0xb000000075bcd152 retainCount = -1n2 : class = __NSCFNumber p = 0xb000000499602d22 retainCount = -1n3 : class = NSConcreteValue p = 0x7fddbadb4df0 retainCount = 1</code></pre><p>结论:</p><ul><li>对于NSDictionary、NSArray以及NSValue实例,除了空字典和空字符串,其余实例都遵循对象的内存管理策略。</li><li>NSNumber类创建的对于普通数据类型的封装的实例,其内存管理同样做了优化,不遵循对象的内存管理策略。<br>另外可以看到,有些新创建的对象引用计数为1,有些为2.这是因为用类方法创建的实例,系统自动将其置入自动释放池。</li></ul><h5 id="mutable-variable"><a href="#mutable-variable" class="headerlink" title="mutable variable"></a>mutable variable</h5><p>测试代码如下:</p><pre><code>//NSMutableStringNSMutableString *ms1 = [[NSMutableString alloc]init];NSMutableString *ms2 = [[NSMutableString alloc]initWithString:@&quot;str&quot;];NSMutableString *ms3 = [[NSMutableString alloc]initWithFormat:@&quot;str&quot;];NSMutableString *ms4 = [NSMutableString stringWithFormat:@&quot;str&quot;];NSMutableString *ms5 = [NSMutableString stringWithFormat:@&quot;123456789&quot;];NSMutableString *ms6 = [NSMutableString stringWithFormat:@&quot;1234567890&quot;];XFLog(ms1);XFLog(ms2);XFLog(ms3);XFLog(ms4);XFLog(ms5);XFLog(ms6);//NSMutableDictionaryNSMutableDictionary *md1 = [[NSMutableDictionary alloc]init];NSMutableDictionary *md2 = [[NSMutableDictionary alloc]initWithObjectsAndKeys:@&quot;a&quot;,@&quot;1&quot;, nil];NSMutableDictionary *md3 = [NSMutableDictionary dictionaryWithObjectsAndKeys:@&quot;b&quot;,@&quot;2&quot;, nil];XFLog(md1);XFLog(md2);XFLog(md3);//NSMutableArrayNSMutableArray *ma1 = [[NSMutableArray alloc]init];NSMutableArray *ma2 = [[NSMutableArray alloc]initWithObjects:@&quot;1&quot;, nil];NSMutableArray *ma3 = [[NSMutableArray alloc]initWithArray:@[@&quot;a&quot;,@&quot;b&quot;]];NSMutableArray *ma4 = [NSMutableArray arrayWithObjects:@&quot;m&quot;,@&quot;n&quot;, nil];XFLog(ma1);XFLog(ma2);XFLog(ma3);XFLog(ma4); </code></pre><p>测试结果如下:</p><pre><code>ms1 : class = __NSCFString p = 0x7fd31070e6b0 retainCount = 1ms2 : class = __NSCFString p = 0x7fd310716d40 retainCount = 1ms3 : class = __NSCFString p = 0x7fd310719910 retainCount = 1ms4 : class = __NSCFString p = 0x7fd31071b610 retainCount = 2ms5 : class = __NSCFString p = 0x7fd31071bc40 retainCount = 2ms6 : class = __NSCFString p = 0x7fd310715350 retainCount = 2md1 : class = __NSDictionaryM p = 0x7fd31071be00 retainCount = 1md2 : class = __NSDictionaryM p = 0x7fd31070c270 retainCount = 1md3 : class = __NSDictionaryM p = 0x7fd310717960 retainCount = 2ma1 : class = __NSArrayM p = 0x7fd31060d860 retainCount = 1ma2 : class = __NSArrayM p = 0x7fd310605730 retainCount = 1ma3 : class = __NSArrayM p = 0x7fd310607f80 retainCount = 1ma4 : class = __NSArrayM p = 0x7fd310606dc0 retainCount = 2</code></pre><p>结论:<br>    可变变量实例均以对象的形式保存在堆中。</p><font color="#0099ff" size="face=" 黑体""="">color=#0099ff size=12 face=”黑体”</font>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;OC中的NSString不伦是在编译时还是在运行时都做了很多的优化,和普通的对象不同,它是一个比较复杂的存在。&lt;/p&gt;
&lt;p&gt;首先我们做下测试:&lt;/p&gt;
&lt;p&gt;定义宏方便打印:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#if __has_feature(objc_arc)
#defi
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>12.Effective Objective-C 2.0读书笔记</title>
    <link href="http://waythought.duoshuo.com/2018/04/16/12.Effective%20Objective-C%202.0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://waythought.duoshuo.com/2018/04/16/12.Effective Objective-C 2.0读书笔记/</id>
    <published>2018-04-16T07:34:14.000Z</published>
    <updated>2018-04-18T10:03:02.672Z</updated>
    
    <content type="html"><![CDATA[<ol><li>动态绑定</li></ol><p>// Messaging (Objective-C)</p><p>Object *obj = [Object new];</p><p>[obj performWith:parameterl and: parameterl2];</p><p>关键区别在于: 使用消息结构的语言,其运行时所应执行的代码由运行环境来决定;而使用函数调用的语言,则有编辑器决定。如果范例代码中调用的函数是多态的,那么在运行时就要按照 <strong>虚方法表: </strong>来查出到底应该执行哪个函数实现。而采取消息结构的语言,不论是否多态,总是在运行时才回去查找所要执行的方法。实际上,编辑器甚至不关心接受消息的对象是何种类型。接受消息的对象问题也要在运行时处理,其过程叫做”动态绑定”。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;动态绑定&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;// Messaging (Objective-C)&lt;/p&gt;
&lt;p&gt;Object *obj = [Object new];&lt;/p&gt;
&lt;p&gt;[obj performWith:parameterl and: parameterl
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>11.关于iOS9.0 ~ iOS9.3 从App Store下载出现不规则奔溃问题</title>
    <link href="http://waythought.duoshuo.com/2018/04/04/11.%E5%85%B3%E4%BA%8EiOS9.0~9.3%20%E4%BB%8EApp%20Store%E4%B8%8B%E8%BD%BD%E5%87%BA%E7%8E%B0%E4%B8%8D%E8%A7%84%E5%88%99%E5%A5%94%E6%BA%83%E9%97%AE%E9%A2%98/"/>
    <id>http://waythought.duoshuo.com/2018/04/04/11.关于iOS9.0~9.3 从App Store下载出现不规则奔溃问题/</id>
    <published>2018-04-04T08:34:14.000Z</published>
    <updated>2018-06-27T03:01:21.357Z</updated>
    
    <content type="html"><![CDATA[<p>这次上线遇到了一个大坑,版本发布上线后,同事的iOS9.1系统的6sp手机运行闪退,而这个手机真机直接跑、扫描二维码安装ipa包,都是没有问题的。</p><a id="more"></a><p>去友盟错误列表反馈报以下错误提示:</p><pre><code>Application received signal SIGTRAP</code></pre><p>最终定位到了P3资源文件的问题上了,图片资源文件里有16位图,显示模式为P3</p><h4 id="⚠️⚠️⚠️"><a href="#⚠️⚠️⚠️" class="headerlink" title="⚠️⚠️⚠️"></a>⚠️⚠️⚠️</h4><p><strong>原理: </strong><br>如果你的app需要支持广色域显示的话，那你必须得把target设置成iOS 9.3+，相反，如果你的app不需要支持广色域且你想兼容 iOS 9.3 之前的项目，你就得把资源文件所有的16位的或者显示模式为’P3’图片全都替换成8位模式的SRGB颜色的图片</p><ul><li><p>替换16位模式的SRGB颜色的图片步骤:</p><p>  1.打一个ipa包,将该文件后缀名.ipa为.zip</p><p>  2.解压该.zip文件,解压后的目录里面会有一个Payload文件夹</p><p>  3.打开终端切换到Payload文件下的.app路径</p><pre><code>cd ~/路径/appname.app</code></pre><p>  4.用find命名定位到Asset.car文件<br>  find . -name ‘Assets.car’<br>  5.使用使用 assetutil 命令导出图片的信息存储到Assets.json文件中<br>  sudo xcrun –sdk iphoneos assetutil –info ./Assets.car &gt; /tmp/Assets.json<br>  6.使用以下命令 打开上步生成的/tmp/Assets.json</p><pre><code>open /tmp/Assets.json</code></pre><p>  查找“DisplayGamut”: “P3”,看到”BitsPerComponent” : 16,这个就是要被替换的图片</p></li><li><p>修改图片:</p><p>  使用ColorSync实用工具将这个描述文件修改下<br>  <img src="http://payoeqxrw.bkt.clouddn.com/11_colorSync.png" alt=""><br>  指派它的描述文件为sRGB IEC61966-2.1，保存.</p><p>  <img src="http://payoeqxrw.bkt.clouddn.com/11_fix_1.png" alt=""></p><p>  <img src="http://payoeqxrw.bkt.clouddn.com/11_fix_2.png" alt=""><br>  至此我们的问题完美解决。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次上线遇到了一个大坑,版本发布上线后,同事的iOS9.1系统的6sp手机运行闪退,而这个手机真机直接跑、扫描二维码安装ipa包,都是没有问题的。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>10- 上传App Store 报错 ERROR ITMS-90087:&quot;Unsupported Architectures 解决办法</title>
    <link href="http://waythought.duoshuo.com/2018/01/30/10.%E4%B8%8A%E4%BC%A0App%20Store%20%E6%8A%A5%E9%94%99%20ERROR%20ITMS-90087-%20%22Unsupported%20Architectures%20%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%20/"/>
    <id>http://waythought.duoshuo.com/2018/01/30/10.上传App Store 报错 ERROR ITMS-90087- &quot;Unsupported Architectures 解决办法 /</id>
    <published>2018-01-30T02:13:38.100Z</published>
    <updated>2018-04-04T08:32:05.921Z</updated>
    
    <content type="html"><![CDATA[<h3 id="说明"><a href="#说明" class="headerlink" title="说明:"></a>说明:</h3><p>有些第三方提供商为了方便开发者使用,经常把i386 x86_64 armv7 arm64 等几个平台合并到一起,但是上传App Store的时候需要将i386 x86_64两个平台删除后,才能正常审核。</p><h3 id="一、几个重要概念"><a href="#一、几个重要概念" class="headerlink" title="一、几个重要概念"></a>一、几个重要概念</h3><ol><li>ARM:ARM处理器,特点是体积小、低功耗、低成本、高性能,所以几乎所有手机处理器都基于ARM,在嵌入式系统中应用广泛。</li><li>ARM处理器指令集: armv6 | armv7 | armv7s | arm64都是ARM处理器的指令集,这些指令集都是向下兼容的,例如armv7指令集兼容armv6,只是使用armv6的时候无法发挥出其性能,无法使用armv7的新特性,从而会导致程序执行效率没有那么高。<br>i386 | x86_64是Mac处理器的指令集,i386是针对intel通用微处理器32架构的(虚拟机: iPhone4s iPhone5)。x86_64是针对x86架构的64位处理器(虚拟机: iPhone5S iPhone6 iPhone6S iPhone7 iPhone8 iPhoneX)。</li><li><p>目前iOS移动设备指令集</p><a id="more"></a><p> arm64：真机64位处理器需要本架构 iPhone5S(以及以上)｜ iPad Air｜ iPad mini2(iPad mini with Retina Display)</p><p> armv7s：真机32位处理器需要本架构 iPhone5｜iPhone5C｜iPad4(iPad with Retina Display)</p><p> armv7：真机32位处理器需要本架构 iPhone3GS｜iPhone4｜iPhone4S｜iPad｜iPad2｜iPad3(The New iPad)｜iPad mini｜iPod Touch 3G｜iPod Touch4</p><p> armv6 设备： iPhone, iPhone2, iPhone3G, 第一代、第二代 iPod Touch（一般不需要去支持）</p></li><li><p>Xcode中指令集相关选项(Build Setting中)</p><p> (1) Architectures<br>Space-separated list of identifiers. Specifies the architectures (ABIs, processor models) to which the binary is targeted. When this build setting specifies more than one architecture, the generated binary may contain object code for each of the specified architectures. </p><p> 指定工程被编译成可支持哪些指令集类型，而支持的指令集越多，就会编译出包含多个指令集代码的数据包，对应生成二进制包就越大，也就是ipa包会变大。</p><p> (2) Valid Architectures<br>Space-separated list of identifiers. Specifies the architectures for which the binary may be built. During the build, this list is intersected with the value of ARCHS build setting; the resulting list specifies the architectures the binary can run on. If the resulting architecture list is empty, the target generates no binary. </p><p> 限制可能被支持的指令集的范围，也就是Xcode编译出来的二进制包类型最终从这些类型产生，而编译出哪种指令集的包，将由Architectures与Valid Architectures（因此这个不能为空）的交集来确定，例如：<br>比如，你的Valid Architectures设置的支持arm指令集版本有：armv7/armv7s/arm64，对应的Architectures设置的支持arm指令集版本有：armv7s，这时Xcode只会生成一个armv7s指令集的二进制包。<br>再比如：将Architectures支持arm指令集设置为：armv7,armv7s，对应的Valid Architectures的支持的指令集设置为：armv7s,arm64，那么此时，XCode生成二进制包所支持的指令集只有armv7s</p></li></ol><pre><code>在Xcode6.1.1里的 Valid Architectures  设置里， 默认为 Standard architectures(armv7,arm64),如果你想改的话，自己在other中更改。原因解释如下： </code></pre><p>使用 standard architectures (including 64-bit)(armv7,arm64) 参数，则打的包里面有32位、64位两份代码，在iPhone5s（ iPhone5s的cpu是64位的 ）下，会首选运行64位代码包， 其余的iPhone（ 其余iPhone都是32位的,iPhone5c也是32位 ），只能运行32位包，但是包含两种架构的代码包，只有运行在ios6，ios7系统上。<br>这也就是说，这种打包方式，对手机几乎没要求，但是对系统有要求，即ios6以上。<br>而使用 standard architectures (armv7,armv7s) 参数， 则打的包里只有32位代码， iPhone5s的cpu是64位，但是可以兼容32位代码，即可以运行32位代码。但是这会降低iPhone5s的性能。 其余的iPhone对32位代码包更没问题， 而32位代码包，对系统也几乎也没什么限制。 </p><pre><code>所以总结如下：  要发挥iPhone5s的64位性能，就要包含64位包，那么系统最低要求为ios6。 如果要兼容ios5以及更低的系统，只能打32位的包，系统都能通用，但是会丧失iPhone5s的性能。</code></pre><p>（3）Build Active Architecture Only<br>    指定是否只对当前连接设备所支持的指令集编译<br>    当其值设置为YES，这个属性设置为yes，是为了debug的时候编译速度更快，它只编译当前的architecture版本，而设置为no时，会编译所有的版本。 编译出的版本是向下兼容的，连接的设备的指令集匹配是由高到低（arm64 &gt; armv7s &gt; armv7）依次匹配的。比如你设置此值为yes，用iphone4编译出来的是armv7版本的，iphone5也可以运行，但是armv6的设备就不能运行。  所以，一般debug的时候可以选择设置为yes，release的时候要改为no，以适应不同设备。 </p><p>1）<br>Architectures:  armv7, armv7s, arm64<br>ValidArchitectures:  armv6, armv7s, arm64<br>生成二进制包支持的指令集： arm64</p><p>2）<br>Architectures: armv6, armv7, armv7s<br>Valid Architectures:  armv6, armv7s, arm64<br>生成二进制包支持的指令集： armv7s </p><p>3）<br>Architectures: armv7, armv7s, arm64<br>Valid Architectures: armv7，armv7s</p><p>这种情况是报错的，因为允许使用指令集中没有arm64。</p><p>注：如果你对ipa安装包大小有要求，可以减少安装包的指令集的数量，这样就可以尽可能的减少包的大小。当然这样做会使部分设备出现性能损失，当然在普通应用中这点体现几乎感觉不到，至少不会威胁到用户体检。</p><p>三、制作静态库.a是指令集选择</p><p>现在回归到正题，如何制作一个“没有问题”的.a静态库，通过以上信息了解到，当我们做App的时候，为了追求高效率，并且减小包的大小，Build Active Architecture Only设置成YES，Architectures按Xcode默认配置就可以，因为arm64向前兼容。但制作.a静态库就不同了，因为要保证兼容性，包括不同iOS设备以及模拟器运行不出错，所以结合当前行业情况，要做到最大的兼容性。</p><p>四、iOS使用lipo 拆分 合并 .a(我们用CBAiDirectSDK.framework为例子)</p><ol><li>将需要拆分和合并的.framework和.a文件拷贝出去(保留原文件,拆分合并完直接替换掉)</li><li><p>终端cd到拷贝的CBAiDirectSDK.framework路径,依次查看所有需要合并的lib库所支持的框架类型。</p><pre><code>lipo -info CBAiDirectSDK* 输出: Architectures in the &lt;font color=#DC143C size=4 face=&quot;黑体&quot;&gt;fat&lt;/font&gt; file: CBAiDirectSDK are: i386 x86_64 armv7 arm64 * 解释:看到红色的fat了吗,fat file表示这个库里面合并了多于1个框架。</code></pre></li><li><p>将lib库拆分出armv7、arm64类型的.a:</p><pre><code>    lipo CBAiDirectSDK -thin armv7 -output CBAiDirectSDK_armv7lipo CBAiDirectSDK -thin arm64 -output CBAiDirectSDK_arm64</code></pre></li><li><p>找到CBAiDirectSDK_armv7文件,查看下信息(CBAiDirectSDK_arm64相同)</p><pre><code>lipo -info CBAiDirectSDK_armv7* 输出:Non-fat file: CBAiDirectSDK_armv7 is architecture: armv7</code></pre></li><li><p>合并成最终的静态库</p><pre><code>lipo -create -output CBAiDirectSDK CBAiDirectSDK_armv7 CBAiDirectSDK_arm64</code></pre></li><li><p>查看合成支持的框架类型</p><pre><code>lipo -info CBAiDirectSDK* 输出: Architectures in the fat file: CBAiDirectSDK are: armv7 arm64</code></pre><p>最后替换掉原项目中的CBAiDirectSDK.framework</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明:&quot;&gt;&lt;/a&gt;说明:&lt;/h3&gt;&lt;p&gt;有些第三方提供商为了方便开发者使用,经常把i386 x86_64 armv7 arm64 等几个平台合并到一起,但是上传App Store的时候需要将i386 x86_64两个平台删除后,才能正常审核。&lt;/p&gt;
&lt;h3 id=&quot;一、几个重要概念&quot;&gt;&lt;a href=&quot;#一、几个重要概念&quot; class=&quot;headerlink&quot; title=&quot;一、几个重要概念&quot;&gt;&lt;/a&gt;一、几个重要概念&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;ARM:ARM处理器,特点是体积小、低功耗、低成本、高性能,所以几乎所有手机处理器都基于ARM,在嵌入式系统中应用广泛。&lt;/li&gt;
&lt;li&gt;ARM处理器指令集: armv6 | armv7 | armv7s | arm64都是ARM处理器的指令集,这些指令集都是向下兼容的,例如armv7指令集兼容armv6,只是使用armv6的时候无法发挥出其性能,无法使用armv7的新特性,从而会导致程序执行效率没有那么高。&lt;br&gt;i386 | x86_64是Mac处理器的指令集,i386是针对intel通用微处理器32架构的(虚拟机: iPhone4s iPhone5)。x86_64是针对x86架构的64位处理器(虚拟机: iPhone5S iPhone6 iPhone6S iPhone7 iPhone8 iPhoneX)。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;目前iOS移动设备指令集&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>09- iOS证书申请和使用详情</title>
    <link href="http://waythought.duoshuo.com/2018/01/25/09.iOS%E8%AF%81%E4%B9%A6%E7%94%B3%E8%AF%B7%E5%92%8C%E4%BD%BF%E7%94%A8%E8%AF%A6%E6%83%85/"/>
    <id>http://waythought.duoshuo.com/2018/01/25/09.iOS证书申请和使用详情/</id>
    <published>2018-01-25T10:11:35.427Z</published>
    <updated>2018-04-04T08:33:23.301Z</updated>
    
    <content type="html"><![CDATA[<pre><code>由于公司近期开始接入个推推送,自己也没有详细的总结过iOS证书相关,今天刚好有时间,也就当个记录吧</code></pre><h4 id="一-App-ID-bundle-idengtifier"><a href="#一-App-ID-bundle-idengtifier" class="headerlink" title="一. App ID(bundle idengtifier)"></a>一. App ID(bundle idengtifier)</h4><p>App ID一这是每个应用的独立标识,应该是和Xcode中的Bundle Identifier是一致(Explicit)的或匹配(Wildcard)的。<br>App ID字符串通常以反域名格式Company Identifier 例如 “com.apple.garageband”<br>App ID全名会被追加Application Identifier(一般为TeamID),分为两类:</p><pre><code>* Explicit App ID：唯一的App ID，用于唯一标识一个应用程序。* Wildcard App ID：含有通配符的App ID，用于标识一组应用程序。</code></pre><a id="more"></a><h4 id="二-Certification-证书-cer"><a href="#二-Certification-证书-cer" class="headerlink" title="二. Certification 证书 (.cer)"></a>二. Certification 证书 (.cer)</h4><h5 id="1-开发者证书"><a href="#1-开发者证书" class="headerlink" title="1.开发者证书"></a>1.开发者证书</h5><p>证书是对电脑开发资格的认证,每个开发者账号有一套(2两种):</p><h5 id="1-Developer-Certification-开发证书"><a href="#1-Developer-Certification-开发证书" class="headerlink" title="1) Developer Certification(开发证书)"></a>1) Developer Certification(开发证书)</h5><p>安装在电脑上提供权限: 开发人员通过设备进行真机调试。可以生成副本供多台电脑安装;</p><h5 id="2-Distribution-Certification-发布证书"><a href="#2-Distribution-Certification-发布证书" class="headerlink" title="2) Distribution Certification(发布证书)"></a>2) Distribution Certification(发布证书)</h5><p>安装在电脑提供发布iOS程序的权限: 开发人员可以制做测试版和发布版的程序。不可生成副本,仅有配置该证书的电脑才可使用。</p><h5 id="2-推送证书"><a href="#2-推送证书" class="headerlink" title="2.推送证书"></a>2.推送证书</h5><p>推送证书也分为开发和生产两种,类型分别为APNs Development iOS, APNs Production iOS,该证书在appID配置中创建生成,安装在开发者电脑上。</p><h4 id="三-Devices"><a href="#三-Devices" class="headerlink" title="三. Devices"></a>三. Devices</h4><p>苹果的测试证书、发布证书以及推送证书都有对应的Provisioning Profile文件,来验证当前开发者、当前应用、是否能在该真机设备上测试、安装或者运行。所以,需要对该真机设备的UDID进行注册,生成对应的Provisioning Profiles</p><h4 id="四-Provisioning-Profiles-授权证书-PP描述文件"><a href="#四-Provisioning-Profiles-授权证书-PP描述文件" class="headerlink" title="四. Provisioning Profiles(授权证书 PP描述文件)"></a>四. Provisioning Profiles(授权证书 PP描述文件)</h4><p>授权文件是对设备iPhone、iPad、iPod Touch的授权,文件内记录的是设备的UDID和程序的App ID,也就是被授权的设备即Xcode可以安装或者调试Bundle identifier与授权文件中记录的App id对应的程序</p><h5 id="1-Developer-Provisioning-Profile-开发授权文件"><a href="#1-Developer-Provisioning-Profile-开发授权文件" class="headerlink" title="1)Developer Provisioning Profile(开发授权文件)"></a>1)Developer Provisioning Profile(开发授权文件)</h5><p>在装有开发证书或者开发证书副本的电脑上使用,开发人员选择该授权文件通过电脑将程序安装到授权文件记录的设备中,也就是可以进行真机调试</p><h5 id="2-Distribution-Provisioning-Profile-发布授权文件"><a href="#2-Distribution-Provisioning-Profile-发布授权文件" class="headerlink" title="2)Distribution Provisioning Profile(发布授权文件)"></a>2)Distribution Provisioning Profile(发布授权文件)</h5><p>在装有发布证书的电脑上制作测试版本和发布版本的程序。</p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;由于公司近期开始接入个推推送,自己也没有详细的总结过iOS证书相关,今天刚好有时间,也就当个记录吧
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;一-App-ID-bundle-idengtifier&quot;&gt;&lt;a href=&quot;#一-App-ID-bundle-idengtifier&quot; class=&quot;headerlink&quot; title=&quot;一. App ID(bundle idengtifier)&quot;&gt;&lt;/a&gt;一. App ID(bundle idengtifier)&lt;/h4&gt;&lt;p&gt;App ID一这是每个应用的独立标识,应该是和Xcode中的Bundle Identifier是一致(Explicit)的或匹配(Wildcard)的。&lt;br&gt;App ID字符串通常以反域名格式Company Identifier 例如 “com.apple.garageband”&lt;br&gt;App ID全名会被追加Application Identifier(一般为TeamID),分为两类:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;* Explicit App ID：唯一的App ID，用于唯一标识一个应用程序。
* Wildcard App ID：含有通配符的App ID，用于标识一组应用程序。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>08-.gitignore相关</title>
    <link href="http://waythought.duoshuo.com/2017/10/27/08.gitignore/"/>
    <id>http://waythought.duoshuo.com/2017/10/27/08.gitignore/</id>
    <published>2017-10-27T00:59:59.000Z</published>
    <updated>2018-04-04T08:33:55.237Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-作用"><a href="#1-作用" class="headerlink" title="1.作用:"></a>1.作用:</h4><p>利用.gitignore过滤文件，如编译过程中的中间文件，等等，这些文件不需要被追踪管理。<br><a href="https://github.com/github/gitignore" target="_blank" rel="external"><font size="3">内容参考gitHub</font></a></p><h4 id="2-gitignore无效，不能过滤某些文件"><a href="#2-gitignore无效，不能过滤某些文件" class="headerlink" title="2.gitignore无效，不能过滤某些文件"></a>2.gitignore无效，不能过滤某些文件</h4><a id="more"></a><ul><li>现象：<br>在.gitignore添加file1文件，以过滤该文件，但是通过git status查看仍显示file1文件的状态。</li><li>原因：<br>在git库中已存在了这个文件，之前push提交过该文件。<br>.gitignore文件只对还没有加入版本管理的文件起作用，如果之前已经用git把这些文件纳入了版本库，就不起作用了</li><li>解决：<br>需要在git库中删除该文件，并更新。<br>然后再次git status查看状态，file1文件不再显示状态。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-作用&quot;&gt;&lt;a href=&quot;#1-作用&quot; class=&quot;headerlink&quot; title=&quot;1.作用:&quot;&gt;&lt;/a&gt;1.作用:&lt;/h4&gt;&lt;p&gt;利用.gitignore过滤文件，如编译过程中的中间文件，等等，这些文件不需要被追踪管理。&lt;br&gt;&lt;a href=&quot;https://github.com/github/gitignore&quot;&gt;&lt;font size=&quot;3&quot;&gt;内容参考gitHub&lt;/font&gt;
&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;2-gitignore无效，不能过滤某些文件&quot;&gt;&lt;a href=&quot;#2-gitignore无效，不能过滤某些文件&quot; class=&quot;headerlink&quot; title=&quot;2.gitignore无效，不能过滤某些文件&quot;&gt;&lt;/a&gt;2.gitignore无效，不能过滤某些文件&lt;/h4&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>07-JavaScript &amp;&amp; iOS原生交互</title>
    <link href="http://waythought.duoshuo.com/2017/10/21/07-JavaScript%20&amp;&amp;%20iOS%E5%8E%9F%E7%94%9F%E4%BA%A4%E4%BA%92/"/>
    <id>http://waythought.duoshuo.com/2017/10/21/07-JavaScript &amp;&amp; iOS原生交互/</id>
    <published>2017-10-21T08:33:40.000Z</published>
    <updated>2018-04-04T08:40:33.328Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JavaScript-amp-amp-iOS原生交互"><a href="#JavaScript-amp-amp-iOS原生交互" class="headerlink" title="JavaScript &amp;&amp; iOS原生交互"></a>JavaScript &amp;&amp; iOS原生交互</h3><p>JavaScript &amp;&amp; iOS原生交互第三方框架:<br><a href="https://github.com/marcuswestin/WebViewJavascriptBridge" target="_blank" rel="external">WebViewJavascriptBridge</a></p><h4 id="1-简单用法-OC执行JS"><a href="#1-简单用法-OC执行JS" class="headerlink" title="1. 简单用法(OC执行JS)"></a>1. 简单用法(OC执行JS)</h4><pre><code>UIWebView在webViewDidFinishLoad里使用 - (nullable NSString *)stringByEvaluatingJavaScriptFromString:(NSString *)script;// 获取当前页面的titleNSString *title = [webview stringByEvaluatingJavaScriptFromString:@&quot;document.title&quot;];// 获取当前页面的urlNSString *url = [webview stringByEvaluatingJavaScriptFromString:@&quot;document.location.href&quot;];</code></pre><a id="more"></a><h4 id="2-OC执行JS-amp-amp-JS执行OC"><a href="#2-OC执行JS-amp-amp-JS执行OC" class="headerlink" title="2. OC执行JS &amp;&amp; JS执行OC"></a>2. OC执行JS &amp;&amp; JS执行OC</h4><pre><code>2.1 JavaScriptCore:iOS7后引用,里面包含常见的对象及协议如下:JSContext：给JavaScript提供运行的上下文环境,通过-evaluateScript:方法就可以执行一JS代码JSValue：JavaScript和Objective-C数据和方法的桥梁,封装了JS与ObjC中的对应的类型，以及调用JS的API等JSManagedValue：管理数据和方法的类JSVirtualMachine：处理线程相关，使用较少JSExport：这是一个协议，如果采用协议的方法交互，自己定义的协议必须遵守此协议</code></pre><p>注:</p><blockquote><p>JSContext 和 JSValue : JSVirtualMachine 为JavaScript的运行提供了底层资源,JSContext为JavaScript其提供着运行环境,通过evaluateScript方法就可以执行一段JavaScript脚本,并且如果其中有方法,变量等信息都会被存储在其中以便在需要的时候使用。而JSContext的创建都是基于JSVirtualMachine(initwithVirtualMachine:),如果使用init进行初始化,那么在其内部会自动创建一个新的JSVirtualMachine对象然后调用前边的初始化方法。<br>JSValue是JSContext执行后的返回结果,封装了JS与ObjC中的对应的类型,可以方便的在两种类型之间转换,可以说是JavaScript和Object-C之间互换的桥梁</p></blockquote><pre><code>Objective-C type  |   JavaScript type</code></pre><p>   ——————–+———————<br>           nil         |     undefined<br>          NSNull       |        null<br>         NSString      |       string<br>         NSNumber      |   number, boolean<br>       NSDictionary    |   Object object<br>         NSArray       |    Array object<br>          NSDate       |     Date object<br>         NSBlock (1)   |   Function object (1)<br>            id (2)     |   Wrapper object (2)<br>          Class (3)    | Constructor object (3)</p><blockquote><p>JSVirtualMachine : “A JSVirtualMachine instance represents a self-contained environment for JavaScript execution.”，这段话是官方文档中对JSVirtualMachine的定义，我们使用JSVirtualMachine的目的主要有两个：支持JavaScript并发执行，管理用于衔接JavaScript 与 OC(Swift) 代码的对象的内存。</p></blockquote><p>#####2.1 简单直接调用JS代码<br>        // 一个JSContext对象<br>        self.jsContext = [[JSContext alloc] init];</p><pre><code>//  jscontext可以直接执行JS代码。[self.jsContext evaluateScript:@&quot;var num = 10&quot;];[self.jsContext evaluateScript:@&quot;var squareFunc = function(value) { return value * 2 }&quot;];// 计算正方形的面积JSValue *square = [self.jsContext evaluateScript:@&quot;squareFunc(num)&quot;];// 也可以通过下标的方式获取到方法JSValue *squareFunc = self.jsContext[@&quot;squareFunc&quot;];// 将参数传进去来调用方法JSValue *value = [squareFunc callWithArguments:@[@&quot;20&quot;]];NSLog(@&quot;%@&quot;, square.toNumber);NSLog(@&quot;%@&quot;, value.toNumber);</code></pre><p>#####2.2 快读调用Block,可以传入参数</p><pre><code>JSContext *context = [[JSContext alloc] init];context[@&quot;log&quot;] = ^() {NSLog(@&quot;+++++++Begin Log+++++++&quot;);// 获取当前参数列表NSArray *args = [JSContext currentArguments];for (JSValue *jsVal in args) {NSLog(@&quot;%@&quot;, jsVal);}// 获取当前调用该方法的对象JSValue *this = [JSContext currentThis];NSLog(@&quot;this: %@&quot;,this);NSLog(@&quot;-------End Log-------&quot;);};[context evaluateScript:@&quot;log(&apos;ider&apos;, [7, 21], { hello:&apos;world&apos;, js:100 });&quot;];//// Output:// +++++++Begin Log+++++++// ider// 7,21// [object Object]// this: [object GlobalObject]// -------End Log-------</code></pre><h3 id="3-协议、模型实现"><a href="#3-协议、模型实现" class="headerlink" title="3.协议、模型实现"></a>3.协议、模型实现</h3><p>事先和前端wap协商格式、定义方法的名字和参数的顺序<br>    3.1 定义一个模型 KNOCJSModel<br>    3.2 在该模型实现以下协议(协议中定义需要暴露给js的属性和方法)</p><pre><code>@protocol KNOCJSObjectProtocol &lt;JSExport&gt;// 在JS中调用时，函数名应该为showAlertMsg(arg1, arg2)// 这里是只两个参数的。- (void)showAlert:(NSString *)title msg:(NSString *)msg;// JS调用Oc，然后在OC中通过调用JS方法来传值给JS。- (void)jsCallObjcAndObjcCallJsWithDict:(NSDictionary *)params;@endtypedef void (^KNOCJSModelDetailAlertBlock)(NSString * title, NSString *message);typedef void (^KNOCJSModelDetailCallJsBlock)(NSDictionary *dic);@interface ObjCModel : NSObject &lt;JavaScriptObjectiveCDelegate&gt;@property (nonatomic, copy) KNOCJSModelDetailAlertBlock alertBlock;@property (nonatomic, copy) KNOCJSModelDetailCallJsBlock callJsBlock;@end</code></pre><p>3.3实现模型</p><pre><code>@implementation ObjCModel- (void)showAlert:(NSString *)title msg:(NSString *)msg {    if (self. alertBlock) {        self.alertBlock(title, msg)    }}- (void)jsCallObjcAndObjcCallJsWithDict:(NSDictionary *)params {    if (self. callJsBlock) {        self. callJsBlock(params);    }    }@end</code></pre><p>3.4 在控制器中webView加载完成的代理中,给JSContext注入模型</p><pre><code>#pragma mark - UIWebViewDelegate- (void)webViewDidFinishLoad:(UIWebView *)webView {  JSContext *context = [webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;]; // 通过模型调用方法，这种方式更好些。 KNOCJSModel *objectModel  = [[KNOCJSModel alloc] init]; context[@&quot;native&quot;] = objectModel;__weak typeof(self) weakSelf = selfobjectModel.alertBlock = ^(NSString *title, NSString *msg) {    dispatch_async(dispatch_get_main_queue(), ^{    UIAlertView *alert = [[UIAlertView alloc] initWithTitle:title message:msg delegate:nil cancelButtonTitle:@&quot;Ok&quot; otherButtonTitles:nil, nil];        [alert show];    });};objectModel.callJsBlock = ^(NSDictionary *dic) {    dispatch_async(dispatch_get_main_queue(), ^{        // 第一种方式        JSValue *jsParamFunc = context[@&quot;jsParamFunc&quot;];        [jsParamFunc callWithArguments:@[@{@&quot;age&quot;: @10, @&quot;name&quot;: @&quot;lili&quot;, @&quot;height&quot;: @158}]];        // 第二种方式         NSString *alertUserInfo = [NSString stringWithFormat:@&quot;jsParamFunc(&apos;%@&apos;,&apos;%@&apos;,&apos;%@&apos;)&quot;, @10, @&quot;lili&quot;, @158];        [context evaluateScript:alertUserInfo];    });}; context.exceptionHandler = ^(JSContext *context, JSValue *exceptionValue) {   context.exception = exceptionValue;   NSLog(@&quot;异常信息：%@&quot;, exceptionValue); };}</code></pre><p>3.5 在html中的body中添加以下代码:(这里要和wap端统一好)<font color="#0099ff" size="3" face="黑体">‘native’</font></p><pre><code>    &lt;div style=&quot;margin-top: 100px&quot;&gt;&lt;h1&gt;Test how to use objective-c call js&lt;/h1&gt;&lt;input type=&quot;button&quot; value=&quot;Call ObjC system alert&quot; onclick=&quot;native.showAlertMsg(&apos;js title&apos;, &apos;js message&apos;)&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;input type=&quot;button&quot; value=&quot;Call ObjC func with JSON and ObjC call js func to pass args.&quot; onclick=&quot;native.jsCallObjcAndObjcCallJsWithDict({&apos;name&apos;: &apos;testname&apos;, &apos;age&apos;: 10, &apos;height&apos;: 170})&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;span id=&quot;jsParamFuncSpan&quot; style=&quot;color: red; font-size: 50px;&quot;&gt;&lt;/span&gt;&lt;/div&gt;也可自己在控制器中执行js代码调用- (void)useJSExprot {      JSContext *context = [self.webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;];      KNOCJSModel *objectModel  = [[KNOCJSModel alloc] init];      context[@&quot;native&quot;] = objectModel;      [context evaluateScript:@&quot;objectModel.showAlertMsg()&quot;]}</code></pre><p>保留:<br>    1.在Block内都不要直接使用其外部定义的JSContext对象或者JSValue，应该将其当做参数传入到Block中，或者通过JSContext的类方法+ (JSContext *)currentContext;来获得。否则会造成循环引用使得内存无法被正确释放。<br>    2.如果js端的方法是这样的<br>func viewDetailLoginNamePassWord(String name, String passWord) {</p><p>}</p><p>我们可以用<br>第一种:</p><ul><li>(void)viewDetailLoginName:(NSString *)loginName<pre><code>PassWord:(NSString *)passWord;</code></pre></li></ul><p>第二种:<br>JSExportAs(viewDetailLoginNamePassWord,<br>           -(void)viewDetailLoginNamePassWord:(NSString <em>)loginName psd:(NSString </em>)psd;)<br><a href="http://www.jianshu.com/p/fad8c7844d3e" target="_blank" rel="external">http://www.jianshu.com/p/fad8c7844d3e</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;JavaScript-amp-amp-iOS原生交互&quot;&gt;&lt;a href=&quot;#JavaScript-amp-amp-iOS原生交互&quot; class=&quot;headerlink&quot; title=&quot;JavaScript &amp;amp;&amp;amp; iOS原生交互&quot;&gt;&lt;/a&gt;JavaScript &amp;amp;&amp;amp; iOS原生交互&lt;/h3&gt;&lt;p&gt;JavaScript &amp;amp;&amp;amp; iOS原生交互第三方框架:&lt;br&gt;&lt;a href=&quot;https://github.com/marcuswestin/WebViewJavascriptBridge&quot;&gt;WebViewJavascriptBridge&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;1-简单用法-OC执行JS&quot;&gt;&lt;a href=&quot;#1-简单用法-OC执行JS&quot; class=&quot;headerlink&quot; title=&quot;1. 简单用法(OC执行JS)&quot;&gt;&lt;/a&gt;1. 简单用法(OC执行JS)&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;UIWebView在webViewDidFinishLoad里使用 - (nullable NSString *)stringByEvaluatingJavaScriptFromString:(NSString *)script;
// 获取当前页面的title
NSString *title = [webview stringByEvaluatingJavaScriptFromString:@&amp;quot;document.title&amp;quot;];

// 获取当前页面的url
NSString *url = [webview stringByEvaluatingJavaScriptFromString:@&amp;quot;document.location.href&amp;quot;];
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>06-Objectview-C 中变量采用@property的各个关键字的含义</title>
    <link href="http://waythought.duoshuo.com/2017/10/17/06-Objectview-C%20%E4%B8%AD%E5%8F%98%E9%87%8F%E9%87%87%E7%94%A8@property%E7%9A%84%E5%90%84%E4%B8%AA%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%90%AB%E4%B9%89/"/>
    <id>http://waythought.duoshuo.com/2017/10/17/06-Objectview-C 中变量采用@property的各个关键字的含义/</id>
    <published>2017-10-17T07:44:24.000Z</published>
    <updated>2018-04-04T08:35:44.137Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Objectview-C-中变量采用-property的各个关键字的含义"><a href="#Objectview-C-中变量采用-property的各个关键字的含义" class="headerlink" title="Objectview-C 中变量采用@property的各个关键字的含义"></a>Objectview-C 中变量采用@property的各个关键字的含义</h3><h4 id="1-property的本质是什么"><a href="#1-property的本质是什么" class="headerlink" title="1.@property的本质是什么?"></a>1.@property的本质是什么?</h4><p>@property = ivar + getter + setter<br>“属性”(property) = 实例变量 + 存取方法<br>OC2.0开始,系统提供了自动生成设置变量值得方法或获取变量值得方法,让我们有更多的精力放在程序的业务逻辑上</p><h4 id="2-ARC下-不显示指定任何属性性关键字时-默认的关键字有哪些"><a href="#2-ARC下-不显示指定任何属性性关键字时-默认的关键字有哪些" class="headerlink" title="2.ARC下,不显示指定任何属性性关键字时,默认的关键字有哪些?"></a>2.ARC下,不显示指定任何属性性关键字时,默认的关键字有哪些?</h4><pre><code>对于基本数据类型默认关键字是:atomic,readwrite,assign对于普通的OC对象:atomic,readwrite,strong</code></pre><a id="more"></a><h4 id="3-copy关键字"><a href="#3-copy关键字" class="headerlink" title="3.copy关键字"></a>3.copy关键字</h4><pre><code>3.1 NSString,NSArray,NSDictionary等等经常使用copy关键字,是因为他们有对应的可变类型:NSMutableString、NSMutableArray、NSMutableDictionary；是对应的子类,他们之间可能进行赋值操作,为确保对象中的字符串值不会无意间变动,应该在设置新属性值时拷贝一份3.2 block 也经常使用copy关键字,这是从MRC遗留下的&quot;传统&quot;,在MRC中,方法内部的block是在栈区的,使用copy可以把它放在堆区;ARC中写不写都行: 对于block使用copy还是strong效果是一样的,但写上copy能够提醒我们:编译器自动对block进行了copy操作。3.3 小试牛刀:    这个写法会出什么问题 @property (copy) NSMutableArray *array;    3.3.1 添加,删除,修改数组内的元素的时候,程序会因为找不到对应的方法而崩溃,因为copy是复制的一个不可变的NSArray的对象    3.3.2 默认关键字是atomic属性会严重影响性能</code></pre><h4 id="4-weak-关键字"><a href="#4-weak-关键字" class="headerlink" title="4. weak 关键字"></a>4. weak 关键字</h4><pre><code>4.1 在ARC中,有可能出现循环引用的时候,往往要通过让其中一端使用weak来解决,比如delegate代理4.2 自身已经对它进行一次强引用,没有必要再强引用一次,此时也会使用weak,自定义IBOutlet控件的属性一般也使用weak。</code></pre><h4 id="5-assign"><a href="#5-assign" class="headerlink" title="5. assign"></a>5. assign</h4><pre><code>只会执行基本类型的简单赋值操作,既不保留新值,也不释放旧值。</code></pre><h4 id="6-retain"><a href="#6-retain" class="headerlink" title="6. retain"></a>6. retain</h4><pre><code>释放旧的对象，将旧对象的值赋予输入对象，再提高输入对象的索引计数为1</code></pre><h4 id="7-nonnull"><a href="#7-nonnull" class="headerlink" title="7.nonnull:"></a>7.nonnull:</h4><pre><code>不能为空,用来修饰属性,或者方法的参数,方法的返回值,不适用于assign属性,因为他是专门用来修饰指针的 @property (nonatomic, copy, nonnull) NSString *name;  @property (nonatomic, copy) NSString * _Nonnull name;   @property (nonatomic, copy) NSString * __nonnull name;</code></pre><h4 id="8-nullable"><a href="#8-nullable" class="headerlink" title="8.nullable:"></a>8.nullable:</h4><pre><code>表示可以为空,代码提示会告诉你这个谁能够是可以为空的@property (nonatomic, copy, nullable) NSString *name;@property (nonatomic, copy) NSString *_Nullable name;@property (nonatomic, copy) NSString *__nullable name;</code></pre><h4 id="9-null-resettable"><a href="#9-null-resettable" class="headerlink" title="9.null_resettable:"></a>9.null_resettable:</h4><pre><code>表示get方法不能返回为空,set方法可以为空 ⚠️⚠️⚠️ 必须重写该属性的get方法,保证返回值不为空tan @property(nonatomic,strong,null_resettable) NSNumber * number;(只有这一种方式)</code></pre><h4 id="10-null-unspecified"><a href="#10-null-unspecified" class="headerlink" title="10.null_unspecified"></a>10.null_unspecified</h4><pre><code>表示不确定是否为空,使用方式有三种: @property(nonatomic,strong) NSNumber *_Null_unspecified height; @property(nonatomic,strong) NSNumber *__null_unspecified height;  @property(nonatomic,strong,null_unspecified) NSNumber * height;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Objectview-C-中变量采用-property的各个关键字的含义&quot;&gt;&lt;a href=&quot;#Objectview-C-中变量采用-property的各个关键字的含义&quot; class=&quot;headerlink&quot; title=&quot;Objectview-C 中变量采用@property的各个关键字的含义&quot;&gt;&lt;/a&gt;Objectview-C 中变量采用@property的各个关键字的含义&lt;/h3&gt;&lt;h4 id=&quot;1-property的本质是什么&quot;&gt;&lt;a href=&quot;#1-property的本质是什么&quot; class=&quot;headerlink&quot; title=&quot;1.@property的本质是什么?&quot;&gt;&lt;/a&gt;1.@property的本质是什么?&lt;/h4&gt;&lt;p&gt;@property = ivar + getter + setter&lt;br&gt;“属性”(property) = 实例变量 + 存取方法&lt;br&gt;OC2.0开始,系统提供了自动生成设置变量值得方法或获取变量值得方法,让我们有更多的精力放在程序的业务逻辑上&lt;/p&gt;
&lt;h4 id=&quot;2-ARC下-不显示指定任何属性性关键字时-默认的关键字有哪些&quot;&gt;&lt;a href=&quot;#2-ARC下-不显示指定任何属性性关键字时-默认的关键字有哪些&quot; class=&quot;headerlink&quot; title=&quot;2.ARC下,不显示指定任何属性性关键字时,默认的关键字有哪些?&quot;&gt;&lt;/a&gt;2.ARC下,不显示指定任何属性性关键字时,默认的关键字有哪些?&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;对于基本数据类型默认关键字是:atomic,readwrite,assign
对于普通的OC对象:atomic,readwrite,strong
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>05-git教程</title>
    <link href="http://waythought.duoshuo.com/2017/07/07/05-git%E6%95%99%E7%A8%8B/"/>
    <id>http://waythought.duoshuo.com/2017/07/07/05-git教程/</id>
    <published>2017-07-07T04:34:25.000Z</published>
    <updated>2018-03-05T02:25:35.218Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>SVN: 集中式的版本控制系统. 本地只有文件,没有版本库,所有的代码只在服务器上有版本记录,如果要进行版本的回退,和一些tag操作,必须经过服务器</p></li><li><p>Git: 分布式版本控制系统,每个人电脑就有版本库.写完代码,先提交到本地的版本,让后提交到服务器上,最后每个电脑都有一个最新的代码</p><pre><code>git也要配置服务器, 但是服务器的作用, 只是作为一个中间桥梁供开发人员去同步代码用的.git有机器强大的分支管理,把SVN等远远抛在了后面</code></pre></li></ul><h4 id="1-远程仓库"><a href="#1-远程仓库" class="headerlink" title="1.远程仓库"></a>1.远程仓库</h4><ul><li><p>1.1 创建SSH Key. 在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。使用以下命令创建SSH Key：(替换成你的邮箱地址).</p><pre><code>$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</code></pre></li><li><p>1.2 在用户主目录中找到.ssh目录,里面有id_rsa(私钥)和id_rea.pub(公钥),打开id_rea.pub并记录下来.</p></li><li><p>1.3 登录GitHub,打开”Account settings”,”SSH Key”页面,添加Key,把id_rea.pub内容添加进去.</p><pre><code>git需要在GitHup,OsChina,GitLabel中添加自己的公钥由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的,GitHub只要知道了你的公钥,就可以在每台电脑上往GitHub推送了.</code></pre><a id="more"></a></li><li><p>1.4 添加远程库</p><pre><code>在GitHub上创建仓库,使用下面命令,把这个远程的仓库与本地已有的仓库进行关联,之后就可以把本地仓库的内容推送到GitHub仓库了,注意是SSH的,传输相比http稳定cd 到本地文件        $ git remote add origin git@github.com:WayThought/blog.git</code></pre></li></ul><p>git remote  查看远程库的信息</p><pre><code>$ git remote origin或者，用git remote -v显示更详细的信息：</code></pre><ul><li><p>1.5 从远程库克隆(当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。)</p><pre><code> cd 到本地文件        $ git clone git@github.com:WayThought/blog.git</code></pre><p>这样就把远程的仓库克隆到了本地</p></li></ul><h4 id="2-本地分支管理"><a href="#2-本地分支管理" class="headerlink" title="2.本地分支管理"></a>2.本地分支管理</h4><p>git status: 查看文件的状态</p><p>git add : 提交有修改的文件,由工作区到暂存区</p><pre><code>git add 文件名  添加指定修改的文件到暂存区git add .  添加当前目录所有有修改的文件到暂存区</code></pre><p>git commit : 提交暂存区的文件到本地版本库</p><pre><code>git commit -m &quot;注释&quot; 文件名  提交指定的文件到本地仓库git commit -m &quot;注释&quot;        提交所有的文件到本地仓库</code></pre><p>(需要提交的改动文件,必须先add加到缓存区,再commit到版本区)</p><p>git pull和push命令是本地仓库和远程仓库(服务器)打交道的,一般在push之前都会先pull下代码,如果有冲突,解决完冲突再push</p><pre><code>git pull 从服务器上更新代码到本地仓库,切换到本地需要提交的分支(dev)git pull origin dev  把服务器远程仓库更新的代码拉到本地仓库git push origin dev  把本地仓库的代码更新推送到服务器上</code></pre><p>创建与合并分支(当前分支为master)</p><pre><code>git branch  查看当前分支git branch dev origin/dev 切换到分支devgit checkout dev    切换到分支devgit checkout -b dev   创建dev分支,然后切换到dev分支git merge dev  把dev的工作内容合并到master上(分支A合并分支B,与分支B合并分支A是一样的)</code></pre><h4 id="3-版本回退"><a href="#3-版本回退" class="headerlink" title="3.版本回退"></a>3.版本回退</h4><pre><code>git log  显示历史记录(写周报或者查看版本号)git reflog 来记录你的每一次命令(版本回退后,可以找到上一个版本的commit id )git reset --hard HEAD^ 回退到上一个版本git reset --hard HEAD^^ 回退到上上个版本git reset --hard HEAD 版本号 回退到指定的版本注: 如何找回删除的分支    3.1 通过git reflog 命令找到我们需要恢复的信息对应的commit_id (根据log 提交的日期时间)    3.2 通过git branch 新分支名字 对应的commit_id 来建立一个新的分支,吧丢失的东西恢复到新分支上</code></pre><h4 id="4-补充"><a href="#4-补充" class="headerlink" title="4.补充:"></a>4.补充:</h4><p>4.1 常用命令:<br>    git config user.name 查看用户名<br>    git config user.email 查看邮箱地址<br>    git config –global user.name “Your Name”  提交名字<br>    git config –global user.email you@example.com  提交邮箱</p><pre><code>git co  -- &lt;file&gt;   # 抛弃工作区修改git co  .           # 抛弃工作区修改git rm &lt;file&gt;       # 从版本库中删除文件git rm &lt;file&gt; --cached  # 从版本库中删除文件，但不删除文件git reset &lt;file&gt;    # 从暂存区恢复到工作文件git reset -- .      # 从暂存区恢复到工作文件git reset --hard    # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改git stash listgit stash pop  恢复的同时把stash内容也删了git checkout -- readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销git checkout -- . 把工作区的修改全部撤销(版本相同的两个分支)未add和commit的内容如果checkout另一个分支会带过去 可以来回切换</code></pre><p>4.2 常见问题:</p><p>4.2.1 git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接：</p><pre><code>$ git branch --set-upstream dev origin/dev</code></pre><p>4.2.2 将本地项目添加到远程的仓库</p><pre><code>1.远程建立仓库,并克隆到本地(例如:storeHouse)2.将本地的项目拷贝到storeHouse文件中3.使用 git init 命令4.使用 $ git remote add origin git@github.com:WayThought/blog.git 5. git add . 6. git commit 7. git push </code></pre><p>4.2.3 将本地分支推送到远程分支:(如果远程分支不存在则会自动创建分支)<br>git push origin 本地分支名:远程分支名<br>4.2.4 远程分支版本的回退</p><pre><code>切换到本地分支对应着的远程分支git push origin HEAD --force #远程提交回退</code></pre><p>4.2.5 删除远程分支<br>git push origin –delete 远程分支名</p><p>4.2.6 强制覆盖分支<br>git push origin develop:master -f<br>把本地的 develop 分支强制(-f)推送到远程 master</p><p>4.3 补充：<br>查看本地分支与远端分支的差异：<br>git diff master..远程仓库名字/master<br>4.4 将本地分支推送到远端服务器：<br>git push 远程仓库名字 分支名字<br>4.4 寻找回退的commit-id(后悔药)<br>git reflog</p><p>ea34578 HEAD@{0}: reset: moving to HEAD^<br>3628164 HEAD@{1}: commit: append GPL<br>ea34578 HEAD@{2}: commit: add distributed<br>做完后面的操作的形成前面的commit-id</p><h3 id="5-0冲突"><a href="#5-0冲突" class="headerlink" title="5.0冲突"></a>5.0冲突</h3><h4 id="5-1常见冲突"><a href="#5-1常见冲突" class="headerlink" title="5.1常见冲突:"></a>5.1常见冲突:</h4><pre><code>第一种: 项目可以打开,报错-&gt;直接去找,对别人的改动要进行沟通决定是否要保留第二种: 项目打开失败git status 查看哪个文件冲突(一般是配置文件)open 路径 搜索&quot;===“,删除后没有恢复的话 说明删除错误了 -&gt;重新删除&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADCreating a new branch is quick &amp; simple.=======Creating a new branch is quick AND simple.&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1</code></pre><p>上面那个是HEAD分支的,下面这个是feature1分支,沟通后决定保留或删除</p><h4 id="5-2-pbxproj文件冲突"><a href="#5-2-pbxproj文件冲突" class="headerlink" title="5.2 pbxproj文件冲突"></a>5.2 pbxproj文件冲突</h4><p>比较麻烦的一种冲突,企业开发经常会遇到project.pbxproj文件冲突的问题,project.pbxproj文件主要包含了以下几项主要信息:</p><pre><code>1.工程文件关联信息, 如PBXBuildFile PBXFileReference2.组织结构分类信息, 如PBXGroup3.项目工程配置信息, 如XCBuildConfiguration XCConfigurationList</code></pre><p>解决办法:</p><pre><code>1. 1.1 笨方法1: 由于删除自己的修改的部分还是没有办法打开工程,所以要将上一个版本的project.pbxproj文件导出来，替换掉现有的project.pbxproj文件,但是添加到工程中的文件不见了,后来其实在工程里面看不到了而已,在对应文件目录还是能找到的,只要将这些文件拖一遍到工程里就ok了,(注意看下工程的Compile Sources,有时候会不显示添加的类)    1.2 笨方法2: 将project.pbxproj文件文件中一个版本的的冲突都删除掉,根据编译报的错误去添加对应的类(注意不要重复添加),在对应文件目录还是能找到的,只要将这些文件拖一遍到工程里就ok了2.预防:需要增加文件时先增加完空文件后立刻check一次，让别人每次改动 pbxproj的时候改动之前check一次，保证有交叉时间是可能性最小3.将不同分支导致的对象进行重新排序,先排序冲突里面相同的对象,然后是重命名或移动了的对象,最后是两边各自新增的对象,(根据sourceCode进行排序)</code></pre><h3 id="5-3-git-push-报以下错误"><a href="#5-3-git-push-报以下错误" class="headerlink" title="5.3 git push 报以下错误:"></a>5.3 git push 报以下错误:</h3><pre><code>错误error: RPC failed; result=22, HTTP code = 413fatal: The remote end hung up unexpectedlyfatal: The remote end hung up unexpectedly解决:第一种. 将http切换成ssh,在git的config中修改url( changed it to the SSH address, and everything resumed working flawlessly)第二种. 继续使用http,运行    git config http.postBuffer 524288000第三种。 git push -u origin 分支(这种没有亲自尝试过,可以试试)</code></pre><h3 id="6-0-建议"><a href="#6-0-建议" class="headerlink" title="6.0 建议"></a>6.0 建议</h3><pre><code>项目开发的时候 可以单独建立一个分支dev_x  并行发开人员的每天或者几天合并下代码,合并到dev_x  比较方便,避免最后批量合并代码</code></pre><p>参考资料:<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/" target="_blank" rel="external">廖雪峰的博客</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;SVN: 集中式的版本控制系统. 本地只有文件,没有版本库,所有的代码只在服务器上有版本记录,如果要进行版本的回退,和一些tag操作,必须经过服务器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Git: 分布式版本控制系统,每个人电脑就有版本库.写完代码,先提交到本地的版本,让后提交到服务器上,最后每个电脑都有一个最新的代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git也要配置服务器, 但是服务器的作用, 只是作为一个中间桥梁供开发人员去同步代码用的.
git有机器强大的分支管理,把SVN等远远抛在了后面
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;1-远程仓库&quot;&gt;&lt;a href=&quot;#1-远程仓库&quot; class=&quot;headerlink&quot; title=&quot;1.远程仓库&quot;&gt;&lt;/a&gt;1.远程仓库&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;1.1 创建SSH Key. 在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。使用以下命令创建SSH Key：(替换成你的邮箱地址).&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ssh-keygen -t rsa -C &amp;quot;youremail@example.com&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;1.2 在用户主目录中找到.ssh目录,里面有id_rsa(私钥)和id_rea.pub(公钥),打开id_rea.pub并记录下来.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;1.3 登录GitHub,打开”Account settings”,”SSH Key”页面,添加Key,把id_rea.pub内容添加进去.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git需要在GitHup,OsChina,GitLabel中添加自己的公钥
由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的,GitHub只要知道了你的公钥,就可以在每台电脑上往GitHub推送了.
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>04-Code Review</title>
    <link href="http://waythought.duoshuo.com/2017/06/21/04-%E4%BB%A3%E7%A0%81%E5%AE%A1%E6%9F%A5%E6%B8%85%E5%8D%95/"/>
    <id>http://waythought.duoshuo.com/2017/06/21/04-代码审查清单/</id>
    <published>2017-06-21T07:03:43.000Z</published>
    <updated>2018-03-09T01:49:54.402Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Code-Review"><a href="#Code-Review" class="headerlink" title="Code Review"></a>Code Review</h2><h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><ul><li>1.在项目早起就能发现代码中的bug</li><li>2.项目统一代码风格,项目代码更容易维护</li><li>3.避免开发人员犯一些很常见,很普通的错误(可预测性检查)</li></ul><h4 id="常规项"><a href="#常规项" class="headerlink" title="常规项"></a>常规项</h4><ul><li>1.代码能够工作吗？它有没有实现预期的功能，逻辑是否正确等。</li><li>2.代码符合你遵循的编程规范吗？通常包括大括号的位置，变量名和函数名，行的长度，缩进，格式和注释等风格是否保持一致。</li><li>3.是否存在多余的或是重复的代码？</li><li>4.代码是否尽可能的模块化了？</li><li>5.是否有可以被替换的全局变量？</li><li>6.是否有被注释掉的代码？所有的注释是否是准确的?</li><li>7.健壮性：是否考虑线程安全；边界处理是否完整；数据的越界处理；被零除,有没有内存泄漏；逻辑是否健壮；循环引用（block中的self和weakSelf）<a id="more"></a></li></ul><h4 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h4><ul><li>1.所有的数据输入是否都进行了检查（检测正确的类型，长度，格式和范围）并且进行了编码？</li><li>2.在哪里使用了第三方工具，返回的错误是否被捕获？</li><li>3.输入的值是够进行了检查和编码？</li><li>4.无效的参数值是否能够处理？</li></ul><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>把使用清单作为你的起点，针对特定的使用案例，需要对其进行优化。一个比较棒的方式就是记录下那些在代码审查过程中临时发现的问题，有了这些数据，能够明确常犯的错误，然后可以量身定制一个审查清单。确保删除了那些没有出现过的错误。</p><h4 id="代码审查清单"><a href="#代码审查清单" class="headerlink" title="代码审查清单"></a>代码审查清单</h4><ul><li>1.基础: iOS规范指南</li><li>2.控件的创建尽量放到Setter和Getter中进行懒加载,不要写在viewDidLoad中</li><li>3.block中的self需要替换成weakSelf防止循环引用,形成好的习惯。</li><li>4.多余控件和控制器的删除。被注释掉的代码是否有必要保留？所有的注释是否是准确的?</li><li>5.base类中已经存在满足需求控件和方法不需要再重新定义(例如UITableView及其分页、刷新)</li><li>6.手动开启线程要谨慎。</li></ul><h4 id="获取认可并且保持更新"><a href="#获取认可并且保持更新" class="headerlink" title="获取认可并且保持更新"></a>获取认可并且保持更新</h4><p>基本规则是，清单上的人和条目都必须明确，而且，如果可能的话，对于一些条目你可以对其进行二元判断。这样可以防止判断的不一致。定期检查你的清单，以确保各条目仍然是有意义的。</p><h4 id="责任："><a href="#责任：" class="headerlink" title="责任："></a>责任：</h4><p>代码编写者，代码审核者共同对代码的质量承担责任。这样才能保证Code Review不是走过场.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Code-Review&quot;&gt;&lt;a href=&quot;#Code-Review&quot; class=&quot;headerlink&quot; title=&quot;Code Review&quot;&gt;&lt;/a&gt;Code Review&lt;/h2&gt;&lt;h4 id=&quot;目的&quot;&gt;&lt;a href=&quot;#目的&quot; class=&quot;headerlink&quot; title=&quot;目的&quot;&gt;&lt;/a&gt;目的&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;1.在项目早起就能发现代码中的bug&lt;/li&gt;
&lt;li&gt;2.项目统一代码风格,项目代码更容易维护&lt;/li&gt;
&lt;li&gt;3.避免开发人员犯一些很常见,很普通的错误(可预测性检查)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;常规项&quot;&gt;&lt;a href=&quot;#常规项&quot; class=&quot;headerlink&quot; title=&quot;常规项&quot;&gt;&lt;/a&gt;常规项&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;1.代码能够工作吗？它有没有实现预期的功能，逻辑是否正确等。&lt;/li&gt;
&lt;li&gt;2.代码符合你遵循的编程规范吗？通常包括大括号的位置，变量名和函数名，行的长度，缩进，格式和注释等风格是否保持一致。&lt;/li&gt;
&lt;li&gt;3.是否存在多余的或是重复的代码？&lt;/li&gt;
&lt;li&gt;4.代码是否尽可能的模块化了？&lt;/li&gt;
&lt;li&gt;5.是否有可以被替换的全局变量？&lt;/li&gt;
&lt;li&gt;6.是否有被注释掉的代码？所有的注释是否是准确的?&lt;/li&gt;
&lt;li&gt;7.健壮性：是否考虑线程安全；边界处理是否完整；数据的越界处理；被零除,有没有内存泄漏；逻辑是否健壮；循环引用（block中的self和weakSelf）&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>03-iOS单元测试</title>
    <link href="http://waythought.duoshuo.com/2017/06/21/03-iOS%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    <id>http://waythought.duoshuo.com/2017/06/21/03-iOS单元测试/</id>
    <published>2017-06-21T07:03:43.000Z</published>
    <updated>2018-01-03T09:29:59.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>我是从去年开始写单元测试的,平常也只是使用测试一下接口的测试,最近有时间网上查找下了资料总结一下,也是有个归纳吧</p><h2 id="单元测试简介"><a href="#单元测试简介" class="headerlink" title="单元测试简介"></a>单元测试简介</h2><blockquote><p>单元测试是指开发者编写代码,检测代码。合理的利用单元测试可以提高软件的质量</p><p>代码检测通常需要预先设置边界条件,因为UI测试的时候,很多边界条件不容易满足。主要针对<font color="#0099ff" size="3" face="黑体">业务逻辑</font>进行测试,不适合做UI的测试。</p><p>MVVM的设计模式,把几乎所有重要的业务逻辑全部封装在视图模型中,通过单元测试就很方便检测条件以及代码质量。</p></blockquote><h2 id="什么方法或者函数需要测试"><a href="#什么方法或者函数需要测试" class="headerlink" title="什么方法或者函数需要测试"></a>什么方法或者函数需要测试</h2><pre><code>1.私有方法不需要测试,面向对象有一个原则:开闭原则! 暴露在.h中的方法需要测试,2. 所有跟UI有关的都不需要测试,有UI的交互。MVVM 把小的业务逻辑封装出来,变成可以测试的代码,让程序更加健壮。3.一般而言,代码的覆盖度大概在50% ~ 70%</code></pre><h2 id="苹果自带的XCTest"><a href="#苹果自带的XCTest" class="headerlink" title="苹果自带的XCTest"></a>苹果自带的XCTest</h2><pre><code>/** 单元测试开始前调用 */- (void)setUp {[supersetUp];// Put setup code here. This method is called before the invocation of each test method in the class.}</code></pre><a id="more"></a><pre><code>/** 单元测试结束前调用 */- (void)tearDown {// Put teardown code here. This method is called after the invocation of each test method in the class.[supertearDown];}/** 测试代码可以写到以test开头的方法中 并且test开头的方法左边会生成一个菱形图标，点击即可运行检测当前test方法内的代码 */- (void)testExample {// This is an example of a functional test case.// Use XCTAssert and related functions to verify your tests produce the correct results.}/** 测试性能 */- (void)testPerformanceExample {// This is an example of a performance test case.[selfmeasureBlock:^{// 测量执行时间的代码放到这里// Put the code you want to measure the time of here.}];}</code></pre><h2 id="断言命令"><a href="#断言命令" class="headerlink" title="断言命令"></a>断言命令</h2><p>XCTFail(format…) 生成一个失败的测试；</p><p>XCTAssertNil(a1, format…)为空判断，a1为空时通过，反之不通过；</p><p>XCTAssertNotNil(a1, format…)不为空判断，a1不为空时通过，反之不通过；</p><p>XCTAssert(expression, format…)当expression求值为TRUE时通过；</p><p>XCTAssertTrue(expression, format…)当expression求值为TRUE时通过；</p><p>XCTAssertFalse(expression, format…)当expression求值为False时通过；</p><p>XCTAssertEqualObjects(a1, a2, format…)判断相等，[a1 isEqual:a2]值为TRUE时通过，其中一个不为空时，不通过；</p><p>XCTAssertNotEqualObjects(a1, a2, format…)判断不等，[a1 isEqual:a2]值为False时通过，</p><p>XCTAssertEqual(a1, a2, format…)判断相等（当a1和a2是 C语言标量、结构体或联合体时使用,实际测试发现NSString也可以）；</p><p>XCTAssertNotEqual(a1, a2, format…)判断不等（当a1和a2是 C语言标量、结构体或联合体时使用）；</p><p>XCTAssertEqualWithAccuracy(a1, a2, accuracy, format…)判断相等，（double或float类型）提供一个误差范围，当在误差范围（+/-accuracy）以内相等时通过测试；</p><p>XCTAssertNotEqualWithAccuracy(a1, a2, accuracy, format…) 判断不等，（double或float类型）提供一个误差范围，当在误差范围以内不等时通过测试；</p><p>XCTAssertThrows(expression, format…)异常测试，当expression发生异常时通过；反之不通过；（很变态）</p><p>XCTAssertThrowsSpecific(expression, specificException, format…) 异常测试，当expression发生specificException异常时通过；反之发生其他异常或不发生异常均不通过；</p><p>XCTAssertThrowsSpecificNamed(expression, specificException, exception_name, format…)异常测试，当expression发生具体异常、具体异常名称的异常时通过测试，反之不通过；</p><p>XCTAssertNoThrow(expression, format…)异常测试，当expression没有发生异常时通过测试；</p><h2 id="单元测试的适用情况以及覆盖率"><a href="#单元测试的适用情况以及覆盖率" class="headerlink" title="单元测试的适用情况以及覆盖率"></a>单元测试的适用情况以及覆盖率</h2><p>对于测试用例覆盖度多少合适这个话题,也是仁者见仁智者见智,其实一个软件覆盖度在50%以上就可以成为一个健壮的软件了,要达到70%,80%这些已经非常难了,不过我们常见的一些第三方开源框架的测试用例覆盖率还是非常高的,例如AFNNetWorking的覆盖率高达87%,SDWebImage的覆盖率高达77%</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;单元测试&quot;&gt;&lt;a href=&quot;#单元测试&quot; class=&quot;headerlink&quot; title=&quot;单元测试&quot;&gt;&lt;/a&gt;单元测试&lt;/h2&gt;&lt;p&gt;我是从去年开始写单元测试的,平常也只是使用测试一下接口的测试,最近有时间网上查找下了资料总结一下,也是有个归纳吧&lt;/p&gt;
&lt;h2 id=&quot;单元测试简介&quot;&gt;&lt;a href=&quot;#单元测试简介&quot; class=&quot;headerlink&quot; title=&quot;单元测试简介&quot;&gt;&lt;/a&gt;单元测试简介&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;单元测试是指开发者编写代码,检测代码。合理的利用单元测试可以提高软件的质量&lt;/p&gt;
&lt;p&gt;代码检测通常需要预先设置边界条件,因为UI测试的时候,很多边界条件不容易满足。主要针对&lt;font color=&quot;#0099ff&quot; size=&quot;3&quot; face=&quot;黑体&quot;&gt;业务逻辑&lt;/font&gt;进行测试,不适合做UI的测试。&lt;/p&gt;
&lt;p&gt;MVVM的设计模式,把几乎所有重要的业务逻辑全部封装在视图模型中,通过单元测试就很方便检测条件以及代码质量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;什么方法或者函数需要测试&quot;&gt;&lt;a href=&quot;#什么方法或者函数需要测试&quot; class=&quot;headerlink&quot; title=&quot;什么方法或者函数需要测试&quot;&gt;&lt;/a&gt;什么方法或者函数需要测试&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;1.私有方法不需要测试,面向对象有一个原则:开闭原则! 暴露在.h中的方法需要测试,
2. 所有跟UI有关的都不需要测试,有UI的交互。MVVM 把小的业务逻辑封装出来,变成可以测试的代码,让程序更加健壮。
3.一般而言,代码的覆盖度大概在50% ~ 70%
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;苹果自带的XCTest&quot;&gt;&lt;a href=&quot;#苹果自带的XCTest&quot; class=&quot;headerlink&quot; title=&quot;苹果自带的XCTest&quot;&gt;&lt;/a&gt;苹果自带的XCTest&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;/** 单元测试开始前调用 */
- (void)setUp {
[supersetUp];
// Put setup code here. This method is called before the invocation of each test method in the class.
}
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>02-Mac上安装oh-my-zsh以及iterm2的使用</title>
    <link href="http://waythought.duoshuo.com/2017/06/21/02-mac%E4%B8%8A%E5%AE%89%E8%A3%85oh-my-zsh%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
    <id>http://waythought.duoshuo.com/2017/06/21/02-mac上安装oh-my-zsh以及应用/</id>
    <published>2017-06-21T07:02:42.000Z</published>
    <updated>2017-10-31T12:45:18.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Mac上安装oh-my-zsh"><a href="#Mac上安装oh-my-zsh" class="headerlink" title="Mac上安装oh-my-zsh"></a>Mac上安装oh-my-zsh</h3><ul><li><p>1 克隆项目本地(Mac默认已经安装git) </p><pre><code>git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh</code></pre></li><li><p>2 创建一个zsh的配置文件 </p><pre><code>cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc</code></pre><p>  备注:~ 代表:你的/home/用户名的目录,假设你的用户名是user,那么~/就是/home/user/. .是代表此目录本身,但是一般可以不写,所以cd ~/. 和 cd ~ 和cd ~/效果是一样的.但是.后面有东西又是另外一个问题,点在文件名头部,代表一个隐藏文件. ~/.local是你的主目录下下一个.local的文件夹的路径,并且从.可以看出,这是一个隐藏文件,使用ls -a显示.</p></li><li><p>3 设置zsh为默认的shell</p><pre><code>chsh -s /bin/zsh</code></pre></li><li><p>4 重启终端生效</p><a id="more"></a></li><li><p>5 设置ZSH主题:<br>   5.1 到你的用户名目录</p><pre><code>$ cd ~/</code></pre><p>   5.2 显示文件(包括隐藏文件),并打开.zshrc</p><pre><code>$ ls -a $ open .zshrc</code></pre><p>   5.3 找到 ZSH_THEME=“robbyrussell”,并注释掉(行头加 #),另起一行,换上你喜欢的主题,我使用的ys.zsh-theme(补充:直接在原来的行上替换,有时候会出现替换是失败的情况,所以注释掉原来的,重新写是最好的选择)</p><pre><code>ZSH_THEME=&quot;ys&quot;</code></pre></li><li><p>6 补充:卸载oh my zsh：<br>在命令行输入如下命令，回车即可</p><pre><code>uninstall_oh_my_zsh</code></pre></li></ul><h3 id="iterm2的使用"><a href="#iterm2的使用" class="headerlink" title="iterm2的使用"></a>iterm2的使用</h3><pre><code>下载地址:  http://www.iterm2.com/</code></pre><p>使用:</p><pre><code>1.cmd+f 弹出iterm2的查找模式,确认找到的是自己的内容之后,使用tab键,查找窗口将自动变化内容,并将其复制.如果是shift+tab,则自动将查找内容的左边选中并复制.2.自动使用前-Tab路径,设置perferces-&gt;Profiles-&gt;选中Login shell 和Reuse previous tab&apos;s directory3.command+d: 垂直分割  command+shift+d: 水平分割4.系统热键:设置好系统热键之后,将在正常的浏览器或者编辑器等窗口的上面,以半透明窗口的上面,以半透明窗口形式直接调出iterm2 shell-&gt;perferces-&gt;Key-&gt;Hotkey5.自动完成:输入打头几个字母,然后输入cmd + ; iterm2将自动列出之前输入过的类似命令6.剪切历史:输入cmd + shift + h iterm2将自动列出剪切板的历史记录.如果需要将剪切板的历史记录保存到磁盘,在Perferences-&gt;General-&gt;Save copy/paste history to disk. 7.全屏切换: cmd + enter 进入和返回全屏模式</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Mac上安装oh-my-zsh&quot;&gt;&lt;a href=&quot;#Mac上安装oh-my-zsh&quot; class=&quot;headerlink&quot; title=&quot;Mac上安装oh-my-zsh&quot;&gt;&lt;/a&gt;Mac上安装oh-my-zsh&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;1 克隆项目本地(Mac默认已经安装git) &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;2 创建一个zsh的配置文件 &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  备注:~ 代表:你的/home/用户名的目录,假设你的用户名是user,那么~/就是/home/user/. .是代表此目录本身,但是一般可以不写,所以cd ~/. 和 cd ~ 和cd ~/效果是一样的.但是.后面有东西又是另外一个问题,点在文件名头部,代表一个隐藏文件. ~/.local是你的主目录下下一个.local的文件夹的路径,并且从.可以看出,这是一个隐藏文件,使用ls -a显示.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;3 设置zsh为默认的shell&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;chsh -s /bin/zsh
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;4 重启终端生效&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>01-状态栏</title>
    <link href="http://waythought.duoshuo.com/2017/05/22/01-%E7%8A%B6%E6%80%81%E6%A0%8F/"/>
    <id>http://waythought.duoshuo.com/2017/05/22/01-状态栏/</id>
    <published>2017-05-22T05:38:39.000Z</published>
    <updated>2018-01-03T09:29:35.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="状态栏"><a href="#状态栏" class="headerlink" title="状态栏"></a>状态栏</h2><pre><code>typedef NS_ENUM(NSInteger, UIStatusBarStyle) {UIStatusBarStyleDefault                                     = 0, // 白底黑子UIStatusBarStyleLightContent     NS_ENUM_AVAILABLE_IOS(7_0) = 1, 黑底白字UIStatusBarStyleBlackTranslucent NS_ENUM_DEPRECATED_IOS(2_0, 7_0, &quot;Use UIStatusBarStyleLightContent&quot;) = 1,UIStatusBarStyleBlackOpaque      NS_ENUM_DEPRECATED_IOS(2_0, 7_0, &quot;Use UIStatusBarStyleLightContent&quot;) = 2,</code></pre><p>} __TVOS_PROHIBITED;</p><p>//默认的值是黑色的<br>-(UIStatusBarStyle)preferredStatusBarStyle<br>{<br>    return UIStatusBarStyleDefault;</p><p>}<br>如果项目中root是UINavigationController,那我们自己的UIViewController的preferredStatusBarStyle的方法根本不会调用</p><p>// 是否隐藏状态栏</p><ul><li>(BOOL)prefersStatusBarHidden<br>{<br>  return NO;<br>}</li></ul><p><a href="http://www.cnblogs.com/ilovelqq/p/4769655.html" target="_blank" rel="external">http://www.cnblogs.com/ilovelqq/p/4769655.html</a>  参考</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;状态栏&quot;&gt;&lt;a href=&quot;#状态栏&quot; class=&quot;headerlink&quot; title=&quot;状态栏&quot;&gt;&lt;/a&gt;状态栏&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;typedef NS_ENUM(NSInteger, UIStatusBarStyle) {
UIStatusBar
      
    
    </summary>
    
    
  </entry>
  
</feed>
