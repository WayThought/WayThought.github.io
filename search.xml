<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[20.多线程编程-GCD]]></title>
    <url>%2F2018%2F11%2F17%2F20.GCD%2F</url>
    <content type="text"><![CDATA[在实际开项目开发中为了能够给用户更好的体验，有些延时操作我们都会放在子线程中进行。今天我们就来聊聊多线程在实际项目中的运用。 基本知识进程(process) 进程是一个具有一定独立功能的程序关于某次数据集合的一次运行活动,它是操作系统分配资源的基本单元 每个进程之间是相互独立的,每个进程均运行在其专用且受保护的内存空间内。 进程状态: 进程有三个状态,就绪、运行和阻塞。就绪状态其实就是获取了除cpu外的所有资源,只要处理器分配资源马上就可以运行。运行状态就是获取了处理器分配的资源,程序开始执行。阻塞状态:当程序条件不够时,需要等待条件满足时才能执行;比如等待I/O操作的时候,此刻的状态就叫阻塞 线程(thread) 一个进程中的所有任务都是在线程中执行,所以一个进程要想执行任务,必须要有线程,至少有一条线程 应用程序启动的时候我们的系统会默认帮我们的应用程序开启一条线程,这条线程叫主线程 进程和线程的关系 进程是CPU分配资源和调度的单位 线程是CPU调用的最小单位 进程有独立的地址空间,一个进程crash后,在保护模式下不会对其他进程产生影响。 线程是一个进程中的不同执行路径。线程有自己的堆栈和局部变量,但是线程之间没有单独的地址空间。一个线程crash就等于整个进程crash 多线程编程OC源代码 int main() { id o = [[MyObject alloc] init] [o execBlock] return 0 } Mac或iphone中执行OC源代码, 该源代码通过编译器转换为如下CPU命令列(二进制代码) 000001ac: b590 push {r4, r7, 1r} 000001ae: f240019c movw r1, :lower16:0x260-0x1c0+0xfffffffc 000001b2: af01 add r7, sp, #4 000001b4: f2c00100 movt r1, :upper16:0x260-0x1c0+0xfffffffc ... 汇集CPU命令列和数据,将其作为一个应用程序安装到Mac或iPhone上。 Mac、iPhone的操作系统OS X、iOS根据用户的指示启动该应用程序后,首先便将包含在应用程序中的CPU命令列配置到内存中。CPU从应用程序指定的地址开始,一个一个地执行CPU命令列。先执行1ac的命令列push,接着向后移动,执行地址lae的命令movw,再次向后移动,不断循环下去 在控制语句或者函数调用的情况下,执行命令列的地址会远离当前的位置。由于一个CPU命令只能执行一个命令,不能执行某处分开的并列的两个命令,因此通过CPU执行的CPU命令就好像比一条无分叉的大道,执行不会出现分歧。 现在一个物理的CPU芯片实际上有多个核的CPU,例如iPhone-Xs搭配的A12是六核的,尽管如此,”一个CPU核执行的CPU命令列为一条无分叉路径”仍然不变。 这种无分叉路径不只1条,存在有多条时即为”多线程”。在多线程中,1个CPU核执行多条不同路径上的不同命令。如下图 队列中的任务,放到不同线程中相当于把命令列放到不同的渠道。单核的话,一个CPU核在一条命令列执行,和在多条命令列中调用执行任务效果其实是一样的,每个时刻只能执行一个命令。 因为CPU能够在某个线程和其他线程之间反复多次进行上下文切换,因此看上去就好像1个CPU核能够并列执行多个线程一样。而在具有多个CPU核的情况下,多个CPU核心在多个线程中调度,就真的提供了多个CPU核并行执行多个线程的技术。 但是,多线程编程实际上是一种易发生各种问题的编程技术。比如多个线程更新相同的资源会导致数据的不一致(数据竞争)、停止等待时间的线程会导致多个线程相互持续等待(死锁)、使用太多线程会消耗大量内存等。 尽管极易发生各种问题,也应当使用多线程编程。因为使用多线程编程可保证应用程序的响应性能。 GCD打打简化了偏于复杂的多线程编程的代码。我们来看下GCD的API。 GCD的API GCD是iOS4.0开始引入的新多线程编程技术,是异步执行任务的技术之一,提供的是系统级线程管理,执行效率更高。 Dispath Queue开发者要做的只是定义想执行的任务并追加到适当的 Dispath Queue中。 通过dispath_async函数等API,在Block语法中记述想执行的处理并将其追加到Dispath Queue中。Dispath Queue按照追加的顺序(FIFO,先进先出)执行处理。 现在有两种Dispath Queue,一种是等待现在执行中处理结束的Serial Dispatch,另一种是不等待现在执行中处理结束的Concurrent Queue. 比较这两种Dispath Queue。准备以下源代码: dispatch_queue_t serialQueue = dispatch_queue_create(&quot;test.example.serial&quot;, DISPATCH_QUEUE_SERIAL); for (int i = 0; i &lt; 100 ; i ++) { dispatch_async(serialQueue, ^{ NSLog(@&quot;serialQueue%@&quot;,@(i)); }); } 当队列为Serial Dispatch(串行队列)时,因为需要等待现在执行中的处理结束,所以首先执行第一个block,第一个block执行结束后,接着执行第二个block,如此重复。同时执行的处理数只有1个。 serialQueue0 serialQueue1 serialQueue2 serialQueue3 serialQueue4 serialQueue5 ... serialQueue97 serialQueue98 serialQueue99 当队列为Concurrent Dispath Queue时,因为不用等待现在执行中的处理结束,所以首先执行第一个block,不管第一个block的执行是否结束,都开始执行后面的第二个block,不管第二个block的执行是否结束,都开始执行后面的第三个block,如此重复循环。 并行执行的处理数量取决于当前的系统的状态。即iOS和OS X基于Dispatch Queue中的处理数、CPU核数以及CPU负荷等当前系统的状态来决定Concurrent Dispath Queue中并行执行的处理数 下面我们总结下不同种类的队列和不同执行方式的组合: 第一种: 串行队列同步执行 //串行队列同步 - (void)serialQueueSyncMethod{ //创建队列 dispatch_queue_t queue = dispatch_queue_create(&quot;serialQueueSyncMethod&quot;, DISPATCH_QUEUE_SERIAL); //执行任务 for (int i = 0; i &lt; 6; i++) { NSLog(@&quot;mainThread---&gt;%d&quot;,i); dispatch_sync(queue, ^{ NSLog(@&quot;Current Thread=%@----&gt;%d-----&quot;,[NSThread currentThread],i); }); } NSLog(@&quot;串行队列同步end&quot;); } 打印结果: mainThread---&gt;0 Current Thread=&lt;NSThread: 0x6000014a5480&gt;{number = 1, name = main}----&gt;0----- mainThread---&gt;1 Current Thread=&lt;NSThread: 0x6000014a5480&gt;{number = 1, name = main}----&gt;1----- mainThread---&gt;2 Current Thread=&lt;NSThread: 0x6000014a5480&gt;{number = 1, name = main}----&gt;2----- mainThread---&gt;3 Current Thread=&lt;NSThread: 0x6000014a5480&gt;{number = 1, name = main}----&gt;3----- mainThread---&gt;4 Current Thread=&lt;NSThread: 0x6000014a5480&gt;{number = 1, name = main}----&gt;4----- mainThread---&gt;5 Current Thread=&lt;NSThread: 0x6000014a5480&gt;{number = 1, name = main}----&gt;5----- 串行队列同步end 小结: 串行队列同步执行打印结果是交替进行的。同步执行不会开启新线程,串行队列需要等待现在执行中的处理结束,才会派发任务到当前线程(例子中当前线程是主线程)去执行,所以任务是依次执行的。 第二种: 串行队列异步执行 //串行队列异步 - (void)serialQueueAsyncMethod{ dispatch_queue_t queue = dispatch_queue_create(&quot;serialQueueAsyncMethod&quot;, DISPATCH_QUEUE_SERIAL); for (int i = 0; i &lt; 6; i++) { NSLog(@&quot;mainThread---&gt;%d&quot;,i); dispatch_async(queue, ^{ NSLog(@&quot;Current Thread=%@----&gt;%d-----&quot;,[NSThread currentThread],i); }); } NSLog(@&quot;串行队列异步end&quot;); } 打印结果: mainThread---&gt;0 mainThread---&gt;1 mainThread---&gt;2 mainThread---&gt;3 mainThread---&gt;4 mainThread---&gt;5 串行队列异步end Current Thread=&lt;NSThread: 0x6000028d8740&gt;{number = 3, name = (null)}----&gt;0----- Current Thread=&lt;NSThread: 0x6000028d8740&gt;{number = 3, name = (null)}----&gt;1----- Current Thread=&lt;NSThread: 0x6000028d8740&gt;{number = 3, name = (null)}----&gt;2----- Current Thread=&lt;NSThread: 0x6000028d8740&gt;{number = 3, name = (null)}----&gt;3----- Current Thread=&lt;NSThread: 0x6000028d8740&gt;{number = 3, name = (null)}----&gt;4----- Current Thread=&lt;NSThread: 0x6000028d8740&gt;{number = 3, name = (null)}----&gt;5----- 小结:执行结果看出打印结果并不是交替执行的。打印中number=5,说明block任务是在一个新的线程中执行的。因为异步执行会开辟线程,串行队列需要等待现在执行中的处理结束,才会派发任务到这个新线程去执行,所以任务是依次执行的。 第三种: 并发队列同步执行 //并行队列同步 - (void)concurrentQueueSyncMethod{ dispatch_queue_t queue = dispatch_queue_create(&quot;concurrentQueueSyncMethod&quot;, DISPATCH_QUEUE_CONCURRENT); for (int i = 0; i &lt; 6; i++) { dispatch_sync(queue, ^{ NSLog(@&quot;Current Thread=%@----&gt;%d-----&quot;,[NSThread currentThread],i); }); } NSLog(@&quot;并行队列同步end&quot;); } 打印结果: Current Thread=&lt;NSThread: 0x600002852fc0&gt;{number = 1, name = main}----&gt;0----- Current Thread=&lt;NSThread: 0x600002852fc0&gt;{number = 1, name = main}----&gt;1----- Current Thread=&lt;NSThread: 0x600002852fc0&gt;{number = 1, name = main}----&gt;2----- Current Thread=&lt;NSThread: 0x600002852fc0&gt;{number = 1, name = main}----&gt;3----- Current Thread=&lt;NSThread: 0x600002852fc0&gt;{number = 1, name = main}----&gt;4----- Current Thread=&lt;NSThread: 0x600002852fc0&gt;{number = 1, name = main}----&gt;5----- 并行队列同步end 小结: 并发队列同步执行与串行队列同步执行是相同的,并发队列不需要等待现在执行中的处理结束,由于同步执行没有创建新的线程,并发队列会派发所有任务到当前线程(例子中当前线程是主线程)去执行,由于队列遵循FIFO规则,所以执行结果也是依次的 第四种: 并行队列异步 //并行队列异步 - (void)concurrentQueueAsyncMethod{ dispatch_queue_t queue = dispatch_queue_create(&quot;concurrentQueueAsyncMethod&quot;, DISPATCH_QUEUE_CONCURRENT); for (int i = 0; i &lt; 6; i++) { dispatch_async(queue, ^{ NSLog(@&quot;Current Thread=%@----&gt;%d-----&quot;,[NSThread currentThread],i); }); } NSLog(@&quot;并行队列异步end&quot;); } 打印结果: 并行队列异步end Current Thread=&lt;NSThread: 0x6000028d8500&gt;{number = 10, name = (null)}----&gt;0----- Current Thread=&lt;NSThread: 0x6000028ddfc0&gt;{number = 5, name = (null)}----&gt;1----- Current Thread=&lt;NSThread: 0x6000028d8fc0&gt;{number = 11, name = (null)}----&gt;2----- Current Thread=&lt;NSThread: 0x6000028d8500&gt;{number = 10, name = (null)}----&gt;4----- Current Thread=&lt;NSThread: 0x6000028d9740&gt;{number = 12, name = (null)}----&gt;5----- Current Thread=&lt;NSThread: 0x6000028d9140&gt;{number = 13, name = (null)}----&gt;3----- 小结:并发队列异步执行从结果看开辟了多个线程,并且不是顺序执行。主线程执行的”并行队列异步end”打印。异步执行会开启新的线程,并发队列不需要等待现在执行中的处理结束,就开始派发下一个队列中的任务,所以不是顺序。 补充: 1. 当生成多个Serial Dispath Queue**异步**执行时候,各个Serial Dispath Queue都将并行执行。虽然在一个Serial Dispath Queue中同时只能执行一个追加处理,但是如果将处理分别追加到多个Serial Dispath Queue中,各个Serial Dispath Queue执行1个,即为同时执行多个处理。 ![](http://ww1.sinaimg.cn/large/8af26a6dly1fz63cr8d02j21860z0jt5.jpg) 一旦生成Serial Dispath Queue并追加处理,系统对于一个Serial Dispath Queue就只生成并使用一个线程。 2.主队列同步执行 //获取主队列 dispatch_queue_t queue = dispatch_get_main_queue(); //执行任务 dispatch_sync(queue, ^{ NSLog(@&quot;main_queue_sync%@&quot;,[NSThread currentThread]); }); NSLog(@&quot;main_queue_sync_end&quot;); 小结: 这样会死锁, 主线程调用dispatch_sync这个函数,当这个函数执行完成后主队列才会将下一个任务派遣到主线程中执行,但dispatch_sync执行完成的条件是里面的block返回,里面的block是不会执行的, 因为dispatch_sync这个函数将block任务放到主队列中了,这个block任务需要等待主线程中的任务执行的dispatch_sync函数完成才会执行, dispatch_set_target_queue作用: 变更生成的Dispath Queue的执行优先级 dispatch_after作用: 在指定时间后执行处理的情况 dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3ull * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{ NSLog(@&quot;waited at least three seconds.&quot;); }); 因为Main Dispatch Queue在主线程中的RunLoop中执行,所以在比如每隔1/60秒执行的RunLoop中,Block最快在3秒后执行,最慢在3秒+1/60秒后执行,并且在Main Dispatch Queue有大量处理追加活主线程的处理本身有延迟时,这个时间会更长。 Dispatch Group作用: 追加到Dispatch Queue中的多个处理全部结束后想执行结束处理。 在追加到Dispatch Queue中的多个处理全部结束后想执行结束处理,只使用一个Serial Dispatch Queue时,只要将想执行的处理全部追加到该Serial Dispatch Queue中并在最后追加结束处理,就可以实现。但是在使用Concurrent Dispatch Queue时或同时使用多个Dispatch Queue时,就需要用到Dispatch Group了 dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;example.test.com&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_group_t group = dispatch_group_create(); for (int i = 0; i &lt; 5; i ++) { dispatch_group_async(group, concurrentQueue, ^{ NSLog(@&quot;block%@&quot;,@(i)); }); } dispatch_group_notify(group, concurrentQueue, ^{ NSLog(@&quot;done&quot;); }); 执行结果为 block3 block1 block0 block2 block4 done 多个派发队列情况: dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;example.test.com&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_queue_t anotherConcurrentQueue = dispatch_queue_create(&quot;example.another.test.com&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_group_t group = dispatch_group_create(); for (int i = 0; i &lt; 100; i ++) { dispatch_group_async(group, concurrentQueue, ^{ NSLog(@&quot;block%@ === thread=%@&quot;,@(i),[NSThread currentThread]); }); dispatch_group_async(group, anotherConcurrentQueue, ^{ NSLog(@&quot;anotherBlock%@ === thread=%@&quot;,@(i),[NSThread currentThread]); }); } dispatch_group_notify(group, concurrentQueue, ^{ NSLog(@&quot;done&quot;); }); dispatch_group_notify(group, anotherConcurrentQueue, ^{ NSLog(@&quot;anotherDone&quot;); }); 打印结果: ... block80 === thread=&lt;NSThread: 0x6000021b7040&gt;{number = 6, name = (null)} block98 === thread=&lt;NSThread: 0x6000021b0ec0&gt;{number = 24, name = (null)} anotherBlock98 === thread=&lt;NSThread: 0x6000021b1140&gt;{number = 30, name = (null)} block99 === thread=&lt;NSThread: 0x6000021b1200&gt;{number = 32, name = (null)} anotherBlock99 === thread=&lt;NSThread: 0x6000021b1400&gt;{number = 38, name = (null)} } anotherBlock85 === thread=&lt;NSThread: 0x60000218cbc0&gt;{number = 57, name = (null)} block85 === thread=&lt;NSThread: 0x6000021b1cc0&gt;{number = 60, name = (null)} done anotherDone 多个派发队列任务追加到Dispatch Group中,需要多个队列中的任务都执行完成,多个dispatch_group_notify才分别执行的 dispatch_barrier_async barrier顾名思义是栅栏、障碍物的意思在访问数据库或者文件时,使用Serial Dispatch Queue可避免数据竞争的问题。 写入处理确实不可与其他的写入处理以及包含读取处理的其他某些处理并行执行。但是如果读取处理只是与读取并行执行,那么多个并行执行就不会发生问题。 也就是说,为了高效率地进行访问,读取处理追加到Concurrent Dispatch Queue中,写入处理在任一个读取处理没有执行的状态下,追加到Serial Dispatch Queue中即可(在写入处理结束之前,读取处理不可执行)。 虽然利用Dispatch Group和dispath_set_target_queue函数也可实现,但代码会稍微复杂。有兴趣的可以尝试下。 GCD为我们提供了更为聪明的解决方法: dispatch_barrier_async函数。该函数同并发队列一起使用。 void(^block1_reading)(void) = ^{ NSLog(@&quot;block1_reading&quot;); }; void(^block2_reading)(void) = ^{ NSLog(@&quot;block2_reading&quot;); }; void(^block3_reading)(void) = ^{ NSLog(@&quot;block3_reading&quot;); }; void(^block4_reading)(void) = ^{ NSLog(@&quot;block4_reading&quot;); }; void(^block5_reading)(void) = ^{ NSLog(@&quot;block5_reading&quot;); }; void(^block_writing)(void) = ^{ NSLog(@&quot;block_writing&quot;); }; dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;example.test.com&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_async(concurrentQueue, block1_reading); dispatch_async(concurrentQueue, block2_reading); dispatch_async(concurrentQueue, block3_reading); dispatch_barrier_async(concurrentQueue, block_writing); dispatch_async(concurrentQueue, block4_reading); dispatch_async(concurrentQueue, block5_reading); 打印结果 block2_reading block1_reading block3_reading block_writing block4_reading block5_reading 使用 Concurrent Dispatch Queue和dispatch_barrier_async函数可实现高效率的数据库访问和文件访问,但是栅栏函数只能保证这个队列同时只执行1个任务。 dispatch_apply dispatch_apply函数是dispatch_sync函数和Dispatch Group的关联api。该函数按照指定的次数将指定的block追加到指定的Dispatch Queue中,并等待全部处理执行结束。 使用方法 dispatch_apply( 循环次数, 任务所在队列 ) {要循环执行的任务}。 由于dispatch_apply函数也与dispatch_sync函数相同,会等待处理执行结束,因此推荐在dispatch_async函数中非同步的执行dispatch_apply函数。 dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); void(^blk1_reading)(void) = ^{ NSLog(@&quot;blk1---reading&quot;); }; void(^blk2_reading)(void) = ^{ NSLog(@&quot;blk2---reading&quot;); }; void(^blk3_reading)(void) = ^{ NSLog(@&quot;blk3---reading&quot;); }; void(^blk_writing)(void) = ^{ NSLog(@&quot;blk---writing&quot;); }; NSMutableArray *array = [NSMutableArray new]; [array addObject:blk1_reading]; [array addObject:blk2_reading]; [array addObject:blk3_reading]; [array addObject:blk_writing]; dispatch_async(queue, ^{ dispatch_apply(array.count, queue, ^(size_t index) { void (^blk)(void) = [array objectAtIndex:index]; blk(); NSLog(@&quot;%zu====%@&quot;,index,[array objectAtIndex:index]); }); NSLog(@&quot;全部执行结束&quot;); dispatch_async(dispatch_get_main_queue(), ^{ //在main Dispatch queue中执行处理，更新用户界面等待 NSLog(@&quot;done&quot;); }); }); 执行结果 blk1---reading blk2---reading blk3---reading 0====&lt;__NSGlobalBlock__: 0x101279ac8&gt; 1====&lt;__NSGlobalBlock__: 0x101279b08&gt; blk---writing 2====&lt;__NSGlobalBlock__: 0x101279b48&gt; 3====&lt;__NSGlobalBlock__: 0x101279b88&gt; 全部执行结束 done dispatch_suspend/dispatch_resume使用: dispatch_suspend(queue);// 挂起queue这个队列 dispatch_resume(queue);// 唤醒queue这个队列 //系统默认生成的，所以无法调用dispatch_resume()和dispatch_suspend()来控制执行继续或中断。 dispatch_queue_t queue1 = dispatch_queue_create(&quot;queue1&quot;, 0); dispatch_queue_t queue2 = dispatch_queue_create(&quot;queue2&quot;, 0); dispatch_group_t group = dispatch_group_create(); dispatch_async(queue1, ^{ for (int i = 0; i &lt; 5; i++) { NSLog(@&quot;%@-------%d&quot;,[NSThread currentThread],i); sleep(1); } }); dispatch_async(queue2, ^{ NSLog(@&quot;task2&quot;); }); dispatch_group_async(group, queue1, ^{ NSLog(@&quot;task1 finished!&quot;); }); dispatch_group_async(group, queue2, ^{ dispatch_suspend(queue1);//挂起 NSLog(@&quot;task2 finished!挂起queue1&quot;); [NSThread sleepForTimeInterval:10.0]; dispatch_resume(queue1);//唤醒队列 }); dispatch_group_wait(group, DISPATCH_TIME_FOREVER); dispatch_async(queue1, ^{ NSLog(@&quot;task3&quot;); }); dispatch_async(queue2, ^{ NSLog(@&quot;task4&quot;); }); 打印结果: ThreadDemo[54913:1615402] task2 ThreadDemo[54913:1615006] &lt;NSThread: 0x600003499540&gt;{number = 3, name = (null)}-------0 ThreadDemo[54913:1615402] task2 finished!挂起queue1 ThreadDemo[54913:1615006] &lt;NSThread: 0x600003499540&gt;{number = 3, name = (null)}-------1 ThreadDemo[54913:1615006] &lt;NSThread: 0x600003499540&gt;{number = 3, name = (null)}-------2 ThreadDemo[54913:1615006] &lt;NSThread: 0x600003499540&gt;{number = 3, name = (null)}-------3 ThreadDemo[54913:1615006] &lt;NSThread: 0x600003499540&gt;{number = 3, name = (null)}-------4 ThreadDemo[54913:1615006] task1 finished! ThreadDemo[54913:1615006] task3 ThreadDemo[54913:1615402] task4 解释: 队列挂起之前,队列已经派遣的任务可以执行完成;未派遣的任务,需要等队列被唤醒之后才能执行。 dispatch_once作用: 保证应用程序执行中只执行一次指定处理的API。dispatch_once函数在多线程环境下执行,也可保证百分之百安全。 GCD中的Dispatch Queue编程人员所使用GCD的API全部为包含在libdispatch库中的C语言函数。 Dispatch Queue通过结构体和链表,被实现为FIFO队列。FIFO队列管理是通过dispatch_async等函数所谁家的Block。 Block并不是直接加入FIFO队列,而是先加入Dispatch Continuation这一dispatch_continuation_t类型结构体重,然后再加入FIFO队列。该Dispatch Continuation用于记忆Block所属的Dispatch Group和其他一些信息,相当于一般常说的执行上下文。]]></content>
  </entry>
  <entry>
    <title><![CDATA[19.RequestToModel的使用]]></title>
    <url>%2F2018%2F08%2F17%2F19.python%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90model%E5%92%8Capi%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[19.RequestToModel的使用第一步、进入RequestToModel路径 第二步、执行 python3 main.py start 网络请求的样子第三步、输入需要的Json值对应着key,输入对应转的模型和网络请求的api第四步、查看结果]]></content>
  </entry>
  <entry>
    <title><![CDATA[18.在Mac系统下配置PHP运行环境]]></title>
    <url>%2F2018%2F04%2F26%2F18.%E5%9C%A8Mac%E7%B3%BB%E7%BB%9F%E4%B8%8B%E9%85%8D%E7%BD%AEPHP%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[一、概述近期项目中需要将UIWebView替换成WKWebView,查询到前端口原js调用的方法不在起作用,需要调用新方法window.webkit.messageHandlers..postMessage(),所以本地新建Html测试下,需要设置Apache相关配置 Mac系统对于Php运行非常友好,我们只需要进行简单的配置便可以开始进行使用。 二、ApacheApache介绍启动Apache服务,在Mac系统中已经安装好了Apache服务,我们只需要通过如下方式启动即可直接使用。 在终端中输入如下命令,启动Apache服务 sudo apachectl start 在终端输入如下命令,查看Apache服务版本 sudo apachectl -v 在本机中版本信息如下: Server version: Apache/2.4.29 (Unix) Server built: Jan 17 2017 18:20:31 在浏览器中输入如下网址,检查Apache服务是否启动成功 http://localhost http://127.0.0.1 如果Apache服务启动成功,页面会显示 It works! Apache服务部署路径Apache服务部署路径在 /资源库/WebServer/Documents/,我们的项目需要放置在该路径下 如果想要修改部署路径,可以在/private/etc/apache2目录下找到并打开httpd.conf文件,搜索DocumentRoot并修改部署路径DocumentRoot “/Library/WebServer/Documents” Apache服务端口号 Apache服务端口默认80,如果想要修改端口号,可以在/private/etc/apache2目录下找到并打开httpd.conf文件,搜索Listen 80并修改端口号 PHPPHP的启动只需要再Apache服务中进行下一配置即可直接使用 首先,在/private/etc/apache2目录下找到并打开httpd.conf文件 其次,搜索#LoadModule php7_module libexec/apache2/libphp7.so,将前方的#删除,由于php版本不同,全局搜索libexec/apache2/libphp就可以找到再次,重启Apache服务即可 最后我们把我们创建好的项目tmp.html放入/资源库/WebServer/Documents/路径下 在终端输入以下命令得到本机ip() ifconfig en0 外网访问我们项目地址就是: 172.50.10.239/tmp.html 至此,我们创建的项目能够正常访问了Apache的其他配置在终端中输入如下命令,关闭Apache服务 sudo apachectl stop 在终端中输入如下命令,重启Apache服务 sudo apachectl restart]]></content>
  </entry>
  <entry>
    <title><![CDATA[17.iOS Block详解]]></title>
    <url>%2F2018%2F04%2F23%2F17.iOS%20Block%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[一、概述Block是C语言的扩充功能。可以用一句话来表示Block的扩充功能: 带有自动变量的匿名函数。 Block本质是对象,使代码高聚合 Block的使用分为声明、实现、执行 Block可以定义在方法内部或外部 二、 Block的定义和使用 实际开发中常用typedef 定义Block // ^ 代表插入记号 typedef: 起别名 返回值(^名称)(参数列表) typedef void(^MyBlock)(int parameter); 这时, MyBlock就成为了一种Block类型,在定义类的属性时可以这样: @property (nonatomic, copy) MyBlock anotherBlock; 三、Block与外界变量1、截获自动变量(局部变量)值 1.1 默认情况 对于block外的变量引用,block默认是将其复制到数据结构中来实现访问的。也就是说block的自动变量截获只针对内部使用的自动变量,不使用则不截获,因为截获的自动变量会存储于block的结构体的内部,会导致block体积变大。 int age = 10; myBlock block = ^{ NSLog(@&quot;age = %d&quot;, age); }; age = 18; block(); 输出结果: age = 10 在声明Block之后,调用block之前对局部变量进行修改,在调用block时局部变量值是修改之前的旧值,并且默认情况下侧block只能访问而不能修改局部变量的值。 使用clang将OC代码转为C++文件查看block的方法: 我们通过clang命令将OC转为C++来查看一下block底层实现,终端定位main.m文件所在文件夹,然后clang -rewrite-objc main.m将OC转为C++,成功后在main.m同目录下会生成一个main.cpp文件 // OC代码如下 int main() { int global = 10; void(^firstBlock)() = ^() { int tmp = global; }; firstBlock(); return 0; } // 转为C++代码如下 int main() { int global = 10; // 定义 void(*firstBlock)() = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, global)); // 执行 ((void (*)(__block_impl *))((__block_impl *)firstBlock)-&gt;FuncPtr)((__block_impl *)firstBlock); return 0; } // 将变量类型精简之后C++代码如下,我们发现block变量实际上就是一个指向__main_block_impl_0的指针,而结构体的第三个元素是局部变量global的值 // 我们看下结构体__main_block_impl_0的代码 struct __main_block_impl_0 { struct __block_impl impl; struct __main_block_desc_0* Desc; int global; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _global, int flags=0) : global(_global) { impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; } }; // 在OC中执行block的方法转为C++代码如下,实际上是指向结构体的指针firstBlock访问FuncPtr元素,在定义block时为FuncPtr元素传进去的__main_block_func_0方法 ((void (*)(__block_impl *))((__block_impl *)firstBlock)-&gt;FuncPtr)((__block_impl *)firstBlock); // __main_block_func_0方法代码如下,由此可见tmp的赋值正是定义block时为结构体传进去的局部变量global的值。 static void __main_block_func_0(struct __main_block_impl_0 *__cself) { int global = __cself-&gt;global; int tmp = global; } 由此可知,在block定义时便是将局部变量的值传给block变量所指向的结构体,因此在调用block之前对局部变量进行修改并不会影响block内部的值,同时内部的值也是不可修改的。 ((void (*)(__block_impl *))((__block_impl *)firstBlock)-&gt;FuncPtr)((__block_impl *)firstBlock); 1.2 Block内访问 __block修饰的局部变量在block中不可直接修改局部变量对于用__block修饰的外部变量的引用,block是复制其引用地址来实现访问的。block可以修改__block修饰的外部变量的值。 __block int age = 10; myBlock block = ^{ NSLog(@&quot;age = %d&quot;, age); }; age = 18; block(); 输出为: age = 18 为什么使用__block 修饰的外部变量的值就可以被block修改呢？ 我们使用clang将OC代码转成C++文件: // OC代码为 int main() { __block int global = 10; void(^secondBlock)() = ^{ int tmp = global; // NSLog(@&quot;age = %d&quot;, age); }; global = 18; secondBlock(); return 0; } - // 转为C++代码如下 int main() { __attribute__((__blocks__(byref))) __Block_byref_global_0 global = {(void*)0,(__Block_byref_global_0 *)&amp;global, 0, sizeof(__Block_byref_global_0), 10}; void(*secondBlock)() = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_global_0 *)&amp;global, 570425344)); (global.__forwarding-&gt;global) = 18; ((void (*)(__block_impl *))((__block_impl *)secondBlock)-&gt;FuncPtr)((__block_impl *)secondBlock); return 0; } 由此我们看见,在局部变量前使用__block修改,在block定义时便是将局部变量的指针(&amp;global)传给block变量所指向的结构体,因此在调用block之前对局部变量进行修改会影响block内部的值,同时内部的值也是可以可以修改的 2、截获自动变量(全局变量)值 int global = 10; int main() { void(^thirdBlock)() = ^{ int tmp = global; // global += 1; // NSLog(@&quot;global = %d&quot;, global); }; global = 18; // 调用后控制台输出&quot;global = 18&quot; thirdBlock(); return 0; } 在block内部可以访问全局变量,在block中可以直接修改全局变量 在声明block之后、调用block之前对全局变量进行修改,在调用block全局变量值是修改之后的新值 // 转为C++代码如下 int main() { void(*thirdBlock)() = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA)); global = 18; ((void (*)(__block_impl *))((__block_impl *)thirdBlock)-&gt;FuncPtr)((__block_impl *)thirdBlock); return 0; } - // __main_block_func_0方法如下,由此可见访问的global是全局变量的global的值 static void __main_block_func_0(struct __main_block_impl_0 *__cself) { int tmp = global; } 由此可知,全局变量所占用的内存只有一份,供所有函数共同调用,在block定义时并未将全局变量的值或者指针传给block变量所指向的结构体,因此在调用block之前对全局变量进行修改会影响到block内部的值,同时内部的值也是可以修改的 3.Block内访问静态变量 int main() { static int global = 10; void(^thirdBlock)() = ^{ int tmp = global; // global += 1; NSLog(@&quot;global = %d&quot;, global); }; global = 18; // 调用后控制台输出&quot;global = 18&quot; thirdBlock(); return 0; } 在声明block之后,调用block之前对全局变量进行修改,在调用block时全局变量值是修改之后的新值 在block中也可以直接修改全局变量 这里的block是放在全局区的 注: 原理解析,通过clang命令将OC转为C++代码来查看一下Block底层实现 int main() { static int global = 10; // 我们发现block变量实际上就是一个指向结构体__main_block_impl_0的指针,而结构体的第三个元素是静态变量global的指针 void(*thirdBlock)() = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, &amp;global)); global = 18; ((void (*)(__block_impl *))((__block_impl *)thirdBlock)-&gt;FuncPtr)((__block_impl *)thirdBlock); return 0; } - __main_block_func_0方法代码如下,传入block的global为结构体传进去的静态变量global的指针 static void __main_block_func_0(struct __main_block_impl_0 *__cself) { int *global = __cself-&gt;global; // bound by copy int tmp = (*global); } 由此可见,在block定义时便是静态变量的指针传给block变量所指向的结构体,因此在调用block之前对静态变量进行修改会影响block内部的值,同时内部的值也是可以修改的 四、Block的copy操作1.Block的存储域及copy操作 在开始研究block的copy操作前,先来思考下:Block是存储在栈上还是堆上呢? 我们先来看看一个由C/C++OBJC编译的程序占用内存分布的结构: 其实,block有三种类型: 全局块 (_NSConcreteGlobalBlock) 栈块 (_NSConcreteStackBlock) 堆块 (_NSConcreteMallocBlock) 这三种block各自的存储域如下图: 全局块存在于全局内存中,相当于单例. 栈块存在于栈内存中,超出其作用域则马上销毁 堆块存在于堆内存中,是一个带引用计数的对象,需要自行管理其内存 判断block的存储位置: 4.1 Block不访问外界变量 Block既不在栈又不在堆中,在代码段中,ARC和MRC下都是如此。此时为全局块。 4.2 Block访问外界变量(包括局部变量和全局变量) MRC环境下: 访问外界变量中的Block默认存储在栈中。ARC环境下: 访问外界变量中的Block默认存储在堆中。(实际上是放在栈区,然后ARC情况下自动又拷贝到堆区),自动释放。 注: 1.ARC或者MRC下访问静态变量,Block默认存储在全局区; 2.如果MRC下对block进行copy,block访问的外部变量也会retain一份,无法正常释放,所以要使用__block修饰外部变量 ARC下,访问外界变量(局部变量和全局变量)的Block为什么要从自动从栈区拷贝到堆区呢? 栈上的Block,如果其所属的变量作用域结束,该Block就被废弃,如同一般的自动变量。当然,Block中的__block变量也同时被废弃。如下图 为了解决栈块在其变量作用域结束之后被废弃(释放)的问题,我们需要把Block复制到堆中,延长其生命周期。开启ARC时,大多数情况下编译器会恰当地进行判断是否有需要将Block从栈复制到堆,如果有,自动生成将Block从栈上复制到堆上的代码。Block的复制操作执行的是copy实例方法。Block只要调用了copy方法,栈块就会变成堆块。我认为做的原因是,由于ARC已经能很好地处理对象的生命周期的管理,这样所有对象都放到堆上管理,对于编译器来实现来说,会比较方便。 如下图: 例如下面一个返回值为Block类型的函数: - (void)viewDidLoad { [super viewDidLoad]; int globalNum = 100; void(^fourthBlock)(void) = ^{ NSLog(@&quot;%ld&quot;,(long)globalNum); }; } 分析可知道: 在MRC下,上面的函数返回的block是配置在栈上的,所以当viewDidLoad方法执行完成,block变量作用域就结束了,block就会被废弃,所以需要开发者调用copy方法手动复制。但在ARC有效,这种情况编译器会自动完成copy。 将block从栈上复制到堆上相当消耗CPU,所以当block设置在栈上也能够使用时,就不要复制了,因为此时的复制只是浪费CPU资源。 Block的复制操作执行的是copy实例方法。不同类型的block使用copy方法的效果如下表: 4.3 __block变量与__forwarding 在copy操作之后,既然__block变量也被copy到堆上去了,那么访问该变量是访问栈上的还是堆上的呢?这里和__forwarding有关系 通过__forwarding,无论是在block中还是block外访问__block变量,也不管该变量在栈上或堆上,都能顺利地访问同一个__block变量。 五、防止Block循环引用block循环引用的情况:某个类将block作为自己的属性变量,然后该类在block的方法体里面又使用了该类本身,如下: self.anotherBlock = ^(int parameter) { self.name = [NSString stringWithFormat:@&quot;%@&quot;,@(parameter)]; }; 解决方法: 5.1 ARC下: 使用__weak // 使用__weak修饰的变量,实际上是变量的弱引用,整句就是给self定义了一个弱引用性质的替身 __weak typeof(self) weakSelf = self; self.anotherBlock = ^(int parameter) { self.name = [NSString stringWithFormat:@&quot;%@&quot;,@(parameter)]; }; 5.2 MRC下: 使用__block __block typeof(self) blockSelf = self; self.someBlock = ^(Type var){ [blockSelf dosomething]; }; 值得注意的是,在ARC下,使用__block也有可能带来的循环引用,如下: // 循环引用 self -&gt; _attributBlock -&gt; tmp -&gt; self typedef void (^Block)(); @interface TestObj : NSObject { Block _attributBlock; } @end @implementation TestObj - (id)init { self = [super init]; __block id tmp = self;// 这里的tmp是对self的引用 self.attributBlock = ^{ NSLog(@&quot;Self = %@&quot;,tmp); tmp = nil; }; } - (void)execBlock { self.attributBlock(); } @end // 使用类 id obj = [[TestObj alloc] init]; [obj execBlock]; // 如果不调用此方法，tmp 永远不会置 nil，内存泄露会一直在 __block在mrc下有两个作用: 允许在block中访问和修改局部变量 禁止block对所引用的对象进行隐式retain操作 __block在ARC下只有一个作用: 允许在block中访问和修改局部变量 六、block实现链式编程6.1 定义一个函数,让block作为返回值,这样就可以返回一个代码块,然后在代码块里面执行某些操作完成一些功能。也可以返回自己,然后继续调用该函数,返回一个block,这样就可以实现masonry的链式效果,具体的我们下面再详细讲解。 先来看一个例子 @interface People : NSObject /** * 该函数返回一个block，该block无返回值，传入的参数为int类型 * void：无返回值 * int： 参数类型为int */ - (void(^)(int))run; /** * 该函数返回一个block，该block有返回值为NSString类型，传入的参数为int类型 * NSString *：返回值为NSString类型 * int： 参数类型为int */ - (NSString *(^)(int meter))drive; @end - @implementation People - (void(^)(int))run { return ^(int meter){ NSLog(@&quot;people run %@米&quot;,@(meter)); }; } - (NSString *(^)(int))drive { return ^NSString *(int meter){ return [NSString stringWithFormat:@&quot;i drive %@米&quot;,@(meter)]; }; } @end 调用上述方法: People *people = [[People alloc] init]; people.run(12); NSLog(@&quot;%@&quot;,people.drive(12)); 输出如下: 2018-08-14 13:56:16.500648+0800 29.Block详解[14286:3946087] people run 12米 2018-08-14 13:56:16.500790+0800 29.Block详解[14286:3946087] i drive 12米 其实上面的run和drive函数我们完全可以用方法来实现相同的功能,但是那样我们只能使用[object methodName]的方式调用,没法使用点语法实现链式调用。其实上面的点语法调用函数,就是调用该函数的getter方法。 这里我们先了解可以使用点语法来实现和方法相同的功能,下面我们会讲到链式调用,就是使用此处的知识点。 6.2 block实现链式编程 说完了上面的基础知识,我们下面就需要使用这些基础知识来实现链式编程 6.2.1 先定义一个NSObject的分类如下: #import &quot;CalculateManager.h&quot; @interface NSObject (Block) + (double)makeCalculate:(void(^)(CalculateManager *))block; @end - @implementation NSObject (Block) + (double)makeCalculate:(void(^)(CalculateManager *))block { CalculateManager *manager = [[CalculateManager alloc] init]; if (block) { block(manager); } return manager.result; } @end 6.2.2 继续定义一个类实现计算过程,比如add: @interface CalculateManager : NSObject @property (nonatomic, assign) double result; - (CalculateManager *(^)(double result))add; @end - #import &quot;CalculateManager.h&quot; @implementation CalculateManager - (CalculateManager *(^)(double result))add { __weak typeof(self) weakSelf = self; return ^(double value){ weakSelf.result += value; return self; }; } @end 6.2.3 调用 double result = [NSObject makeCalculate:^(CalculateManager *manager) { manager.add(12).add(21); }]; NSLog(@&quot;result === %@&quot;,@(result)); 要实现链式编程的一个关键点: 就是每次调用add方法必须返回自身,然后才可以继续调用,如此一致循环下去,实现这一切都是block的功劳。 6.2.4 实现过程分析: 第一步: 调用NSObject的分类方法 makeCalculate:(void(^)(CalculateManager *))block,该方法的参数是一个block,我们在这里传递一个定义好的block到该函数。block的实现是 manager.add(12).add(21); 第二步:分类方法 makeCalculate:(void(^)(CalculateManager *))block的具体实现,该方法内部初始化一个CalculateManager实例对象manager,然后作为block的参数传入block,这里block开始执行,调用manager.add(12).add(21),block执行完成后返回执行完毕后的结果,也就是manager.result。 第三步: manager.add(12).add(21)是关键,这里的add方法返回的是一个block,该block的实现是累加传递进来的值然后赋值给属性的result保存下来,然后返回值是self,也就是CalculateManager实例对象。这样又科技实现点语法继续调用add方法。]]></content>
  </entry>
  <entry>
    <title><![CDATA[16.项目启动耗时性能优化]]></title>
    <url>%2F2018%2F02%2F13%2F16.%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8%E8%80%97%E6%97%B6%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[近期项目线下反应app启动时间较长,本着对用户体验的追求,我们希望在业务扩张的同时优化启动时间。 启动时间总时间 = T1(main函数之前的加载时间) + T2(main函数之后的加载时间) T1: 加载系统dylib和可执行文件的时间 T2: 从mian函数到applicationWillFinishLaunching结束的时间,构建第一个界面,并完成渲染展示 main()函数调用之前的加载过程 App开始启动后,系统首先加载可执行文件(自身App的所有的.o文件的集合),然后加载动态链接库dyld,dyld是一个专门用来加载动态链接库的库。执行从dyld开始,dyld从可执行文件的依赖开始,递归加载所有的依赖动态链接库。 动态链接库包括: iOS中用到的所有系统的framework, 加载OC runtime方法的libobjc,系统级别的libSystem,例如libdispath(GCD)和libsystem_block(Block)。 其实无论对于系统的动态链接库还是对于App本身的可执行文件而言,他们都算是image(镜像),而每个App都是以image(镜像)为单位进行加载的,那么image究竟是包括哪些呢? #####什么是image 1.executable可执行文件 比如.o文件 2.dylib动态链接库framework就是动态链接库和相应资源包含在一起的一个文件夹结构。3.bundle资源文件 只能用dlopen加载,不推荐使用这种方式加载。 除了我们App本身的可执行文件,系统中所有的framework 比如UIKit、Foundation等都是以动态链接库的方式集成进App中的。 系统使用动态链接有几点好处:代码共用: 很多程序都动态链接了这些lib,但是它们在内存和磁盘中只有一份。易于维护: 由于被依赖的lib地程序执行时才链接的,所以这些lib很容易做更新,比如libSystem.dylib是libSystem.v1.dylib的替身,那天想升级直接换成libSystem.v2.dylib然后再替换替身就行了。减少可执行文件体积: 相比静态链接,动态链接在编译时不需要打进去,所以可执行文件的体积要小很多。 如上图所示,不同进程之间共用系统dylib的_TEXT区,但是各自维护对应的_DATA区。 所有动态链接库和我们App中的静态库.a和所有类文件编译后的.o文件最终都是有dyld(the dynamic link editor),Apple的动态链接器来加载到内存中。每个image都是一个叫做ImageLoader的类来负责加载(–对应),那么ImageLoader又是什么呢? 什么是ImageLoaderimage表示一个二进制文件(可执行文件或so文件),里面是呗编译过的符号、代码等,所以ImageLoader作用是将这些文件加载进内存,且每一个文件对应一个ImageLoader实例来负责加载。 两步走: 在程序运行时,它先将动态链接的image递归加载(也就是上面测试栈中一串的递归调用的时刻)。再从可执行文件image递归加载所有符号。 当然所有这些都发生在我们真正的main函数执行前。 动态链接库加载的具体流程动态链接库的加载步骤具体分为5步: 1. load dylibs image 读取库镜像文件 2. Rebase image 3. Blid image 4. Objc setup 5. initalizers load dylibs image在每个动态库的加载过程中,dyld需要: 1.分析所依赖的动态库 2.找到动态库的mach-o文件 3.打开文件 4.验证文件 5.在系统核心注册文件签名 6.对动态库的每一个segment调用mmap() 通常的,一个App需要加载100到400个dylibs,但是其中的系统库被优化,可以很快的加载。针对这一步骤的优化有: 1.减少非系统库的依赖 2.合并非系统库 3.使用静态资源,比如把代码加入主程序 Rebase/Blid由于ASLR(address space layout randomization)的存在,可执行文件和动态链接库在虚拟内存中的加载地址每次启动都不固定,所以需要这个2步来修复镜像中的资源指针,来指向正确的地址。rebase修复的是指向当前镜像内部的资源指针;而blid指向的是镜像外部的资源指针。 rebase步骤先进性,需要把镜像读入内存,并以page为单位进行加密验证,保证不会被篡改,所以这一步的瓶颈在IO。blid在其后进行,由于要查询符号表,来指向跨镜像的资源,加上在rebase阶段,镜像已被读入和加密验证,所以这一步的瓶颈在于CPU计算。 通过命名行可以查看相关的资源指针: xcrun dyldinfo -rebase -bind -lazy_bind myApp.App/myApp 优化该阶段的关键在于减少__DATA segment中的指针数量。 我们可以优化的点有: 1.减少Objc类数量,减少selector数量 2.减少C++虚函数数量 3.转而使用swift stuct (其实本质就是为了减少符号的数量) Objc setup这一步主要工作是: 1. 注册Objc类(class registration) 2. 把category的定义插图方法列表(category resightration) 3. 保证每一个selector唯一(selector uniquing) 由于之前2步骤的优化,这一步实际没有什么可做的。 initializers以上三步属于静态调整(fix-up),都是在修改__DATA segment中的内容,而这里则开始动态调整,开始在堆中堆栈中写入内容。在这里中工作有: 1.Objc的+load()函数 2.C++的构造函数属性函数 形如attribute((constructor)void DoSomeInitializationWork()) 3.非基本类型的C++静态全局变量的创建(通常是类或结构体)(non-trivial initializer)比如一个全局静态结构体的构建,如果在构造函数中有繁重的工作,那么会拖慢启动速度 Objc的load函数和C++的静态构造函数采用由底向上的方式执行,来保证每个执行的方法,都可以找到所依赖的动态库。]]></content>
  </entry>
  <entry>
    <title><![CDATA[15.Object-C Runtime基本介绍和消息传递]]></title>
    <url>%2F2017%2F12%2F12%2F15.rutime%E7%B3%BB%E5%88%97-%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%2F</url>
    <content type="text"><![CDATA[本文内容 缘由代码 Runtime基本介绍 object_getClass(obj)与[obj class]的区别与[obj class]的区别) objc_class结构体及其成员变量定义 1. objc_msgSend的介绍 来看两段代码第一段代码#import &quot;KNBFather.h&quot; @interface KNBSon : KNBFather @end - #import &quot;KNBSon.h&quot; @implementation KNBSon - (instancetype)init { if (self = [super init]) { NSLog(@&quot;[self class] --&gt; %@&quot;,[self class]); NSLog(@&quot;[super class] --&gt; %@&quot;,[super class]); } return self; } @end 实例化KNBSon控制台输出: 2018-06-20 09:37:15.874949+0800 23- 数组的练习[50857:2147245] [self class] --&gt; KNBSon 2018-06-20 09:37:15.875173+0800 23- 数组的练习[50857:2147245] [super class] --&gt; KNBSon 分析:我们想当然的认为self class是son, super class是father。但是输出的却是一样的,都是son。这是因为oc一切方法的本质都是消息的发送和接受,是动态的。具体的等看过第二节我们再探讨。 第二段代码#import &lt;Foundation/Foundation.h&gt; @interface KNBFather : NSObject @property (nonatomic, copy) NSString *name; @end =================== #import &quot;KNBFather.h&quot; @implementation KNBFather - (instancetype)init { if (self = [super init]) { self.name = @&quot;&quot;; } return self; } - (void)setName:(NSString *)name { _name = name; NSLog(@&quot;我是KNBFather,调用我的setName方法了&quot;); } @end - #import &quot;KNBFather.h&quot; @interface KNBSon : KNBFather @end ========================= #import &quot;KNBSon.h&quot; @implementation KNBSon - (instancetype)init { if (self = [super init]) { NSLog(@&quot;[self class] --&gt; %@&quot;,[self class]); NSLog(@&quot;[super class] --&gt; %@&quot;,[super class]); } return self; } - (void)setName:(NSString *)name { NSLog(@&quot;我是KNBSon,调用我的setName方法了&quot;); } @end 实例化KNBSon控制台输出: 2018-06-20 09:58:03.162035+0800 23- 数组的练习[51199:2171942] 我是KNBSon,调用我的setName方法了 2018-06-20 09:58:03.162231+0800 23- 数组的练习[51199:2171942] [self class] --&gt; KNBSon 2018-06-20 09:58:03.162368+0800 23- 数组的练习[51199:2171942] [super class] --&gt; KNBSon 分析: 我们在父类KNBFather中的init方法中设置了self.name = @””,是想初始化name的值。 按道理说,我们在父类使用self.name方法应该调用father的setName方法,在子类KNBSon中使用self.name方法也应该调用KNBSon的setName方法。(以前的理解 self在实例方法中表示的该实例) 但是实际上我们看到在父类中使用self.name调用的确实是子类的setName方法。 我们先看下runtime相关的一些知识,再来解释以上问题。 2.Runtime基本介绍Objective-C是基于C加入了面向对象特性和消息转发机制的动态语言。这意味着不仅需要编译器,还需要一个运行系统来执行编译后的代码。而这个运行系统就是runtime,也就是运行时机制,我理解的就是”中间调度系统”,来控制消息发送、消息转发、查看对象信息等等 给对象发消息可以这样写: id returnValue = [someObject messageName: parameter]; 在本例中, someObject叫做”接收者”(receiver),messageName叫做”选择器”(selector).选择器与参数合起来称为”消息”(message)。编译器看到此消息后,将其转换为一条标准的C语言函数调用,所调用的函数仍是消息传递机制中的核心函数,叫做objc_msgSend,其”原型”(prototype)如下: id returnValue = objc_msgSend(id self,SEL cmd, ...) 这是个”参数个数可变的函数”(variadic function),能接受两个或两个以上的参数。第一个参数代表接收者,第二个参数代表”选择器”,后续参数就是消息中的那些参数,其顺序不变。”选择器”指的就是方法的名字。”选择子”与”方法”这两个词经常交替使用。编译器会把刚才那个例子中的消息转换为如下的函数。 id returnValue = objc_msgSend(someObject,@selector(messageName:),parameter); PS: 如果要给超类发送消息,那么交由objc_msgSendSuper:处理。 idid 是一个指向类实例的指针: // objc.h中 typedef struct objc_object *id; struct objc_object { Class _Nonnull isa OBJC_ISA_AVAILABILITY; }; objc_object是一个结构体,包含一个isa指针,根据这个isa指针可以顺藤摸瓜找到对象所属的类。(isa指针不总是指向实例对象所属的类,不能依靠它来确定类型,而是应该是class方法来确定实例对象的类。因为KVO的实现机理就是将被观察对象的isa指针指向一个中间类而不是真实的类,这是一种叫做isa-swizzling的技术)。 感兴趣的可以去这个链接介绍isa-swizzling SELobjc_msgSend函数的第二个参数类型是SEL,它是selector在Objc中的表示类型,他是个映射到方法的C字符串。 isa指针上面的objc_msgSend实现原理里面提到了isa指针、类。也是我们平时经常接触的两个概念,但是他们内部具体如何实现,却很少深究。 我们OC中的基本所有的类都是继承于NSObject,NSObject是根类。我们来看下定义 // NSObject.h定义 @interface NSObject &lt;NSObject&gt; { Class isa OBJC_ISA_AVAILABILITY; } 这个Class是什么? // objc.h中 typedef struct objc_class *Class; // runtime.h中 struct objc_class { Class _Nonnull isa OBJC_ISA_AVAILABILITY; Class _Nullable super_class OBJC2_UNAVAILABLE; // 父类 const char * _Nonnull name OBJC2_UNAVAILABLE; // 类名 long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE;// 该类的实例变量大小 struct objc_ivar_list * _Nullable ivars OBJC2_UNAVAILABLE;// 该类的成员变量链表 struct objc_method_list * _Nullable * _Nullable methodLists OBJC2_UNAVAILABLE;// 方法定义的链表 struct objc_cache * _Nonnull cache OBJC2_UNAVAILABLE;// 方法缓存，对象接到一个消息会根据isa指针查找消息对象，这时会在method Lists中遍历，如果cache了，常用的方法调用时就能够提高调用的效率。 struct objc_protocol_list * _Nullable protocols OBJC2_UNAVAILABLE;// 协议链表 } OBJC2_UNAVAILABLE; objc_class为什么也有个isa?我们知道isa指针指向的是该对象所属的类,对于实例对象的isa指针,我们知道是指向其所属的类,但是实例对象所属的类的isa指针又指向谁呢? 类对象本身也是对象,类本身所属类是 元类!!!所以实例对象所属的类的isa指针指向的是元类。 类1.类对象的实质类对象是由编译器创建的,任何直接或间接继承NSObject的类,它的实例对象(instance object)中都有一个isa指针,指向它的类对象(class object)。这个类对象中存储了关于这个实例对象所属的类的定义的包括变量、方法、遵守的协议等。 因此,类对象能访问所有关于这个类的信息,利用这些信息可以产生一个新的实例,但是类对象不能访问任何实例对象的内容。当调用一个类方法的时候,例如[NSObject alloc]的时候,实际上是发送了一个消息给他的类对象。 2.类对象和实例对象的区别类对象虽然保留了一个该类实例对象的原型,但是不能执行实例方法。然而,类的定义能包括那些特意为类对象准备的方法–类方法。类对象也可以从父类那里继承类方法。 类对象是一个功能完整的对象,所以也能被动态识别(dynamically typed),接受消息,从其他类继承方法。特殊之处是在于它们由编辑器创建,缺少它们自己的数据结构(实例变量)。 元类实际上,类对象是元类对象的一个实例!! 元类描述了一个类对象,就像类对象描述了普通的实例变量一样。不同的是元类的方法列表是类方法的集合,由类对象的选择器来响应。当向一个类发送消息时,objc_msgSend会通过类对象的isa指针定位到元类,并检查元类的方法列表来决定调用哪个方法。 很显然,元类也是对象,也应该是其他类的实例,实际上元类是根类(root class’s metaclass)的实例,而根类是其自身的实例,即根类的isa指针指向自身。 整个指针链就是类的super_class指向其父类,而元类的super_class则指向父类的元类。元类的super class链与类的super_class链平行,所以类方法的继承于实例方法的继承也是并行的。而根元类的super_class指向根元类。 当一个消息发送给任何一个对象的时候,方法检测都是从对象的isa指针开始依次去本类、父类方法列表中寻找。实例方法在类中定义,类方法在元类和根类中定义。 (根类的元类就是根类自己)。 objc_msgSend函数会依据接收者与选择子的类型来调用适当的方法。为了完成此操作,该方法需要在接收者所属的类中搜寻其”方法列表”(list of methods),如果能找到与选择子名称相符的方法,就跳至其实现代码。若是找不到,那就沿着继承体系继续向上查找,等找到合适的方法之后再跳转。如果最终还是找不到相符的方法,那就执行”消息转发”(message forwarding)操作。 objc_msgSend会匹配结果缓存在”快速映射表”(fast map)里面,每个类都有这样一块缓存,若是稍后还向该类发送与选择子相同的消息,那么执行起来的就会快了。 object_getClass(obj)与[obj class]的区别 object_getClass(obj)返回的是obj中的isa指针; [obj class]分为两种情况: 当obj为实例对象时,[obj class]调用的是实例方法: -(Class)class,返回的是isa指针; 当obj为类对象(包括元类和根类)时,调用的是类方法: +(Class)class,返回的结果为其本身。 -(Class)class的实现如下: -(Class)class { return object_getClass(self); } 第一段代码解析来让我们看看第一段代码为什么[self class]和[super class]都是输出的是KNSon。 [self class]根据上面的知识,我们知道[self class]最终会转换为如下形式: id objc_msgSend(son的实例对象self, @selector(class), ...) 消息的接受者是KNBSon的实例对象的self,然后调用他的class方法,它自己没有实现该方法,最终在NSObject中找到该方法的实现,然后返self的isa指针,此时self是KNBSon类的实例对象,那么isa指针也就是指向KNBSon类,所以[self class]返回的是 KNBSon。 [super class]而当使用[super class]调用时,会使用objc_msgSendSuper函数。看下objc_msgSendSuper的函数定义: id objc_msgSendSuper(struct objc_super *super, @selector(class), ...) 第一个参数是个objc_super的结构体,第二个参数还是类似上面的类方法的selector,先看objc_super这个结构体是什么东西 struct objc_super { id receiver; Class superClass; }; 此处上面的结构体转换为如下样式: struct objc_super { KNBSon的实例对象self; KNBFather; }; 那么调用[super class]后的内部流程如下: 当使用[super class]时,这时要转化成objc_msgSendSuper的方法。 想构造objc_super的结构体,第一个成员变量就是self,第二个成员变量就是KNBFather,然后要找class这个selector,先去superClass也就是KNBFather中去找,没有,然后去KNBFather的父类中去找,结果还是在NSObject中找到了。 然后内部使用函数objc_msgSend(objc_super -&gt; receiver, @selector(class))去掉用,此时已经和我们用[self class]调用相同了,因为这里的receiver还是KNBSon的实例对象self,所以这里返回的还是实例对象self的isa指针(指向他的类对象),也就是KNBSon。 总结很多人会想当然的认为”super和self类似,应该是指向父类的指针”。这其实是一个误区。 其实super是一个关键字,他的本质是一个编译器标志符,和self是指向同一个消息接受者!他俩的不同点在于: super会告诉编译器,调用class这个方法(或者其他方法)时,要去父类的方法去找,而不是本类里的。 所以当使用self调用的方法时,会从当前类的方法列表中开始找,如果没有,就从父类中再找;而当使用super时,则直接从父类的方法列表中开始找,不在从当前的类的方法列表中寻找了。- 第二段代码解析第二段代码在KNBFather里面使用self.name = @””调用的是子类的setName方法我们来看下子类实例化的代码 - (instancetype)init { if (self = [super init]) { NSLog(@&quot;[self class] --&gt; %@&quot;,[self class]); NSLog(@&quot;[super class] --&gt; %@&quot;,[super class]); } return self; } 当调用[super init]的时候,消息的接受者依然是KNBSon的实例对象, 只是去查父类中调用init方法去了。在父类执行[self setName]的时候,接受消息的是KNBSon的实例对象,去查询的是KNBSon的方法列表,调用的是KNBSon的 setName方法。 所以我们要注意,如果子类重写了父类的方法,那么不管在子类还是在父类调用发方法,如果是子类调用,最终被执行的方法是子类的方法。 总结我们探讨了一些runtime的特性和机制,由此可见runtime的一些本质,但是也只是管中窥豹,做抛砖引玉之用,欢迎大家探讨。 参考资料: https://www.jianshu.com/p/7b8d834042e4 https://www.jianshu.com/p/1c52810f23d2 https://www.jianshu.com/p/d774ad33d165 https://juejin.im/post/57a9516e7db2a2005aba4809]]></content>
  </entry>
  <entry>
    <title><![CDATA[14.友盟 crash log 错误分析工具]]></title>
    <url>%2F2017%2F10%2F02%2F14.%E5%8F%8B%E7%9B%9F%20crash%20log%20%E9%94%99%E8%AF%AF%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[开发完成,闲置时间对已上线版本进行crash log错误分析,crash展示文件除了帧调用就是内存地址,的确不好看明白 我们用友盟的错误分析工具umcrashtoolhttp://dev.umeng.com/files/download/umcrashtool.zip 第一步:找到上线打包的xcarchive 保证存在就好第二步:去友盟错误统计的网页,下载对应的csv文件第三步:将下载好的错误分析工具和csv文件放到同一目录下第四步: 打开终端输入 ./umcrashtool csv路径 显示结果: 从上到下,是调用堆栈,可以清晰的看出来报错的地方]]></content>
  </entry>
  <entry>
    <title><![CDATA[13.字符串特辑(转载)]]></title>
    <url>%2F2017%2F09%2F20%2F13.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%89%B9%E8%BE%91%2F</url>
    <content type="text"><![CDATA[OC中的NSString不伦是在编译时还是在运行时都做了很多的优化,和普通的对象不同,它是一个比较复杂的存在。 首先我们做下测试: 定义宏方便打印: #if __has_feature(objc_arc) #define Obj_RetainCount(obj) \ CFGetRetainCount((__bridge CFTypeRef)(obj)) #else #define Obj_RetainCount(obj) \ DebugLog(@&quot;%lu&quot;,[obj retainCount]); #endif #define KNLog(_var) NSLog(@&quot;%@ : class = %@ p = %p retainCount = %d&quot;,@#_var,NSStringFromClass([_var class]),_var,Obj_RetainCount(_var)); 测试代码: NSString *a = @&quot;str&quot;; NSString *b = [[NSString alloc]init]; NSString *c = [[NSString alloc]initWithString:@&quot;str&quot;]; NSString *d = [[NSString alloc]initWithFormat:@&quot;str&quot;]; NSString *e = [NSString stringWithFormat:@&quot;str&quot;]; NSString *f = [NSString stringWithFormat:@&quot;123456789&quot;]; NSString *g = [NSString stringWithFormat:@&quot;1234567890&quot;]; KNLog(a); KNLog(b); KNLog(c); KNLog(d); KNLog(e); KNLog(f); KNLog(g); 打印结果: a : class = __NSCFConstantString p = 0x104038110 retainCount = -1 b : class = __NSCFConstantString p = 0x1af4d3c28 retainCount = -1 c : class = __NSCFConstantString p = 0x104038110 retainCount = -1 d : class = NSTaggedPointerString p = 0xa000000007274733 retainCount = -1 e : class = NSTaggedPointerString p = 0xa000000007274733 retainCount = -1 f : class = NSTaggedPointerString p = 0xa1ea1f72bb30ab19 retainCount = -1 g : class = __NSCFString p = 0x1c40366e0 retainCount = 2 可以看到,不同的方式创建的字符串额立新不同,引用计数也有所区别,并不是我们常规理解的对象初始化后引用计数为1.创建的字符串有3种类型 __NSCFConstantString __NSCFString NSTaggedPointerString 造成这种结果的原因是由于OC对字符串做的内存优化。 __NSCFConstantString对变量类型名上就可以看出,这种类型的字符串是常亮字符串。该类型的字符串以字面量的方式创建,保存在字符串常亮区,是在编译时创建的。例如: NSString *a = @&quot;good afternoon!&quot;; NSString *b = [[NSString alloc]initWithString:@&quot;good afternoon!&quot;]; NSString *c = [[NSString alloc]initWithFormat:a]; 对于initWithString实例方法以及stringWithString类方法,编译器会给出redundant警告,原因是该方法创建字符串等同于直接复制字符串字面量。 当创建的字符串变量值在常亮区已经存在时,会指向那个字符串,这是编译器做的优化。 由于是常量,因此其内存管理并不同于对象的内存管理,引用计数用用整形格式打出来始终为-1。 __NSCFString__NSCFString表示对象类型的字符串,在运行时创建,保存在堆区,初始引用计数为1,其内存管理方式就是对象的内存管理方式。该种类型字符串通过format方式创建,并且字符串内容仅由数字、字母和常规ASCII字符构成,且其长度不能太小,否则创建的是NSTaggedPointerString类型。 NSString *d = [[NSString alloc]initWithFormat:@&quot;我是对象&quot;];//__NSCFString NSString *e = [NSString stringWithFormat:@&quot;1234567890&quot;]; //__NSCFString NSTaggedPointerStringNSTaggedPointerString类型的字符串是对__NSCFString类型的一种优化,在运行时创建字符串时,会对字符串内容及长度作判断,若内容由ASCII字符构成且长度较小,这时候创建的字符串类型就是NSTaggedPointerString（标签指针字符串),字符串直接存储在指针的内容中。NSTaggedPointerString类型中字符串引用计数同样为-1,不适用对象的内存管理策略。 NSString *e = [NSString stringWithFormat:@&quot;123456789&quot;]; //NSTaggedPointerString 而上面以同样的方式创建的1234567890字符串却为 __NSCFString 类型。 探究NSDictionary NSArray NSValue NSNumber是否也做了优化#####NSDictionary测试代码如下： NSDictionary *d1 = @{@&quot;aa&quot;:@&quot;11&quot;,@&quot;bb&quot;:@&quot;22&quot;}; NSDictionary *d2 = [[NSDictionary alloc]init]; NSDictionary *d3 = [[NSDictionary alloc]initWithObjectsAndKeys:@&quot;a&quot;,@&quot;1&quot;, nil]; NSDictionary *d4 = [NSDictionary dictionaryWithObjectsAndKeys:@&quot;b&quot;,@&quot;2&quot;, nil]; KNLog(d1); KNLog(d2); KNLog(d3); KNLog(d4); 打印结果: d1 : class = __NSDictionaryI p = 0x7fddbad1e9d0 retainCount = 1 d2 : class = __NSDictionary0 p = 0x7fddbae00dd0 retainCount = -1 d3 : class = __NSDictionaryI p = 0x7fddbad044f0 retainCount = 1 d4 : class = __NSDictionaryI p = 0x7fddbadbd8a0 retainCount = 2 #####NSArray测试代码如下： NSDictionary *d1 = @{@&quot;aa&quot;:@&quot;11&quot;,@&quot;bb&quot;:@&quot;22&quot;}; NSDictionary *d2 = [[NSDictionary alloc]init]; NSDictionary *d3 = [[NSDictionary alloc]initWithObjectsAndKeys:@&quot;a&quot;,@&quot;1&quot;, nil]; NSDictionary *d4 = [NSDictionary dictionaryWithObjectsAndKeys:@&quot;b&quot;,@&quot;2&quot;, nil]; KNLog(d1); KNLog(d2); KNLog(d3); KNLog(d4); 打印结果: d1 : class = __NSDictionaryI p = 0x7fddbad1e9d0 retainCount = 1 d2 : class = __NSDictionary0 p = 0x7fddbae00dd0 retainCount = -1 d3 : class = __NSDictionaryI p = 0x7fddbad044f0 retainCount = 1 d4 : class = __NSDictionaryI p = 0x7fddbadbd8a0 retainCount = 2 NSArray测试代码如下：NSArray *a1 = @[@&quot;1&quot;,@&quot;2&quot;]; NSArray *a2 = [[NSArray alloc]init]; NSArray *a3 = [[NSArray alloc]initWithObjects:@&quot;1&quot;, nil]; NSArray *a4 = [[NSArray alloc]initWithArray:@[@&quot;a&quot;,@&quot;b&quot;]]; NSArray *a5 = [NSArray arrayWithObjects:@&quot;m&quot;,@&quot;n&quot;, nil]; KNLog(a1); KNLog(a2); KNLog(a3); KNLog(a4); KNLog(a5); 打印结果: a1 : class = __NSArrayI p = 0x7fddbae16970 retainCount = 1 a2 : class = __NSArray0 p = 0x7fddbae00ce0 retainCount = -1 a3 : class = __NSArrayI p = 0x7fddbae23ea0 retainCount = 1 a4 : class = __NSArrayI p = 0x7fddbae0ab30 retainCount = 1 a5 : class = __NSArrayI p = 0x7fddbae0ab10 retainCount = 2 NSValue测试代码如下：NSValue *v1 = [NSValue valueWithCGPoint:CGPointMake(10, 10)]; CGPoint point = CGPointMake(20, 20); NSValue *v2 = [[NSValue alloc]initWithBytes:&amp;point objCType:@encode(CGPoint)]; KNLog(v1); KNLog(v2); 打印结果: v1 : class = NSConcreteValue p = 0x7fddbae153e0 retainCount = 2 v2 : class = NSConcreteValue p = 0x7fddbae21fa0 retainCount = 1 NSNumber测试代码如下：NSNumber *n1 = [NSNumber numberWithInt:123456789]; NSNumber *n2 = [NSNumber numberWithInt:1234567890]; int i = 10; NSNumber *n3 = [[NSNumber alloc]initWithBytes:&amp;i objCType:@encode(int)]; KNLog(n1); KNLog(n2); KNLog(n3); 打印结果: n1 : class = __NSCFNumber p = 0xb000000075bcd152 retainCount = -1 n2 : class = __NSCFNumber p = 0xb000000499602d22 retainCount = -1 n3 : class = NSConcreteValue p = 0x7fddbadb4df0 retainCount = 1 结论: 对于NSDictionary、NSArray以及NSValue实例,除了空字典和空字符串,其余实例都遵循对象的内存管理策略。 NSNumber类创建的对于普通数据类型的封装的实例,其内存管理同样做了优化,不遵循对象的内存管理策略。另外可以看到,有些新创建的对象引用计数为1,有些为2.这是因为用类方法创建的实例,系统自动将其置入自动释放池。 mutable variable测试代码如下: //NSMutableString NSMutableString *ms1 = [[NSMutableString alloc]init]; NSMutableString *ms2 = [[NSMutableString alloc]initWithString:@&quot;str&quot;]; NSMutableString *ms3 = [[NSMutableString alloc]initWithFormat:@&quot;str&quot;]; NSMutableString *ms4 = [NSMutableString stringWithFormat:@&quot;str&quot;]; NSMutableString *ms5 = [NSMutableString stringWithFormat:@&quot;123456789&quot;]; NSMutableString *ms6 = [NSMutableString stringWithFormat:@&quot;1234567890&quot;]; XFLog(ms1); XFLog(ms2); XFLog(ms3); XFLog(ms4); XFLog(ms5); XFLog(ms6); //NSMutableDictionary NSMutableDictionary *md1 = [[NSMutableDictionary alloc]init]; NSMutableDictionary *md2 = [[NSMutableDictionary alloc]initWithObjectsAndKeys:@&quot;a&quot;,@&quot;1&quot;, nil]; NSMutableDictionary *md3 = [NSMutableDictionary dictionaryWithObjectsAndKeys:@&quot;b&quot;,@&quot;2&quot;, nil]; XFLog(md1); XFLog(md2); XFLog(md3); //NSMutableArray NSMutableArray *ma1 = [[NSMutableArray alloc]init]; NSMutableArray *ma2 = [[NSMutableArray alloc]initWithObjects:@&quot;1&quot;, nil]; NSMutableArray *ma3 = [[NSMutableArray alloc]initWithArray:@[@&quot;a&quot;,@&quot;b&quot;]]; NSMutableArray *ma4 = [NSMutableArray arrayWithObjects:@&quot;m&quot;,@&quot;n&quot;, nil]; XFLog(ma1); XFLog(ma2); XFLog(ma3); XFLog(ma4); 测试结果如下: ms1 : class = __NSCFString p = 0x7fd31070e6b0 retainCount = 1 ms2 : class = __NSCFString p = 0x7fd310716d40 retainCount = 1 ms3 : class = __NSCFString p = 0x7fd310719910 retainCount = 1 ms4 : class = __NSCFString p = 0x7fd31071b610 retainCount = 2 ms5 : class = __NSCFString p = 0x7fd31071bc40 retainCount = 2 ms6 : class = __NSCFString p = 0x7fd310715350 retainCount = 2 md1 : class = __NSDictionaryM p = 0x7fd31071be00 retainCount = 1 md2 : class = __NSDictionaryM p = 0x7fd31070c270 retainCount = 1 md3 : class = __NSDictionaryM p = 0x7fd310717960 retainCount = 2 ma1 : class = __NSArrayM p = 0x7fd31060d860 retainCount = 1 ma2 : class = __NSArrayM p = 0x7fd310605730 retainCount = 1 ma3 : class = __NSArrayM p = 0x7fd310607f80 retainCount = 1 ma4 : class = __NSArrayM p = 0x7fd310606dc0 retainCount = 2 结论: 可变变量实例均以对象的形式保存在堆中。 color=#0099ff size=12 face=”黑体”]]></content>
  </entry>
  <entry>
    <title><![CDATA[12.Effective Objective-C 2.0读书笔记]]></title>
    <url>%2F2017%2F08%2F17%2F12.Effective%20Objective-C%202.0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[动态绑定 // Messaging (Objective-C) Object *obj = [Object new]; [obj performWith:parameterl and: parameterl2]; 关键区别在于: 使用消息结构的语言,其运行时所应执行的代码由运行环境来决定;而使用函数调用的语言,则有编辑器决定。如果范例代码中调用的函数是多态的,那么在运行时就要按照 虚方法表: 来查出到底应该执行哪个函数实现。而采取消息结构的语言,不论是否多态,总是在运行时才回去查找所要执行的方法。实际上,编辑器甚至不关心接受消息的对象是何种类型。接受消息的对象问题也要在运行时处理,其过程叫做”动态绑定”。]]></content>
  </entry>
  <entry>
    <title><![CDATA[11.关于iOS9.0 ~ iOS9.3 从App Store下载出现不规则奔溃问题]]></title>
    <url>%2F2017%2F07%2F15%2F11.%E5%85%B3%E4%BA%8EiOS9.0~9.3%20%E4%BB%8EApp%20Store%E4%B8%8B%E8%BD%BD%E5%87%BA%E7%8E%B0%E4%B8%8D%E8%A7%84%E5%88%99%E5%A5%94%E6%BA%83%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[这次上线遇到了一个大坑,版本发布上线后,同事的iOS9.1系统的6sp手机运行闪退,而这个手机真机直接跑、扫描二维码安装ipa包,都是没有问题的。 去友盟错误列表反馈报以下错误提示: Application received signal SIGTRAP 最终定位到了P3资源文件的问题上了,图片资源文件里有16位图,显示模式为P3 ⚠️⚠️⚠️原理: 如果你的app需要支持广色域显示的话，那你必须得把target设置成iOS 9.3+，相反，如果你的app不需要支持广色域且你想兼容 iOS 9.3 之前的项目，你就得把资源文件所有的16位的或者显示模式为’P3’图片全都替换成8位模式的SRGB颜色的图片 替换16位模式的SRGB颜色的图片步骤: 1.打一个ipa包,将该文件后缀名.ipa为.zip 2.解压该.zip文件,解压后的目录里面会有一个Payload文件夹 3.打开终端切换到Payload文件下的.app路径 cd ~/路径/appname.app 4.用find命名定位到Asset.car文件 find . -name &apos;Assets.car&apos; 5.使用使用 assetutil 命令导出图片的信息存储到Assets.json文件中 sudo xcrun --sdk iphoneos assetutil --info ./Assets.car &gt; /tmp/Assets.json 6.使用以下命令 打开上步生成的/tmp/Assets.json open /tmp/Assets.json 查找“DisplayGamut&quot;: “P3”,看到&quot;BitsPerComponent&quot; : 16,这个就是要被替换的图片 修改图片: 使用ColorSync实用工具将这个描述文件修改下 指派它的描述文件为sRGB IEC61966-2.1，保存. 至此我们的问题完美解决。]]></content>
  </entry>
  <entry>
    <title><![CDATA[10- 上传App Store 报错 ERROR ITMS-90087:"Unsupported Architectures 解决办法]]></title>
    <url>%2F2017%2F06%2F15%2F10.%E4%B8%8A%E4%BC%A0App%20Store%20%E6%8A%A5%E9%94%99%20ERROR%20ITMS-90087-%20%22Unsupported%20Architectures%20%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%20%2F</url>
    <content type="text"><![CDATA[说明:有些第三方提供商为了方便开发者使用,经常把i386 x86_64 armv7 arm64 等几个平台合并到一起,但是上传App Store的时候需要将i386 x86_64两个平台删除后,才能正常审核。 一、几个重要概念 ARM:ARM处理器,特点是体积小、低功耗、低成本、高性能,所以几乎所有手机处理器都基于ARM,在嵌入式系统中应用广泛。 ARM处理器指令集: armv6 | armv7 | armv7s | arm64都是ARM处理器的指令集,这些指令集都是向下兼容的,例如armv7指令集兼容armv6,只是使用armv6的时候无法发挥出其性能,无法使用armv7的新特性,从而会导致程序执行效率没有那么高。i386 | x86_64是Mac处理器的指令集,i386是针对intel通用微处理器32架构的(虚拟机: iPhone4s iPhone5)。x86_64是针对x86架构的64位处理器(虚拟机: iPhone5S iPhone6 iPhone6S iPhone7 iPhone8 iPhoneX)。 目前iOS移动设备指令集 arm64：真机64位处理器需要本架构 iPhone5S(以及以上)｜ iPad Air｜ iPad mini2(iPad mini with Retina Display) armv7s：真机32位处理器需要本架构 iPhone5｜iPhone5C｜iPad4(iPad with Retina Display) armv7：真机32位处理器需要本架构 iPhone3GS｜iPhone4｜iPhone4S｜iPad｜iPad2｜iPad3(The New iPad)｜iPad mini｜iPod Touch 3G｜iPod Touch4 armv6 设备： iPhone, iPhone2, iPhone3G, 第一代、第二代 iPod Touch（一般不需要去支持） Xcode中指令集相关选项(Build Setting中) (1) ArchitecturesSpace-separated list of identifiers. Specifies the architectures (ABIs, processor models) to which the binary is targeted. When this build setting specifies more than one architecture, the generated binary may contain object code for each of the specified architectures. 指定工程被编译成可支持哪些指令集类型，而支持的指令集越多，就会编译出包含多个指令集代码的数据包，对应生成二进制包就越大，也就是ipa包会变大。 (2) Valid ArchitecturesSpace-separated list of identifiers. Specifies the architectures for which the binary may be built. During the build, this list is intersected with the value of ARCHS build setting; the resulting list specifies the architectures the binary can run on. If the resulting architecture list is empty, the target generates no binary. 限制可能被支持的指令集的范围，也就是Xcode编译出来的二进制包类型最终从这些类型产生，而编译出哪种指令集的包，将由Architectures与Valid Architectures（因此这个不能为空）的交集来确定，例如：比如，你的Valid Architectures设置的支持arm指令集版本有：armv7/armv7s/arm64，对应的Architectures设置的支持arm指令集版本有：armv7s，这时Xcode只会生成一个armv7s指令集的二进制包。再比如：将Architectures支持arm指令集设置为：armv7,armv7s，对应的Valid Architectures的支持的指令集设置为：armv7s,arm64，那么此时，XCode生成二进制包所支持的指令集只有armv7s 在Xcode6.1.1里的 Valid Architectures 设置里， 默认为 Standard architectures(armv7,arm64),如果你想改的话，自己在other中更改。 原因解释如下： 使用 standard architectures (including 64-bit)(armv7,arm64) 参数，则打的包里面有32位、64位两份代码，在iPhone5s（ iPhone5s的cpu是64位的 ）下，会首选运行64位代码包， 其余的iPhone（ 其余iPhone都是32位的,iPhone5c也是32位 ），只能运行32位包，但是包含两种架构的代码包，只有运行在ios6，ios7系统上。这也就是说，这种打包方式，对手机几乎没要求，但是对系统有要求，即ios6以上。而使用 standard architectures (armv7,armv7s) 参数， 则打的包里只有32位代码， iPhone5s的cpu是64位，但是可以兼容32位代码，即可以运行32位代码。但是这会降低iPhone5s的性能。 其余的iPhone对32位代码包更没问题， 而32位代码包，对系统也几乎也没什么限制。 所以总结如下： 要发挥iPhone5s的64位性能，就要包含64位包，那么系统最低要求为ios6。 如果要兼容ios5以及更低的系统，只能打32位的包，系统都能通用，但是会丧失iPhone5s的性能。 （3）Build Active Architecture Only 指定是否只对当前连接设备所支持的指令集编译 当其值设置为YES，这个属性设置为yes，是为了debug的时候编译速度更快，它只编译当前的architecture版本，而设置为no时，会编译所有的版本。 编译出的版本是向下兼容的，连接的设备的指令集匹配是由高到低（arm64 &gt; armv7s &gt; armv7）依次匹配的。比如你设置此值为yes，用iphone4编译出来的是armv7版本的，iphone5也可以运行，但是armv6的设备就不能运行。 所以，一般debug的时候可以选择设置为yes，release的时候要改为no，以适应不同设备。 1）Architectures: armv7, armv7s, arm64ValidArchitectures: armv6, armv7s, arm64生成二进制包支持的指令集： arm64 2）Architectures: armv6, armv7, armv7sValid Architectures: armv6, armv7s, arm64生成二进制包支持的指令集： armv7s 3）Architectures: armv7, armv7s, arm64Valid Architectures: armv7，armv7s 这种情况是报错的，因为允许使用指令集中没有arm64。 注：如果你对ipa安装包大小有要求，可以减少安装包的指令集的数量，这样就可以尽可能的减少包的大小。当然这样做会使部分设备出现性能损失，当然在普通应用中这点体现几乎感觉不到，至少不会威胁到用户体检。 三、制作静态库.a是指令集选择 现在回归到正题，如何制作一个“没有问题”的.a静态库，通过以上信息了解到，当我们做App的时候，为了追求高效率，并且减小包的大小，Build Active Architecture Only设置成YES，Architectures按Xcode默认配置就可以，因为arm64向前兼容。但制作.a静态库就不同了，因为要保证兼容性，包括不同iOS设备以及模拟器运行不出错，所以结合当前行业情况，要做到最大的兼容性。 四、iOS使用lipo 拆分 合并 .a(我们用CBAiDirectSDK.framework为例子) 将需要拆分和合并的.framework和.a文件拷贝出去(保留原文件,拆分合并完直接替换掉) 终端cd到拷贝的CBAiDirectSDK.framework路径,依次查看所有需要合并的lib库所支持的框架类型。 lipo -info CBAiDirectSDK * 输出: Architectures in the &lt;font color=#DC143C size=4 face=&quot;黑体&quot;&gt;fat&lt;/font&gt; file: CBAiDirectSDK are: i386 x86_64 armv7 arm64 * 解释:看到红色的fat了吗,fat file表示这个库里面合并了多于1个框架。 将lib库拆分出armv7、arm64类型的.a: lipo CBAiDirectSDK -thin armv7 -output CBAiDirectSDK_armv7 lipo CBAiDirectSDK -thin arm64 -output CBAiDirectSDK_arm64 找到CBAiDirectSDK_armv7文件,查看下信息(CBAiDirectSDK_arm64相同) lipo -info CBAiDirectSDK_armv7 * 输出:Non-fat file: CBAiDirectSDK_armv7 is architecture: armv7 合并成最终的静态库 lipo -create -output CBAiDirectSDK CBAiDirectSDK_armv7 CBAiDirectSDK_arm64 查看合成支持的框架类型 lipo -info CBAiDirectSDK * 输出: Architectures in the fat file: CBAiDirectSDK are: armv7 arm64 最后替换掉原项目中的CBAiDirectSDK.framework]]></content>
  </entry>
  <entry>
    <title><![CDATA[09- iOS证书申请和使用详情]]></title>
    <url>%2F2017%2F05%2F25%2F09.iOS%E8%AF%81%E4%B9%A6%E7%94%B3%E8%AF%B7%E5%92%8C%E4%BD%BF%E7%94%A8%E8%AF%A6%E6%83%85%2F</url>
    <content type="text"><![CDATA[由于公司近期开始接入个推推送,自己也没有详细的总结过iOS证书相关,今天刚好有时间,也就当个记录吧 一. App ID(bundle idengtifier)App ID一这是每个应用的独立标识,应该是和Xcode中的Bundle Identifier是一致(Explicit)的或匹配(Wildcard)的。App ID字符串通常以反域名格式Company Identifier 例如 “com.apple.garageband”App ID全名会被追加Application Identifier(一般为TeamID),分为两类: * Explicit App ID：唯一的App ID，用于唯一标识一个应用程序。 * Wildcard App ID：含有通配符的App ID，用于标识一组应用程序。 二. Certification 证书 (.cer)1.开发者证书证书是对电脑开发资格的认证,每个开发者账号有一套(2两种): 1) Developer Certification(开发证书)安装在电脑上提供权限: 开发人员通过设备进行真机调试。可以生成副本供多台电脑安装; 2) Distribution Certification(发布证书)安装在电脑提供发布iOS程序的权限: 开发人员可以制做测试版和发布版的程序。不可生成副本,仅有配置该证书的电脑才可使用。 2.推送证书推送证书也分为开发和生产两种,类型分别为APNs Development iOS, APNs Production iOS,该证书在appID配置中创建生成,安装在开发者电脑上。 三. Devices苹果的测试证书、发布证书以及推送证书都有对应的Provisioning Profile文件,来验证当前开发者、当前应用、是否能在该真机设备上测试、安装或者运行。所以,需要对该真机设备的UDID进行注册,生成对应的Provisioning Profiles 四. Provisioning Profiles(授权证书 PP描述文件)授权文件是对设备iPhone、iPad、iPod Touch的授权,文件内记录的是设备的UDID和程序的App ID,也就是被授权的设备即Xcode可以安装或者调试Bundle identifier与授权文件中记录的App id对应的程序 1)Developer Provisioning Profile(开发授权文件)在装有开发证书或者开发证书副本的电脑上使用,开发人员选择该授权文件通过电脑将程序安装到授权文件记录的设备中,也就是可以进行真机调试 2)Distribution Provisioning Profile(发布授权文件)在装有发布证书的电脑上制作测试版本和发布版本的程序。]]></content>
  </entry>
  <entry>
    <title><![CDATA[08-.gitignore相关]]></title>
    <url>%2F2017%2F04%2F15%2F08.gitignore%2F</url>
    <content type="text"><![CDATA[1.作用:利用.gitignore过滤文件，如编译过程中的中间文件，等等，这些文件不需要被追踪管理。内容参考gitHub 2.gitignore无效，不能过滤某些文件 现象：在.gitignore添加file1文件，以过滤该文件，但是通过git status查看仍显示file1文件的状态。 原因：在git库中已存在了这个文件，之前push提交过该文件。.gitignore文件只对还没有加入版本管理的文件起作用，如果之前已经用git把这些文件纳入了版本库，就不起作用了 解决：需要在git库中删除该文件，并更新。然后再次git status查看状态，file1文件不再显示状态。 注意: 先在.gitignore中添加忽略的文件,再去添加文件(待验证)]]></content>
  </entry>
  <entry>
    <title><![CDATA[07-JavaScript && iOS原生交互]]></title>
    <url>%2F2017%2F03%2F15%2F07-JavaScript%20%26%26%20iOS%E5%8E%9F%E7%94%9F%E4%BA%A4%E4%BA%92%2F</url>
    <content type="text"><![CDATA[JavaScript &amp;&amp; iOS原生交互JavaScript &amp;&amp; iOS原生交互第三方框架:WebViewJavascriptBridge 1. 简单用法(OC执行JS)UIWebView在webViewDidFinishLoad里使用 - (nullable NSString *)stringByEvaluatingJavaScriptFromString:(NSString *)script; // 获取当前页面的title NSString *title = [webview stringByEvaluatingJavaScriptFromString:@&quot;document.title&quot;]; // 获取当前页面的url NSString *url = [webview stringByEvaluatingJavaScriptFromString:@&quot;document.location.href&quot;]; 2. OC执行JS &amp;&amp; JS执行OC2.1 JavaScriptCore:iOS7后引用,里面包含常见的对象及协议如下: JSContext：给JavaScript提供运行的上下文环境,通过-evaluateScript:方法就可以执行一JS代码 JSValue：JavaScript和Objective-C数据和方法的桥梁,封装了JS与ObjC中的对应的类型，以及调用JS的API等 JSManagedValue：管理数据和方法的类 JSVirtualMachine：处理线程相关，使用较少 JSExport：这是一个协议，如果采用协议的方法交互，自己定义的协议必须遵守此协议 注: JSContext 和 JSValue : JSVirtualMachine 为JavaScript的运行提供了底层资源,JSContext为JavaScript其提供着运行环境,通过evaluateScript方法就可以执行一段JavaScript脚本,并且如果其中有方法,变量等信息都会被存储在其中以便在需要的时候使用。而JSContext的创建都是基于JSVirtualMachine(initwithVirtualMachine:),如果使用init进行初始化,那么在其内部会自动创建一个新的JSVirtualMachine对象然后调用前边的初始化方法。JSValue是JSContext执行后的返回结果,封装了JS与ObjC中的对应的类型,可以方便的在两种类型之间转换,可以说是JavaScript和Object-C之间互换的桥梁 Objective-C type | JavaScript type ——————–+——————— nil | undefined NSNull | null NSString | string NSNumber | number, boolean NSDictionary | Object object NSArray | Array object NSDate | Date object NSBlock (1) | Function object (1) id (2) | Wrapper object (2) Class (3) | Constructor object (3) JSVirtualMachine : “A JSVirtualMachine instance represents a self-contained environment for JavaScript execution.”，这段话是官方文档中对JSVirtualMachine的定义，我们使用JSVirtualMachine的目的主要有两个：支持JavaScript并发执行，管理用于衔接JavaScript 与 OC(Swift) 代码的对象的内存。 #####2.1 简单直接调用JS代码 // 一个JSContext对象 self.jsContext = [[JSContext alloc] init]; // jscontext可以直接执行JS代码。 [self.jsContext evaluateScript:@&quot;var num = 10&quot;]; [self.jsContext evaluateScript:@&quot;var squareFunc = function(value) { return value * 2 }&quot;]; // 计算正方形的面积 JSValue *square = [self.jsContext evaluateScript:@&quot;squareFunc(num)&quot;]; // 也可以通过下标的方式获取到方法 JSValue *squareFunc = self.jsContext[@&quot;squareFunc&quot;]; // 将参数传进去来调用方法 JSValue *value = [squareFunc callWithArguments:@[@&quot;20&quot;]]; NSLog(@&quot;%@&quot;, square.toNumber); NSLog(@&quot;%@&quot;, value.toNumber); #####2.2 快读调用Block,可以传入参数 JSContext *context = [[JSContext alloc] init]; context[@&quot;log&quot;] = ^() { NSLog(@&quot;+++++++Begin Log+++++++&quot;); // 获取当前参数列表 NSArray *args = [JSContext currentArguments]; for (JSValue *jsVal in args) { NSLog(@&quot;%@&quot;, jsVal); } // 获取当前调用该方法的对象 JSValue *this = [JSContext currentThis]; NSLog(@&quot;this: %@&quot;,this); NSLog(@&quot;-------End Log-------&quot;); }; [context evaluateScript:@&quot;log(&apos;ider&apos;, [7, 21], { hello:&apos;world&apos;, js:100 });&quot;]; // // Output: // +++++++Begin Log+++++++ // ider // 7,21 // [object Object] // this: [object GlobalObject] // -------End Log------- 3.协议、模型实现事先和前端wap协商格式、定义方法的名字和参数的顺序 3.1 定义一个模型 KNOCJSModel 3.2 在该模型实现以下协议(协议中定义需要暴露给js的属性和方法) @protocol KNOCJSObjectProtocol &lt;JSExport&gt; // 在JS中调用时，函数名应该为showAlertMsg(arg1, arg2) // 这里是只两个参数的。 - (void)showAlert:(NSString *)title msg:(NSString *)msg; // JS调用Oc，然后在OC中通过调用JS方法来传值给JS。 - (void)jsCallObjcAndObjcCallJsWithDict:(NSDictionary *)params; @end typedef void (^KNOCJSModelDetailAlertBlock)(NSString * title, NSString *message); typedef void (^KNOCJSModelDetailCallJsBlock)(NSDictionary *dic); @interface ObjCModel : NSObject &lt;JavaScriptObjectiveCDelegate&gt; @property (nonatomic, copy) KNOCJSModelDetailAlertBlock alertBlock; @property (nonatomic, copy) KNOCJSModelDetailCallJsBlock callJsBlock; @end 3.3实现模型 @implementation ObjCModel - (void)showAlert:(NSString *)title msg:(NSString *)msg { if (self. alertBlock) { self.alertBlock(title, msg) } } - (void)jsCallObjcAndObjcCallJsWithDict:(NSDictionary *)params { if (self. callJsBlock) { self. callJsBlock(params); } } @end 3.4 在控制器中webView加载完成的代理中,给JSContext注入模型 #pragma mark - UIWebViewDelegate - (void)webViewDidFinishLoad:(UIWebView *)webView { JSContext *context = [webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;]; // 通过模型调用方法，这种方式更好些。 KNOCJSModel *objectModel = [[KNOCJSModel alloc] init]; context[@&quot;native&quot;] = objectModel; __weak typeof(self) weakSelf = self objectModel.alertBlock = ^(NSString *title, NSString *msg) { dispatch_async(dispatch_get_main_queue(), ^{ UIAlertView *alert = [[UIAlertView alloc] initWithTitle:title message:msg delegate:nil cancelButtonTitle:@&quot;Ok&quot; otherButtonTitles:nil, nil]; [alert show]; }); }; objectModel.callJsBlock = ^(NSDictionary *dic) { dispatch_async(dispatch_get_main_queue(), ^{ // 第一种方式 JSValue *jsParamFunc = context[@&quot;jsParamFunc&quot;]; [jsParamFunc callWithArguments:@[@{@&quot;age&quot;: @10, @&quot;name&quot;: @&quot;lili&quot;, @&quot;height&quot;: @158}]]; // 第二种方式 NSString *alertUserInfo = [NSString stringWithFormat:@&quot;jsParamFunc(&apos;%@&apos;,&apos;%@&apos;,&apos;%@&apos;)&quot;, @10, @&quot;lili&quot;, @158]; [context evaluateScript:alertUserInfo]; }); }; context.exceptionHandler = ^(JSContext *context, JSValue *exceptionValue) { context.exception = exceptionValue; NSLog(@&quot;异常信息：%@&quot;, exceptionValue); }; } 3.5 在html中的body中添加以下代码:(这里要和wap端统一好)‘native’ &lt;div style=&quot;margin-top: 100px&quot;&gt; &lt;h1&gt;Test how to use objective-c call js&lt;/h1&gt; &lt;input type=&quot;button&quot; value=&quot;Call ObjC system alert&quot; onclick=&quot;native.showAlertMsg(&apos;js title&apos;, &apos;js message&apos;)&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;input type=&quot;button&quot; value=&quot;Call ObjC func with JSON and ObjC call js func to pass args.&quot; onclick=&quot;native.jsCallObjcAndObjcCallJsWithDict({&apos;name&apos;: &apos;testname&apos;, &apos;age&apos;: 10, &apos;height&apos;: 170})&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;span id=&quot;jsParamFuncSpan&quot; style=&quot;color: red; font-size: 50px;&quot;&gt;&lt;/span&gt; &lt;/div&gt; 也可自己在控制器中执行js代码调用 - (void)useJSExprot { JSContext *context = [self.webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;]; KNOCJSModel *objectModel = [[KNOCJSModel alloc] init]; context[@&quot;native&quot;] = objectModel; [context evaluateScript:@&quot;objectModel.showAlertMsg()&quot;] } 保留: 1.在Block内都不要直接使用其外部定义的JSContext对象或者JSValue，应该将其当做参数传入到Block中，或者通过JSContext的类方法+ (JSContext *)currentContext;来获得。否则会造成循环引用使得内存无法被正确释放。 2.如果js端的方法是这样的func viewDetailLoginNamePassWord(String name, String passWord) { } 我们可以用第一种: (void)viewDetailLoginName:(NSString *)loginNamePassWord:(NSString *)passWord; 第二种:JSExportAs(viewDetailLoginNamePassWord, -(void)viewDetailLoginNamePassWord:(NSString )loginName psd:(NSString )psd;)http://www.jianshu.com/p/fad8c7844d3e]]></content>
  </entry>
  <entry>
    <title><![CDATA[06-Objectview-C 中变量采用@property的各个关键字的含义]]></title>
    <url>%2F2016%2F12%2F15%2F06-Objectview-C%20%E4%B8%AD%E5%8F%98%E9%87%8F%E9%87%87%E7%94%A8%40property%E7%9A%84%E5%90%84%E4%B8%AA%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%90%AB%E4%B9%89%2F</url>
    <content type="text"><![CDATA[Objectview-C 中变量采用@property的各个关键字的含义1.@property的本质是什么?@property = ivar + getter + setter“属性”(property) = 实例变量 + 存取方法OC2.0开始,系统提供了自动生成设置变量值得方法或获取变量值得方法,让我们有更多的精力放在程序的业务逻辑上 2.ARC下,不显示指定任何属性性关键字时,默认的关键字有哪些?对于基本数据类型默认关键字是:atomic,readwrite,assign 对于普通的OC对象:atomic,readwrite,strong 3.copy关键字3.1 NSString,NSArray,NSDictionary等等经常使用copy关键字,是因为他们有对应的可变类型:NSMutableString、NSMutableArray、NSMutableDictionary；是对应的子类,他们之间可能进行赋值操作,为确保对象中的字符串值不会无意间变动,应该在设置新属性值时拷贝一份 3.2 block 也经常使用copy关键字,这是从MRC遗留下的&quot;传统&quot;,在MRC中,方法内部的block是在栈区的,使用copy可以把它放在堆区;ARC中写不写都行: 对于block使用copy还是strong效果是一样的,但写上copy能够提醒我们:编译器自动对block进行了copy操作。 3.3 小试牛刀: 这个写法会出什么问题 @property (copy) NSMutableArray *array; 3.3.1 添加,删除,修改数组内的元素的时候,程序会因为找不到对应的方法而崩溃,因为copy是复制的一个不可变的NSArray的对象 3.3.2 默认关键字是atomic属性会严重影响性能 4. weak 关键字4.1 在ARC中,有可能出现循环引用的时候,往往要通过让其中一端使用weak来解决,比如delegate代理 4.2 自身已经对它进行一次强引用,没有必要再强引用一次,此时也会使用weak,自定义IBOutlet控件的属性一般也使用weak。 5. assign只会执行基本类型的简单赋值操作,既不保留新值,也不释放旧值。如果使用assign去修饰一个对象,这个对象会立即被释放,assign在被释放的时候是不会把指针设置为nil的,assigin会保留对象的指针地址,形成野指针,这个时候调用该对象的方法(给野指针发送消息)就会崩溃。 6. retain释放旧的对象，将旧对象的值赋予输入对象，再提高输入对象的索引计数为1 7.nonnull:不能为空,用来修饰属性,或者方法的参数,方法的返回值,不适用于assign属性,因为他是专门用来修饰指针的 @property (nonatomic, copy, nonnull) NSString *name; @property (nonatomic, copy) NSString * _Nonnull name; @property (nonatomic, copy) NSString * __nonnull name; 8.nullable:表示可以为空,代码提示会告诉你这个谁能够是可以为空的 @property (nonatomic, copy, nullable) NSString *name; @property (nonatomic, copy) NSString *_Nullable name; @property (nonatomic, copy) NSString *__nullable name; 9.null_resettable:表示get方法不能返回为空,set方法可以为空 ⚠️⚠️⚠️ 必须重写该属性的get方法,保证返回值不为空 tan @property(nonatomic,strong,null_resettable) NSNumber * number;(只有这一种方式) 10.null_unspecified表示不确定是否为空,使用方式有三种: @property(nonatomic,strong) NSNumber *_Null_unspecified height; @property(nonatomic,strong) NSNumber *__null_unspecified height; @property(nonatomic,strong,null_unspecified) NSNumber * height; 11.atomic和nonatomic的区别?11-1.介绍atomic:是原子性,是默认的;系统生成的getter/setter方法会进行加锁操作,注意:这个锁仅仅保证了getter和setter存取方法的线程是安全的, 例如: 线程1调用了某一属性的setter方法并进行到了一半,线程2调用其getter方法,那么会执行完setter操作后,在执行getter操作,线程2会获取到线程1 setter后的完整的值. 当几个线程同时调用同一属性的setter、getter方法时,会get到一个完整的值,但get到的值不可控. 例如: 线程1 调用getter 线程2 调用setter 线程3 调用setter 这3个线程并行同时开始,线程1会get到一个值,但是这个值不可控,可能是线程2,线程3 set之前的原始值,可能是线程2 set的值,也可能是线程3 set的值 说atomic是线程安全的,这个是不准确的。这种安全仅仅是set/get的读写安全,并非真正意义上的线程安全,因为线程安全还有读写之外的其他操作(比如1:如果当一个线程正在get或set时,又有另一个线程进行release操作,可能会直接crash,比如2: 线程1 调用getter 线程2 调用setter 线程3 调用setter 这3个线程并行同时开始,线程1会get到一个值,但是这个值不可控,可能是线程2,线程3 set之前的原始值,可能是线程2 set的值,也可能是线程3 set的值) nonatomic:不是默认的,速度快,线程不安全;如果有两个线程访问同一个属性,会出现数据紊乱 总之:使用nonatomic修饰NSMutableArray对象就可以,而使用锁、dispath_queue来保证NSMutableArray对象的线程安全。 11-2.打造线程安全的NSMutableArray 在《Effective Objective-C 2.0》中第41条:多用派发队列,少使用同步锁中指出:使用”串行同步队列”(serial synchronization queue),将读取操作及写入操作都安排在同一个队列里,即可保证数据同步。而通过并发队列,结合GCD中栅栏块(barrier)来不仅实现数据同步线程安全,还比串行同步队列方式更高效。 在一个并发队列中,读取操作是用普通的块来实现的,而写入操作则是用栅栏块来实现的。栅栏块单独执行,不能与其他块并行。直到当前所有并发块都执行完毕,才会单独执行这个栅栏块。(dispath_barrier_async栅栏块首先查看队列中有没有别的任务执行,如果有则会等待已有的任务执行完毕再执行) 注意: 1.同步栅栏函数与异步栅栏函数相同点: 栅栏函数会在之前的任务都结束后才开始不同点: 同步栅栏函数结束之后才会执行栅栏函数下一行代码,由于没有执行后面的代码,所以不会把后面的任务添加到队列中; 异步栅栏函数结束之后才会执行栅栏函数后面的任务,栅栏函数结束之前,后面的任务代码依然执行,只是把任务添加到队列中,单不会执行任务,只有等栅栏函数结束后才会执行任务。 同步栅栏打印结果 异步栅栏打印结果 主要是看”OperationBarrierSync”与”Hello World的顺序 线程安全的NSMutableArray实现如下: @interface QSThreadSafeMutableArray() @property (nonatomic, strong) dispatch_queue_t MSyncQueue; @property (nonatomic, strong) NSMutableArray* MDataArray; @end @implementation QSThreadSafeMutableArray #pragma mark - init 方法 - (instancetype)initCommon{ self = [super init]; if (self) { //%p 以16进制的形式输出内存地址，附加前缀0x NSString* uuid = [NSString stringWithFormat:@&quot;com.jzp.array_%p&quot;, self]; //注意：_MSyncQueue是并行队列 _MSyncQueue = dispatch_queue_create([uuid UTF8String], DISPATCH_QUEUE_CONCURRENT); } return self; } - (instancetype)init{ self = [self initCommon]; if (self) { _MDataArray = [NSMutableArray array]; } return self; } - (id)objectAtIndex:(NSUInteger)index{ __block id obj; dispatch_sync(_MSyncQueue, ^{ if (index &lt; [_MDataArray count]) { obj = _MDataArray[index]; } }); return obj; } -(NSEnumerator *)objectEnumerator{ __block NSEnumerator *enu; dispatch_sync(_MSyncQueue, ^{ enu = [_MDataArray objectEnumerator]; }); return enu; } - (void)insertObject:(id)anObject atIndex:(NSUInteger)index{ dispatch_barrier_async(_MSyncQueue, ^{ if (anObject &amp;&amp; index &lt; [_MDataArray count]) { [_MDataArray insertObject:anObject atIndex:index]; } }); } - (void)addObject:(id)anObject{ dispatch_barrier_async(_MSyncQueue, ^{ if(anObject){ [_MDataArray addObject:anObject]; } }); } - (void)removeObjectAtIndex:(NSUInteger)index{ dispatch_barrier_async(_MSyncQueue, ^{ if (index &lt; [_MDataArray count]) { [_MDataArray removeObjectAtIndex:index]; } }); } - (void)removeLastObject{ dispatch_barrier_async(_MSyncQueue, ^{ [_MDataArray removeLastObject]; }); } - (void)replaceObjectAtIndex:(NSUInteger)index withObject:(id)anObject{ dispatch_barrier_async(_MSyncQueue, ^{ if (anObject &amp;&amp; index &lt; [_MDataArray count]) { [_MDataArray replaceObjectAtIndex:index withObject:anObject]; } }); } - (NSUInteger)indexOfObject:(id)anObject{ __block NSUInteger index = NSNotFound; dispatch_sync(_MSyncQueue, ^{ for (int i = 0; i &lt; [_MDataArray count]; i ++) { if ([_MDataArray objectAtIndex:i] == anObject) { index = i; break; } } }); return index; } - (void)dealloc{ if (_MSyncQueue) { _MSyncQueue = NULL; } } @end]]></content>
  </entry>
  <entry>
    <title><![CDATA[05-git教程]]></title>
    <url>%2F2016%2F11%2F13%2F05-git%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[SVN: 集中式的版本控制系统. 本地只有文件,没有版本库,所有的代码只在服务器上有版本记录,如果要进行版本的回退,和一些tag操作,必须经过服务器 Git: 分布式版本控制系统,每个人电脑就有版本库.写完代码,先提交到本地的版本,让后提交到服务器上,最后每个电脑都有一个最新的代码 git也要配置服务器, 但是服务器的作用, 只是作为一个中间桥梁供开发人员去同步代码用的. git有机器强大的分支管理,把SVN等远远抛在了后面 1.远程仓库 1.1 创建SSH Key. 在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。使用以下命令创建SSH Key：(替换成你的邮箱地址). $ ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 1.2 在用户主目录中找到.ssh目录,里面有id_rsa(私钥)和id_rea.pub(公钥),打开id_rea.pub并记录下来. 1.3 登录GitHub,打开”Account settings”,”SSH Key”页面,添加Key,把id_rea.pub内容添加进去. git需要在GitHup,OsChina,GitLabel中添加自己的公钥 由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的,GitHub只要知道了你的公钥,就可以在每台电脑上往GitHub推送了. 1.4 添加远程库 在GitHub上创建仓库,使用下面命令,把这个远程的仓库与本地已有的仓库进行关联,之后就可以把本地仓库的内容推送到GitHub仓库了,注意是SSH的,传输相比http稳定 cd 到本地文件 $ git remote add origin git@github.com:WayThought/blog.git git remote 查看远程库的信息 $ git remote origin或者，用git remote -v显示更详细的信息 1.5 从远程库克隆(当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。) cd 到本地文件 $ git clone git@github.com:WayThought/blog.git 这样就把远程的仓库克隆到了本地 2.本地分支管理git status: 查看文件的状态 git add : 提交有修改的文件,由工作区到暂存区 git add 文件名 添加指定修改的文件到暂存区 git add . 添加当前目录所有有修改的文件到暂存区 git commit : 提交暂存区的文件到本地版本库 git commit -m &quot;注释&quot; 文件名 提交指定的文件到本地仓库 git commit -m &quot;注释&quot; 提交所有的文件到本地仓库 (需要提交的改动文件,必须先add加到缓存区,再commit到版本区) git pull和push命令是本地仓库和远程仓库(服务器)打交道的,一般在push之前都会先pull下代码,如果有冲突,解决完冲突再push git pull 从服务器上更新代码到本地仓库,切换到本地需要提交的分支(dev) git pull origin dev 把服务器远程仓库更新的代码拉到本地仓库 git push origin dev 把本地仓库的代码更新推送到服务器上 创建与合并分支(当前分支为master) git branch 查看当前分支 git branch dev origin/dev 切换到分支dev git checkout dev 切换到分支dev git checkout -b dev 创建dev分支,然后切换到dev分支 git merge dev 把dev的工作内容合并到master上(分支A合并分支B,与分支B合并分支A是一样的) 3.版本回退※git log 显示历史记录(写周报或者查看版本号) git reflog 来记录你的每一次命令(版本回退后,可以找到上一个版本的commit id ) git reset --hard HEAD^ 回退到上一个版本 git reset --hard HEAD^^ 回退到上上个版本 git reset --hard HEAD 版本号 回退到指定的版本 注: 如何找回删除的分支 3.1 通过git reflog 命令找到我们需要恢复的信息对应的commit_id (根据log 提交的日期时间) 3.2 通过git branch 新分支名字 对应的commit_id 来建立一个新的分支,吧丢失的东西恢复到新分支上 如何临时修复bug git stash 把工作区的内容暂时隐藏 git stash pop 把工作区的内容显示到当前分支 4.补充:4.1 常用命令:※ git config user.name 查看用户名 git config user.email 查看邮箱地址 git config --global user.name &quot;Your Name&quot; 提交名字 git config --global user.email you@example.com 提交邮箱 git rm &lt;file&gt; # 从版本库中删除文件 git rm &lt;file&gt; --cached # 从版本库中删除文件，但不删除文件 git reset &lt;file&gt; # 从暂存区恢复到工作文件 git reset -- . # 从暂存区恢复到工作文件 git reset --hard # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改 git stash list git stash pop 恢复的同时把stash内容也删了 git checkout -- readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销 git checkout -- . 把工作区的修改全部撤销 git reset HEAD filepathname 来放弃指定文件的暂存区内容 git reset HEAD . 放弃所有暂存区内容 (head相同的两个分支)未add和commit的内容如果checkout另一个分支会带过去 可以来回切换 4.2 常见问题: 4.2.1 git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接： $ git branch --set-upstream dev origin/dev 4.2.2 将本地项目添加到远程的仓库 ※ 1.远程建立仓库,并克隆到本地(例如:storeHouse) 2.将本地的项目拷贝到storeHouse文件中 3.使用 git init 命令 4.使用 $ git remote add origin git@github.com:WayThought/blog.git 5. git add . 6. git commit 7. git push 4.2.3将本地分支推送到远程分支:(如果远程分支不存在则会自动创建分支)git push origin 本地分支名:远程分支名4.2.4 远程分支版本的回退 切换到本地分支对应着的远程分支 git push origin HEAD --force #远程提交回退 4.2.5 删除远程分支 git push origin \-\-delete 远程分支名 4.2.6 强制覆盖分支 ※ 把本地的 develop 分支强制(-f)推送到远程 master git push origin develop:master -f 4.3 补充：查看本地分支与远端分支的差异：git diff master..远程仓库名字/master git tag 标签名 commitId 添加taggit push origin 标签名 将本地tag推到远程 git tag -d 标签名 删除本地taggit push origin –delete 标签名 删除远程tag 5.0冲突5.1常见冲突:第一种: 项目可以打开,报错-&gt;直接去找,对别人的改动要进行沟通决定是否要保留 第二种: 项目打开失败 git status 查看哪个文件冲突(一般是配置文件) open 路径 搜索&quot;===“,删除后没有恢复的话 说明删除错误了 -&gt;重新删除 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD Creating a new branch is quick &amp; simple. ======= Creating a new branch is quick AND simple. &gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1 上面那个是HEAD分支的,下面这个是feature1分支,沟通后决定保留或删除 5.2 pbxproj文件冲突比较麻烦的一种冲突,企业开发经常会遇到project.pbxproj文件冲突的问题,project.pbxproj文件主要包含了以下几项主要信息: 1.工程文件关联信息, 如PBXBuildFile PBXFileReference 2.组织结构分类信息, 如PBXGroup 3.项目工程配置信息, 如XCBuildConfiguration XCConfigurationList 解决办法: 1. 1.1 笨方法1: 由于删除自己的修改的部分还是没有办法打开工程,所以要将上一个版本的project.pbxproj文件导出来，替换掉现有的project.pbxproj文件,但是添加到工程中的文件不见了,后来其实在工程里面看不到了而已,在对应文件目录还是能找到的,只要将这些文件拖一遍到工程里就ok了,(注意看下工程的Compile Sources,有时候会不显示添加的类) 1.2 笨方法2: 将project.pbxproj文件文件中一个版本的的冲突都删除掉,根据编译报的错误去添加对应的类(注意不要重复添加),在对应文件目录还是能找到的,只要将这些文件拖一遍到工程里就ok了 2.预防:需要增加文件时先增加完空文件后立刻check一次，让别人每次改动 pbxproj的时候改动之前check一次，保证有交叉时间是可能性最小 3.将不同分支导致的对象进行重新排序,先排序冲突里面相同的对象,然后是重命名或移动了的对象,最后是两边各自新增的对象,(根据sourceCode进行排序) 5.3 git push 报以下错误:错误 error: RPC failed; result=22, HTTP code = 413 fatal: The remote end hung up unexpectedly fatal: The remote end hung up unexpectedly 解决: 第一种. 将http切换成ssh,在git的config中修改url( changed it to the SSH address, and everything resumed working flawlessly) 第二种. 继续使用http,运行 git config http.postBuffer 524288000 第三种。 git push -u origin 分支(这种没有亲自尝试过,可以试试) 6.0 为什么GitHub需要SSH Key呢因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。 参考资料:廖雪峰的博客]]></content>
  </entry>
  <entry>
    <title><![CDATA[04-Code Review]]></title>
    <url>%2F2016%2F10%2F23%2F04-%E4%BB%A3%E7%A0%81%E5%AE%A1%E6%9F%A5%E6%B8%85%E5%8D%95%2F</url>
    <content type="text"><![CDATA[Code Review目的 1.在项目早起就能发现代码中的bug 2.项目统一代码风格,项目代码更容易维护 3.避免开发人员犯一些很常见,很普通的错误(可预测性检查) 常规项 1.代码能够工作吗？它有没有实现预期的功能，逻辑是否正确等。 2.代码符合你遵循的编程规范吗？通常包括大括号的位置，变量名和函数名，行的长度，缩进，格式和注释等风格是否保持一致。 3.是否存在多余的或是重复的代码？ 4.代码是否尽可能的模块化了？ 5.是否有可以被替换的全局变量？ 6.是否有被注释掉的代码？所有的注释是否是准确的? 7.健壮性：是否考虑线程安全；边界处理是否完整；数据的越界处理；被零除,有没有内存泄漏；逻辑是否健壮；循环引用（block中的self和weakSelf） 安全 1.所有的数据输入是否都进行了检查（检测正确的类型，长度，格式和范围）并且进行了编码？ 2.在哪里使用了第三方工具，返回的错误是否被捕获？ 3.输入的值是够进行了检查和编码？ 4.无效的参数值是否能够处理？ 优化把使用清单作为你的起点，针对特定的使用案例，需要对其进行优化。一个比较棒的方式就是记录下那些在代码审查过程中临时发现的问题，有了这些数据，能够明确常犯的错误，然后可以量身定制一个审查清单。确保删除了那些没有出现过的错误。 代码审查清单 1.基础: iOS规范指南 2.控件的创建尽量放到Setter和Getter中进行懒加载,不要写在viewDidLoad中 3.block中的self需要替换成weakSelf防止循环引用,形成好的习惯。 4.多余控件和控制器的删除。被注释掉的代码是否有必要保留？所有的注释是否是准确的? 5.base类中已经存在满足需求控件和方法不需要再重新定义(例如UITableView及其分页、刷新) 6.手动开启线程要谨慎。 获取认可并且保持更新基本规则是，清单上的人和条目都必须明确，而且，如果可能的话，对于一些条目你可以对其进行二元判断。这样可以防止判断的不一致。定期检查你的清单，以确保各条目仍然是有意义的。 责任：代码编写者，代码审核者共同对代码的质量承担责任。这样才能保证Code Review不是走过场.]]></content>
  </entry>
  <entry>
    <title><![CDATA[03-iOS单元测试]]></title>
    <url>%2F2016%2F08%2F13%2F03-iOS%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[单元测试我是从去年开始写单元测试的,平常也只是使用测试一下接口的测试,最近有时间网上查找下了资料总结一下,也是有个归纳吧 单元测试简介 单元测试是指开发者编写代码,检测代码。合理的利用单元测试可以提高软件的质量 代码检测通常需要预先设置边界条件,因为UI测试的时候,很多边界条件不容易满足。主要针对业务逻辑进行测试,不适合做UI的测试。 MVVM的设计模式,把几乎所有重要的业务逻辑全部封装在视图模型中,通过单元测试就很方便检测条件以及代码质量。 什么方法或者函数需要测试1.私有方法不需要测试,面向对象有一个原则:开闭原则! 暴露在.h中的方法需要测试, 2. 所有跟UI有关的都不需要测试,有UI的交互。MVVM 把小的业务逻辑封装出来,变成可以测试的代码,让程序更加健壮。 3.一般而言,代码的覆盖度大概在50% ~ 70% 苹果自带的XCTest/** 单元测试开始前调用 */ - (void)setUp { [supersetUp]; // Put setup code here. This method is called before the invocation of each test method in the class. } /** 单元测试结束前调用 */ - (void)tearDown { // Put teardown code here. This method is called after the invocation of each test method in the class. [supertearDown]; } /** 测试代码可以写到以test开头的方法中 并且test开头的方法左边会生成一个菱形图标，点击即可运行检测当前test方法内的代码 */ - (void)testExample { // This is an example of a functional test case. // Use XCTAssert and related functions to verify your tests produce the correct results. } /** 测试性能 */ - (void)testPerformanceExample { // This is an example of a performance test case. [selfmeasureBlock:^{ // 测量执行时间的代码放到这里 // Put the code you want to measure the time of here. }]; } 断言命令XCTFail(format…) 生成一个失败的测试； XCTAssertNil(a1, format…)为空判断，a1为空时通过，反之不通过； XCTAssertNotNil(a1, format…)不为空判断，a1不为空时通过，反之不通过； XCTAssert(expression, format…)当expression求值为TRUE时通过； XCTAssertTrue(expression, format…)当expression求值为TRUE时通过； XCTAssertFalse(expression, format…)当expression求值为False时通过； XCTAssertEqualObjects(a1, a2, format…)判断相等，[a1 isEqual:a2]值为TRUE时通过，其中一个不为空时，不通过； XCTAssertNotEqualObjects(a1, a2, format…)判断不等，[a1 isEqual:a2]值为False时通过， XCTAssertEqual(a1, a2, format…)判断相等（当a1和a2是 C语言标量、结构体或联合体时使用,实际测试发现NSString也可以）； XCTAssertNotEqual(a1, a2, format…)判断不等（当a1和a2是 C语言标量、结构体或联合体时使用）； XCTAssertEqualWithAccuracy(a1, a2, accuracy, format…)判断相等，（double或float类型）提供一个误差范围，当在误差范围（+/-accuracy）以内相等时通过测试； XCTAssertNotEqualWithAccuracy(a1, a2, accuracy, format…) 判断不等，（double或float类型）提供一个误差范围，当在误差范围以内不等时通过测试； XCTAssertThrows(expression, format…)异常测试，当expression发生异常时通过；反之不通过；（很变态） XCTAssertThrowsSpecific(expression, specificException, format…) 异常测试，当expression发生specificException异常时通过；反之发生其他异常或不发生异常均不通过； XCTAssertThrowsSpecificNamed(expression, specificException, exception_name, format…)异常测试，当expression发生具体异常、具体异常名称的异常时通过测试，反之不通过； XCTAssertNoThrow(expression, format…)异常测试，当expression没有发生异常时通过测试； 单元测试的适用情况以及覆盖率对于测试用例覆盖度多少合适这个话题,也是仁者见仁智者见智,其实一个软件覆盖度在50%以上就可以成为一个健壮的软件了,要达到70%,80%这些已经非常难了,不过我们常见的一些第三方开源框架的测试用例覆盖率还是非常高的,例如AFNNetWorking的覆盖率高达87%,SDWebImage的覆盖率高达77%]]></content>
  </entry>
  <entry>
    <title><![CDATA[02-Mac上安装oh-my-zsh以及iterm2的使用]]></title>
    <url>%2F2016%2F07%2F03%2F02-mac%E4%B8%8A%E5%AE%89%E8%A3%85oh-my-zsh%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Mac上安装oh-my-zsh 1 克隆项目本地(Mac默认已经安装git) git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh 2 创建一个zsh的配置文件 cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc 备注:~ 代表:你的/home/用户名的目录,假设你的用户名是user,那么~/就是/home/user/. .是代表此目录本身,但是一般可以不写,所以cd ~/. 和 cd ~ 和cd ~/效果是一样的.但是.后面有东西又是另外一个问题,点在文件名头部,代表一个隐藏文件. ~/.local是你的主目录下下一个.local的文件夹的路径,并且从.可以看出,这是一个隐藏文件,使用ls -a显示. 3 设置zsh为默认的shell chsh -s /bin/zsh 4 重启终端生效 5 设置ZSH主题: 5.1 到你的用户名目录 $ cd ~/ 5.2 显示文件(包括隐藏文件),并打开.zshrc $ ls -a $ open .zshrc 5.3 找到 ZSH_THEME=“robbyrussell”,并注释掉(行头加 #),另起一行,换上你喜欢的主题,我使用的ys.zsh-theme(补充:直接在原来的行上替换,有时候会出现替换是失败的情况,所以注释掉原来的,重新写是最好的选择) ZSH_THEME=&quot;ys&quot; 6 补充:卸载oh my zsh：在命令行输入如下命令，回车即可 uninstall_oh_my_zsh iterm2的使用下载地址: http://www.iterm2.com/ 使用: 1.cmd+f 弹出iterm2的查找模式,确认找到的是自己的内容之后,使用tab键,查找窗口将自动变化内容,并将其复制.如果是shift+tab,则自动将查找内容的左边选中并复制. 2.自动使用前-Tab路径,设置perferces-&gt;Profiles-&gt;选中Login shell 和Reuse previous tab&apos;s directory 3.command+d: 垂直分割 command+shift+d: 水平分割 4.系统热键:设置好系统热键之后,将在正常的浏览器或者编辑器等窗口的上面,以半透明窗口的上面,以半透明窗口形式直接调出iterm2 shell-&gt;perferces-&gt;Key-&gt;Hotkey 5.自动完成:输入打头几个字母,然后输入cmd + ; iterm2将自动列出之前输入过的类似命令 6.剪切历史:输入cmd + shift + h iterm2将自动列出剪切板的历史记录.如果需要将剪切板的历史记录保存到磁盘,在Perferences-&gt;General-&gt;Save copy/paste history to disk. 7.全屏切换: cmd + enter 进入和返回全屏模式]]></content>
  </entry>
  <entry>
    <title><![CDATA[01-状态栏]]></title>
    <url>%2F2016%2F06%2F23%2F01-%E7%8A%B6%E6%80%81%E6%A0%8F%2F</url>
    <content type="text"><![CDATA[状态栏typedef NS_ENUM(NSInteger, UIStatusBarStyle) { UIStatusBarStyleDefault = 0, // 白底黑子 UIStatusBarStyleLightContent NS_ENUM_AVAILABLE_IOS(7_0) = 1, 黑底白字 UIStatusBarStyleBlackTranslucent NS_ENUM_DEPRECATED_IOS(2_0, 7_0, &quot;Use UIStatusBarStyleLightContent&quot;) = 1, UIStatusBarStyleBlackOpaque NS_ENUM_DEPRECATED_IOS(2_0, 7_0, &quot;Use UIStatusBarStyleLightContent&quot;) = 2, } __TVOS_PROHIBITED; //默认的值是黑色的-(UIStatusBarStyle)preferredStatusBarStyle{ return UIStatusBarStyleDefault; }如果项目中root是UINavigationController,那我们自己的UIViewController的preferredStatusBarStyle的方法根本不会调用 // 是否隐藏状态栏 (BOOL)prefersStatusBarHidden{ return NO;} http://www.cnblogs.com/ilovelqq/p/4769655.html 参考]]></content>
  </entry>
</search>
